---
title: "C++限制堆和栈的对象空间分配"
date: 2021-03-06
tags: ["高级C++"]
categories: ["C++开发"]
---

一般情况下，创建一个类对象，可以在栈或者堆中分配空间。

比如，这样编写代码，就是在栈中建立类对象

```c++
int main()
{
    A Obj;
}
```

这句代码对于编译器来说可以转换为近似等于下面的代码:

```c++
int main()
{
    obj = 申请栈空间(sizeof(A));
    A(Obj);
    ~A(Obj);
}
```

1.分配好类的栈空间

2.调用类的构造函数

3.在变量生命周期结束的地方调用析构函数(编译器负责识别出在哪里结束)

因此，如果我们想让编译器无法在栈上建立类对象，可以将类的析构函数设为private，因为编译器便无法执行第三步。

------

而动态建立类对象，就是将对象建立在堆空间中，代码如下：

```c++
int main()
{
	A* ptr = new A;
}
```

实际上编译器是怎么理解这句代码的呢?

1.判断对象A是否有重载operator new函数，如果有，使用对象A的operator new函数，否则，使用默认的operator new函数

2.使用operator new函数返回得到的空间指针，调用类的构造函数

因此，如果我们想让编译器无法在堆上建立类对象，可以重载类的operator new函数，再将属性设为private，这样编译器将无法调用类的operator new函数，便达到了限制的目的。

