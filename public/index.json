[{"categories":["心情文学"],"content":"关于恋爱的顺序 1、认识 姓名、背景之类的。 2、了解对方 特殊事件下的选择、性格等。耐心很重要。 3、暧昧 两个人在一起就感觉怪怪的? ","date":"2022-02-06","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E6%81%8B%E7%88%B1/:1:0","tags":["love"],"title":"关于恋爱","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E6%81%8B%E7%88%B1/"},{"categories":["心情文学"],"content":"关于配偶的要求 人这种生物，总是会本能地不断尝试去同化身边的同类，夫妻之间亦是如此。同化可以指思想对齐，例如对同一件事物，可能两个人有着截然不同的看法，然而两个人都想说服对方，使之与自己的观点相同。 ","date":"2022-02-06","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E6%81%8B%E7%88%B1/:2:0","tags":["love"],"title":"关于恋爱","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E6%81%8B%E7%88%B1/"},{"categories":["项目管理"],"content":"项目管理其实也包含着对人员的管理，那么说面试也就是管理人员的第一步了。 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":["面试"],"title":"逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"考察Windows逆向的基础 1、Windows下的调用约定 cdecl:C和C++程序的缺省调用方式，参数堆栈由调用者清除，即外平衡。\rstdcall:通常是Win32 API,堆栈是在函数内部平衡堆栈。\rfastcall: 先用ecx,edx传参，不够就使用stdcall模式。\r2、调试器中的断点类型和原理 CC断点:置指令为CC，使得程序触发异常，之后调试器接管异常。\r内存断点:利用Page读写保护机制，使得程序触发异常，之后调试器接管异常。\r硬件断点:设置DR0-DR7调试寄存器，使得程序触发异常。\r","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["面试"],"title":"逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Linux"],"content":"ubuntu替换apt源 有一些主机使用apt get命令会出现各种问题，那么很有可能是apt源有问题。 可以试试替换阿里云的软件源。 1、修改/etc/apt/sources.list，修改为以下内容 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\r2、执行 apt-get update -y apt-get upgrade -y 3、如果更新出现下面这种问题 The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 3B4FE6ACC0B21F32\r那么执行以下命令，命令中的 公钥编码就是上述问题后面的PUBKEY了。 apt-key adv --keyserver keyserver.ubuntu.com --recv-keys '公钥编码'\r完成后，重新执行步骤2。 ","date":"2022-01-23","objectID":"/posts/linux/ubuntu%E6%9B%BF%E6%8D%A2apt%E6%BA%90/:1:0","tags":["vnc"],"title":"ubuntu替换apt源","uri":"/posts/linux/ubuntu%E6%9B%BF%E6%8D%A2apt%E6%BA%90/"},{"categories":["Linux"],"content":"ubuntu开启远程桌面可视化 首先要让系统具备可视化桌面的能力。 ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:1:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["Linux"],"content":"安装X-Window X-Windows是一款桌面可视化系统。 执行以下命令 sudo apt-get install xserver-xorg sudo apt-get install x-window-system-core sudo apt-get install ubuntu-desktop sudo dpkg-reconfigure xserver-xorg sudo apt-get install gnome-core sudo apt-get install gdm3 xscreensaver sudo apt-get install ttf-arphic* ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:2:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["Linux"],"content":"安装VNC SERVER 关闭VNC SERVER vncserver -kill :1 ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:3:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["心情文学"],"content":"腾讯为了KPI，强迫用户使用WeGame，在未安装WeGame的情况下禁止更新、禁止运行LOL。。。。 只能说腾讯成功恶心到了我这个从来不用WeGame的LOL玩家。 绕过WeGame可以考虑手动下载更新补丁，参考项目 https://github.com/DongJiangYue-Team/CN_LOL_DNF-Client-Patch-Download 其实LOL的更新补丁下载地址规律也很明显，举个例子: \u003c\rhttp://down.qq.com/lol/patch/4266/LOL_V4.2.6.5-V4.2.6.6_PATCH.exe\rreferer: http://down.qq.com/\rUser-Agent: Mozilla/4.0 (compatible; MSIE 9.11; Windows NT 10.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; .TDCH 7.0;)\r\u003e\r\u003c\rhttp://down.qq.com/lol/patch/4266/LOL_V4.2.6.6_PATCH.7z.001\rreferer: http://down.qq.com/\rUser-Agent: Mozilla/4.0 (compatible; MSIE 9.11; Windows NT 10.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; .TDCH 7.0;)\r\u003e\r\u003c\rhttp://down.qq.com/lol/patch/4266/LOL_V4.2.6.6_PATCH.7z.002\rreferer: http://down.qq.com/\rUser-Agent: Mozilla/4.0 (compatible; MSIE 9.11; Windows NT 10.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; .TDCH 7.0;)\r\u003e\r\u003c\rhttp://down.qq.com/lol/patch/4266/LOL_V4.2.6.6_PATCH.7z.003\rreferer: http://down.qq.com/\rUser-Agent: Mozilla/4.0 (compatible; MSIE 9.11; Windows NT 10.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; .TDCH 7.0;)\r\u003e\r把这玩意拷到IDM里面，就能直接下载了。 ","date":"2022-01-21","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/lol%E7%BB%95%E8%BF%87wegame/:0:0","tags":["LOL"],"title":"LOL绕过WeGame","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/lol%E7%BB%95%E8%BF%87wegame/"},{"categories":["Go语言"],"content":"时间戳转换为时间 秒级别转换 timeStamp := 1642429952 timeStr := time.Unix(int64(timeStamp),0).Format(time.RFC3339) fmt.Println(timeStr) 毫秒级别转换 timeStamp := 1642430127727 timeStr := time.UnixMilli(int64(timeStamp)).Format(time.RFC3339) fmt.Println(timeStr) 时间转换为时间戳 秒级别转换 timeStamp := 1642429952 timeStr := time.Unix(int64(timeStamp),0) fmt.Println(timeStr.Unix()) 毫秒级别转换 timeStamp := 1642430127727 timeStr := time.UnixMilli(int64(timeStamp)) fmt.Println(timeStr.UnixMilli()) ","date":"2022-01-17","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/:0:0","tags":["Go","时间"],"title":"Go语言常用时间转换","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"},{"categories":["心情文学"],"content":"​ 突然想起在大学的一些时光，为了防止遗忘，做一些记录。 ​ 还在上高中的我，就早已对课程里面的内容失去了兴趣，我只不过是一个做题的工具人罢了，而到了大学，这种讨厌的情绪则被进一步地强化了。大学里那些杂七杂八的课程我并没有任何想听的意思，能旷就旷，有的时候为了应付点名也会去划下水。 ​ 虽然数学英语这两门其实算是我的强项科目了，但我深知我已经对高数这种高深的学问失去了兴趣，因此我也很早就决定了放弃考研。大学的大部分时间我都在独自地在电脑前胡乱地研究一些逆向技术，由于没有人指导，进步速度可想而知。快期末考试的时候，我可能还处于一节课都没听的状态，整本书对我来说全是新知识，我不得不采取了一个极端的策略，在临近期末的最后一两周，强迫自己把书本上所有的内容全部阅读和理解一遍，然后到了考试的倒数前一天，再做做去年的试卷，就相当于学了一门课这样子。很明显，这样做只能处理一些简单的课程，在遇到一些复杂课程的时候，我依然心里没底，这个时候我只能依托于作弊，因为学号的原因，我经常坐在教室的倒数第二排，当然偶尔也会坐第一排就是了。由于坐我后面的人比我还浪，因此我只能寄希望于坐我前面一排的K叔，K叔也好说话。大学的考试管理很松，在考试的时候，根据情况如果我觉得试卷比较难，可能要凉的时候，我就会把纸条传给K叔，找他要答案。当然作弊也是要承担一定的风险，即便是慎重的我，也有一次在考电子电子技术的时候，被自己的任课老师给抓了，当时我已经独自做完了试卷上的大部分题目，然而为了尽可能及格，还得去找K叔要几道题的答案，任课老师直接没收我的试卷后，我径直走出了考场。其实我在决定作弊的时候，就做好了面对这种情况的准备，无论是什么结果我都能接受，但令我始料未及的是，最后我既没有被学校通报批评，也没有挂科，是压着60分及格线过的，在得知结果的那一刻，我有一种事件载入史册的自豪感。从此我也越来越浪，从偶尔去上课并及格，再到挑战整个学期旷课并及格。 ​ 站在工作了几年后，现在的我的角度来看，对于当时的决定我只能说，我失去了，也得到了，我并不后悔，如果能重来，我只会变本加厉地去学习我想要学的知识，而不是那些无意义的课程。 ","date":"2022-01-17","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%AD%A6%E7%9A%84%E8%AF%BE%E7%A8%8B%E4%B8%8E%E8%80%83%E8%AF%95/:0:0","tags":["大学","考试"],"title":"关于大学的课程与考试","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%AD%A6%E7%9A%84%E8%AF%BE%E7%A8%8B%E4%B8%8E%E8%80%83%E8%AF%95/"},{"categories":["Go语言"],"content":"Sqlite3数据库 项目地址: https://github.com/mattn/go-sqlite3 ","date":"2022-01-16","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Csqlite3%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Go","Sqlite3"],"title":"Go语言操作sqlite3数据库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Csqlite3%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["浏览器框架"],"content":"Cef浏览器框架 1、Chromium不支持需要身份验证的SOCK5代理。 话说我试了几个小时，搜遍全网的资料，最后才得出这么一个结论😭 https://bugs.chromium.org/p/chromium/issues/detail?id=256785 ","date":"2022-01-09","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/:0:0","tags":["CEF"],"title":"CEF浏览器框架","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/"},{"categories":["浏览器框架"],"content":"浏览器命令行设置 1、启动媒体流 //主要是配置开启Media的命令参数，此配置可以允许摄像头打开摄像 settings.CefCommandLineArgs.Add(\"enable-media-stream\", \"1\"); 2、忽略https证书错误 settings.CefCommandLineArgs.Add(\"--ignore-certificate-errors\", \"1\"); 3、设置全局的代理 settings.CefCommandLineArgs.Add(\"proxy-server\", \"127.0.0.1:1080\"); ","date":"2022-01-09","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/:1:0","tags":["CEF"],"title":"CEF浏览器框架","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/"},{"categories":["后端开发"],"content":"paypal开通支付 paypal是国外的一套支付服务系统，基于web来实现。 官方文档:https://developer.paypal.com/docs/ 代码样例:https://demo.paypal.com/us/demo/code_samples 官方文档点进去之后，主页有三种平台文档: 1、For Business:中小型企业解决方案。 2、For Marketplaces and Platforms:大型销售平台? 3、For Enterprise:大型企业支付解决方案。 按我的猜测，应该是规模和等级依次增加吧，这样的话我就选择1，我就想搭建个小型的收费平台而已。 封装好的SDK:https://github.com/go-pay/gopay 新手教程:https://developer.paypal.com/docs/business/get-started/ 1、paypal提供了一个沙盒平台，开发人员可以在上面进行模拟整套支付流程。 首先需要创建一个App，在创建App页面点击创建App按钮即可。 我们会得到一个沙盒APP凭证，里面包含 Account: xxx@business.example.com\rClient-ID: xxxxxx\rSecret: xxxxx\r这个凭证可以通过官方的一个接口，转换成一个Token凭证，即 Client-ID + Secret =\u003e Token，通过这个Token我们可以去访问创建订单、更新订单、捕获订单等其它API，Token存在一个有效期，如果过期了重新登录即可。 paypal默认还会给我们生成商户和用户两个虚拟账户，在https://www.sandbox.paypal.com上登录能查看到付款和收款情况。 2、创建订单 懒得写了。 ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:0:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"总结大致流程如下: 1、服务器使用后台的Client-ID和Secret去登录paypal，获取访问paypal接口的权限。 2、服务器提供接口server_CreateOrder，用于创建订单。 3、客户端传入商品信息至服务器接口server_CreateOrder。 4、服务器接口server_CreateOrder收到订单后，调用paypal API，接口是paypal_CreateOrder，在这里传入商品的价格、订单的设定 (是否要显示收获地址等…)、以及用户完成订单后的重定向地址，最终得到订单的付费URL地址，再返回给客户端。 5、客户端得到付费的URL地址，通过浏览器访问并付费，付费成功后调用服务器给的重定向地址(可以算是接口)，通知服务器我已经付费完成了。 6、在此时，客户端的付费其实并未被paypal认可，只有服务端收到客户端的通知后，去调用paypal_CaptureOrder函数，捕获住订单，paypal才会承认客户已经付费，服务端此时检查订单的状态是否已完成，返回一些信息给客户端即可。 7、服务端在paypal后台已经设定好了webhook地址，当整个订单完成时候，paypal会发送消息通知服务端paypal的webhook接口，服务端此时确定通过付费，进行一系列操作。 ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:1:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"Paypal安全 https://developer.paypal.com/docs/api/info-security-guidelines/ ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:2:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"域名解析 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:0:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"域名起源 一开始，大家都使用IP地址互相访问，但是这样不方便记忆，域名因此出现了。我们访问www.baidu.com的时候，首先会请求DNS服务器，DNS上面存储着A记录，大概可以理解成这样: www.baidu.com -\u003e 14.215.177.39\rwww.google.com -\u003e 74.86.151.167\r有了A记录，我们就能根据域名查询到IP地址。 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:1:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"CNAME CNAME又称别名记录，相当于给A记录的域名再起个小名，相当于域名的域名? www.test.com -\u003e www.baidu.com -\u003e 14.215.177.39\rA - 将域名指向一个IPV4地址\rCNAME - 将域名指向另外一个域名\rAAAA - 将域名指向一个IPV6地址\rNS - 将子域名指向其它DNS服务器解析\rMX - 将域名指向邮件服务器地址\r","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:2:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"NS 解析服务器记录。用来表明由哪台服务器对该域名进行解析。这里的NS记录只对子域名生效。例如用户希望由12.34.56.78这台服务器解析news.mydomain.com，则需要设置news.mydomain.com的NS记录。 NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:3:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["Go语言"],"content":"Go语言编写DLL 测试代码如下 package main import \"C\" import( \"fmt\" ) //export Test func Test(){ fmt.Println(\"hello\") } func main(){ } 关键点如下: 1、还是必须要有package main和main函数。 2、导出的函数前面用//export + 函数名声明，表示需要导出该函数 3、引出包import \"C\" 生成dll文件 go build -buildmode=c-shared -o test.dll main.go ","date":"2021-12-27","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99dll/:0:0","tags":["Go","DLL"],"title":"Go语言编写DLL","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99dll/"},{"categories":["Go语言"],"content":"界面库介绍 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/:0:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"1、fyne 项目地址:https://github.com/fyne-io/fyne 自写的的界面库，语法和qt那种一样，体积较大，编译一个demo也要20MB。 优点:跨平台，维护性好。 缺点:体积较大、自写库。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/:1:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"2、webview 项目地址:https://github.com/webview/webview 基于webkit组件，体积较小。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/:2:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99gui%E7%95%8C%E9%9D%A2/"},{"categories":["数据库"],"content":"Mysql学习 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:1:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Mysql的安装 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Windows平台下: 需要安装Mysql Community Server，下载地址:https://dev.mysql.com/downloads/mysql/ ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:1","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"linux平台下: wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:2","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"安装步骤 1、下载完成后首次启动需要初始化数据库，会得到一个临时密码 另外，mysql5.6版本则没有初始化这一步。 mysqld --initialize --console 2、将mysql安装为系统服务 //安装服务 mysqld -install //移除服务 mysqld -remove 3、使用临时密码登录mysql服务 mysql -u root -p 4、修改root用户密码，并提交 mysql\u003e alter user 'root'@'localhost' identified by '想要设置的密码'; mysql\u003e commit; 5、创建数据库 mysql\u003e create database \u003c数据库名\u003e; 6、Mysql8.0设置远程连接密码 mysql\u003e ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'mypass@123'; 7、Mysql关闭密码策略，分别是Mysq旧版本和新版本两种命令。 mysql\u003e set global validate_password_policy = 0;\rmysql\u003e set global validate_password.policy = 0;\rset global validate_password.mixed_case_count = 0;\rset global validate_password.number_count = 0;\rset global validate_password.special_char_count = 0;\r8、刷新权限 mysql\u003e flush privileges; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:3","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"MySQL语句 1、查询有哪些数据库 mysql\u003e show databases; 2、使用数据库 mysql\u003e use \u003c数据库名\u003e; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:3:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"SQL语句 1、查询数据库中有哪些表 select table_name from information_schema.tables where table_schema='数据库名'; 2、 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:4:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"关于UNIQUE Mysql数据库中可以使用UNIQUE关键字给字段添加唯一索引。需要注意的是，创建唯一的索引的目的不是为了提高访问速度，而是为了避免数据出现重复。唯一索引可以有多个但索引列的值必须唯一，索引列的值运行有空值。创建唯一索引的示例如下: CREATE TABLE URLTABLE( url TEXT COMMENT 'url接口', ip TEXT COMMENT 'IP地址', md5 CHAR(32) UNIQUE COMMENT 'hash值' ); ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:5:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Mysql获取字段去重后的总数 如果一张表中某个字段存在重复的值，我们想去重后获取这个字段值的总数。例如有下列数据库 select count(distinct(去重的字段)) as count from 表名; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:6:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"ClickHouse ClickHouse是俄罗斯Yandex于2016年开源的一个高性能的SQL数据库。我对这个数据库的看法是，如果你的数据只涉及到读和写，不存在对数据的修改和删除，那么你永远可以信任ClickHouse。 ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:0","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"简介 1、对linux比较友好，如果要在windows运行，就必须使用容器了。 相关文档:https://clickhouse.com/docs/zh/ ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:1","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"安装过程 sudo yum install yum-utils sudo rpm --import https://repo.clickhouse.com/CLICKHOUSE-KEY.GPG sudo yum-config-manager --add-repo https://repo.clickhouse.com/rpm/stable/x86_64 ClickHouse语句 查询数据库中所有的表名，以及对应的建表语句 select database,name,create_table_query from `system`.tables where database = 'Test' ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:2","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["CSharp"],"content":"众所周知，自动有了Dnspy这类的反编译工具，C#写的程序如果不加壳，那就差不多把源码送给别人。 而一款商业化的工具，自然是需要加壳工具保护的。 C#端的加壳工具大全:https://github.com/NotPrab/.NET-Obfuscator ","date":"2021-12-14","objectID":"/posts/csharp/csharp%E5%8A%A0%E5%A3%B3%E5%B7%A5%E5%85%B7/:0:0","tags":["加壳"],"title":"C#加壳工具","uri":"/posts/csharp/csharp%E5%8A%A0%E5%A3%B3%E5%B7%A5%E5%85%B7/"},{"categories":["编程工具"],"content":"VS Code学习 VS Code介绍:全能的现代化开发环境，非常适合全栈开发工程师。 下载地址:https://code.visualstudio.com/ ","date":"2021-12-14","objectID":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/:1:0","tags":["VSCODE"],"title":"VSCODE学习","uri":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/"},{"categories":["编程工具"],"content":"基础介绍 1、VS Code默认打开的话只是个资源浏览器和文本编辑器，如果要切换到项目，则需要切换到指定的项目文件夹，在菜单上选择 文件 -\u003e 打开文件夹 即可。 ","date":"2021-12-14","objectID":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/:1:1","tags":["VSCODE"],"title":"VSCODE学习","uri":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"SmartDec反编译器项目地址:https://github.com/smartdec/smartdec 记录 反编译逻辑入口:void Decompilation::work() ","date":"2021-12-06","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/smartdec%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:0:0","tags":["SmartDec"],"title":"SmartDec源码阅读","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/smartdec%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":["反编译"],"content":"SmartDec 项目地址:https://github.com/smartdec/smartdec C++编写的反编译器，需要Qt和Boost库，支持PE和ELF格式的文件反编译。 配置选项参考说明: https://github.com/smartdec/smartdec/blob/master/doc/build.txt 这里记录一下我在编译项目的时候，踩的坑吧: 1、只支持低版本Qt，我使用的版本是4.8.7 2、如果使用高版本的编译器，例如我用的是Visual Studio 2019(v142)，需要改一处代码。 在nc/config.h文件中，屏蔽代码define noexcept throw()，如下所示: /* Define noexcept as throw() for MSVC and GCC \u003c 4.6. */ #if defined(_MSC_VER) # //define noexcept throw() 屏蔽就完事了 #elif defined(GCC_VERSION) \u0026\u0026 (GCC_VERSION \u003c 40600) # define noexcept throw() #endif 项目评价: 缺点:作为一个半成品，几乎无法正常使用，只能作为一个玩具反编译器，反编译项目中给定的example，而且项目已停止维护。 优点:代码不多，其中的代码值得学习参考。 ","date":"2021-12-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:0","tags":["Github"],"title":"反编译项目介绍","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["前端"],"content":"Vue学习 官方文档:https://cn.vuejs.org/v2/guide/index.html Vue简介:Vue是基于javascript编写一个前端框架，也可以理解为是javascript的一个库。 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:0:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"配置Vue环境 1、安装nodejs，nodejs可以理解为javascript版本的服务端。 2、nodejs中内置npm，npm可以理解为像pip、go get之类的javascript库管理工具。 3、安装cnpm，cnpm可以理解为npm的中国版。 npm install -g cnpm --registry=https://registry.npm.taobao.org 4、安装vue-cli，这个网上都说是vue项目的脚手架，我个人感觉就像是一个项目控制台吧，方便构建和管理vue项目。 cnpm install vue-cli -g 5、npm install在下载第三方库时，偶尔会卡住，这个时候可以尝试使用以下命令(从网上搜集的) npm cache clean ipconfig /flushdns git config http.postBuffer 524288000 git config --global http.sslVerify false npm install --registry=https://registry.npm.taobao.org 可能还是github被墙导致的，好像没有什么太好的办法。 6、查看使用的Vue版本 npm list vue 7、查看vue-cli版本 vue --version\r8、使用webpack初始化vue项目，webpack简单来说可以理解为一个项目打包 + 模板化工具。 vue init webpack project_test 项目名必须是全小写 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:1:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"Vue模板详解 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:2:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"搭建VS Code环境 1、安装VS Code https://code.visualstudio.com/ 2、安装VS Code插件 插件Vetur ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:3:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"基础语法 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:4:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"可能遇到的问题 1、error:0308010C:digital envelope routines::unsupported 解决办法:输入以下命令 export NODE_OPTIONS=--openssl-legacy-provider 参考资料:https://github.com/webpack/webpack/issues/14532 参考项目 1、https://github.com/PanJiaChen/vue-element-admin 一个管理后台的项目，可以用来参考学习。 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:5:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["后端开发"],"content":"正向代理与反向代理 无论代理服务器是正向还是反向，基本原理是相同的，如下图所示: 代理原理\"\r代理原理\r 正向代理被客户端所使用，客户端使用自己的代理服务器，可以达到隐藏自身的IP地址，欺骗服务器的效果。 反向代理与正向代理相反，被服务端所使用，服务端使用自己的代理服务器，可以实现隐藏自身真实服务器IP地址，负载均衡等效果。 实现正向代理服务器 1、goproxy:https://github.com/elazarl/goproxy go语言编写的一款代理服务库，支持中间人劫持，代码量小，可定制性强，性能还不错。 不过作者似乎已经很久没有维护过该项目了，我将此代码应用到实际的项目中，发现代码还是存在一些问题的，想要好好地使用还得进行一番源码修复才行哦。 2、mitmproxy:https://github.com/mitmproxy/mitmproxy python编写，维护时间比较长，专门为中间人劫持而制作，暂时没应用过此项目，不太好评价。 ","date":"2021-11-11","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:0:0","tags":["代理","proxy"],"title":"代理服务器开发","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["Linux"],"content":"安装nload工具 nload可以用来查看linux网络流量，用来实时监测网络流量和带宽使用情况。 yum install gcc yum install gcc gcc-c++ gcc-g77 sudo yum -y install ncurses sudo yum -y install ncurses-devel yum install wget #下载源码编译安装 wget http://www.roland-riegel.de/nload/nload-0.7.2.tar.gz tar zxvf nload-0.7.2.tar.gz cd nload-0.7.2 ./configure make make install ","date":"2021-11-10","objectID":"/posts/linux/linux%E5%AE%89%E8%A3%85nload%E5%91%BD%E4%BB%A4/:1:0","tags":["nload"],"title":"linux安装nload命令","uri":"/posts/linux/linux%E5%AE%89%E8%A3%85nload%E5%91%BD%E4%BB%A4/"},{"categories":["Go语言"],"content":"基础类型 整数型:int、uint、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64 浮点类型:float32、float64 布尔类型:bool 字符串类型:string 字符类型:byte、rune 1、Go语言编译器不会对数据类型进行任何隐式转换，int和int32是两种不同的类型。 2、整数型默认值是0，布尔类型默认值是false，字符串默认是空字符串 3、这些基础类型在进行函数参数传递的时候，都是值传递，即会拷贝一份副本传递至函数体内，函数内对参数的修改不会影响到变量本身。 变量声明 有两种声明方式 //第一种是正常的声明 var a int a = 1 var b int = 2 //第二种是类型自动推导 c := 3 d := \"4\" ","date":"2021-11-09","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["笔记","Go"],"title":"Go语言菜鸟系列(二)基础语法","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Go语言"],"content":"Go语言库 需要进行爬围墙:https://golang.org/ 国内网站:https://studygolang.com/dl 学习相关网站 https://www.topgoer.com/ 开发环境IDE 目前使用的是GoLand，下载地址:https://www.jetbrains.com/go/ GoLand是收费软件，需要配合无限试用插件，在GoLand插件市场，搜索Eval Reset，安装插件即可。 安装插件后，在Help -\u003e Eval Reset中，勾选Auto reset before per restart，即每次重启都会重置试用时间。 另外，GoLand这败家玩意可能和自己从官网下载的go语言库有一些不兼容，如果出了什么问题的话，建议从File -\u003e Settings -\u003e GOROOT中让GoLand自己去远程下载SDK。。。。。。 第一个main程序 package main import \"fmt\" func main() { fmt.Println(\"hello world\") } 很明显，package main中的main函数就是程序的入口。 下载第三方库文件 go和python一样拥有第三方库镜像平台，在命令行中使用go get命令就可以下载，但是国内经常会出现无法访问的情况，这个时候需要设置镜像源为国内。 Windows Powershell输入以下命令，切换镜像源，有下面几种: go env -w GOPROXY=https://goproxy.io,direct go env -w GOPROXY=https://goproxy.cn,direct Linux输入以下命令 export GOPROXY=https://goproxy.io,direct 输入go env查看环境变量，来检查设置是否成功。 项目结构 目前我采用的是下面这样的结构: ∨ TrdPackage\r⊙test.go\r⊙goproxy.go\r∨ Util\r⊙string.go\r⊙time.go\r∨ Model\r⊙Student.go\r⊙UrlElement.go\rgo.mod\rmain.go\rTrdPackage目录放一些三方库。 Utils放一些库函数，比如字符串拼接，时间转换之类的小型函数。 Model目录专门用来存放不依赖其它任何包的结构体，因为结构体是一个比较底层的东西。 所谓项目管理，我认为可以比作是建房子，上面的砖头依赖下面的砖头，故下面的砖头不能再去依赖上面的砖头了，难度在于如何划分出哪些代码是下面的砖头。 ","date":"2021-11-08","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["笔记","Go"],"title":"Go语言菜鸟系列(一)环境搭建","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Go语言"],"content":"Go搭建远程动态调试环境 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:0","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"1、安装go语言 yum install epel-release yum install golang ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:1","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"2、安装调试工具Delve #安装dlv go get -u github.com/go-delve/delve/cmd/dlv #寻找dlv的路径 sudo find / -name dlv #软链接到go的路径 ln -s /root/go/bin/dlv $GOROOT/bin #输入dlv测试是否配置成功 dlv ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:2","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"3、配置GoLand 1、选择Tools -\u003e deployment -\u003e Configuration，新建sftp。 2、填写SSH configuration，配置Root path，这里的root path指的是项目的根目录。 3、选中项目，选择Tools -\u003e deployment -\u003e upload to server，将项目上传到服务器上。 4、选择Run -\u003e Edit Configurations -\u003e 新增Go Remote，填写需要连接的host和端口。 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:3","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"4、开始调试 1、远程服务器，在项目目录中，运行 dlv debug --headless --listen=:2345 --api-version=2 2、Goland点击远程调试即可。 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:4","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["x64Dbg"],"content":"x64Dbg是如何绘制程序代码流程图的 首先在C++代码src\\dbg\\analysis\\advancedanalysis.cpp有与代码流程算法与结构生成相关的代码，最后应该是转换成了dot格式吧。 之后在Qt代码src\\gui\\Src\\Gui\\DisassemblerGraphView.cpp有与流程图的显示、缩放之类相关的代码。 ","date":"2021-10-30","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:0:0","tags":["x64Dbg"],"title":"x64Dbg源码阅读记录","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["安全攻防"],"content":"​ Cain工具官方版是一款专业可靠的远程控制命令或密码的软件，Cain工具最新版可以明文捕捉几十种方式的远程密码或口令，支持十几种远程控制或远程传输协议，Cain工具官方版可以用来crack屏保、PWL密码、共享密码、缓存口令、远程共享口令、SMB口令、支持VNC口令解码、Cisco Type-7口令解码等。 ​ 支持的平台:Windows ​ 大概用来做这些事情吧: 1、解密出保存在本地的Wifi密码。 2、嗅探局域网内的机器并进行arp欺骗，可用来盗取密码。 arp欺骗 ARP（Address Resolution Protocol）地址转换协议，工作在OSI模型的数据链路层，在以太网中，网络设备之间互相通信是用MAC地址而不是IP地址，ARP协议就是用来把IP地址转换为MAC地址的。而RARP和ARP相反，它是反向地址转换协议，把MAC地址转换为IP地址。 每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。 总的来说就一句话，在数据包中篡改自己的mac地址，进行中间人攻击。 arp欺骗防御手段: 上层网络保留好各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。 ","date":"2021-10-27","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/cain%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/:0:0","tags":["Cain","Winpcap"],"title":"Cain工具使用","uri":"/posts/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/cain%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"categories":["动态调试"],"content":"x32gui.dll 此模块是调试器界面，核心函数为processMessage，处理着所有的界面消息。 void* Bridge::processMessage(GUIMSG type, void* param1, void* param2) ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"GUI模块 SelectionGet bool SelectionGet(Window window, duint* start, duint* end); 获取指定窗口的光标选中区域。 SelectionSet bool SelectionSet(Window window, duint start, duint end); 设置指定窗口的光标选中区域。 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Memory模块 Read bool Read(duint addr, void* data, duint size, duint* sizeRead); 读取被调试进程内存中指定大小的数据。 Write bool Write(duint addr, const void* data, duint size, duint* sizeWritten); 写入数据到被调试进程的内存中。 RemoteAlloc duint RemoteAlloc(duint addr, duint size); 在被调试器的进程中申请指定大小内存。 GetBase duint GetBase(duint addr, bool reserved = false, bool cache = true); 获取指定地址所在内存区域的基址。 GetSize duint GetSize(duint addr, bool reserved = false, bool cache = true); 获取指定地址所在内存区域的大小。 ReadDword unsigned int ReadDword(duint addr); 读取指定地址四字节大小。 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Main模块 GuiAddLogMessage void GuiAddLogMessage(const char* msg); 在x64Dbg的日志窗口打印一条消息。 GuiDisasmAt void GuiDisasmAt(duint addr, duint cip); 设置反汇编窗口指向的反汇编地址。 DbgIsDebugging bool DbgIsDebugging(); 判断当前调试器是否处于调试状态，未载入文件进行调试返回false，否则返回true。 DbgGetProcessHandle HANDLE DbgGetProcessHandle(); 获取当前被调试进程的句柄 DbgCmdExec bool DbgCmdExec(const char* cmd); 将x64Dbg命令加入执行队列后立即返回。 DbgCmdExecDirect bool DbgCmdExecDirect(const char* cmd); 执行x64Dbg命令，此函数等待命令执行完成才会后返回。 GuiSetFavouriteToolShortcut void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut); 设置收藏工具的快捷键 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Pattern模块 FindMem duint FindMem(duint start, duint size, const char* pattern); 搜索内存中的数据，支持模板匹配 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["C++开发"],"content":"Spd是一个C++的高效日志打印库 项目地址:spdlog: Fast C++ logging library Spd日志库有着自己的一些语法打印格式，详细内容参考 Custom formatting ","date":"2021-10-15","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E6%97%A5%E5%BF%97%E5%BA%93/:0:0","tags":["日志库"],"title":"C++日志库","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["动态调试"],"content":"GDB调试 命令 解释 attach 进程PID 附加进程调试 next 单步步过,简写n step 单布步入,简写s finish 结束当前函数，返回到函数调用点 print 打印地址以及值，简写p info breakpoints 查看当前断点情况 ","date":"2021-10-15","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/gdb%E8%B0%83%E8%AF%95/:0:0","tags":["GDB","调试器","Linux"],"title":"GDB调试","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/gdb%E8%B0%83%E8%AF%95/"},{"categories":["C++开发"],"content":"​ 禁止程序多开其实有两种，一种是启动A1进程，再启动A2进程，A2进程自行退出；另外一种是启动A1进程后，再启动A2进程，A1进程自行退出。 ​ 第一种逻辑相对来说比较简单，随便贴一下网上抄的代码: void 禁止新开() BOOL bRet = FALSE; HANDLE hMutex = ::CreateMutexA(NULL, FALSE, \"random_id\"); if (GetLastError() == ERROR_ALREADY_EXISTS) { CloseHandle(hMutex); ExitProcess(0); } while (true) { printf(\"running...\\n\"); Sleep(1000); } } ​ 第二种逻辑就比较复杂了，核心思路应该是去想办法通知原先的进程，让它自行退出，这里只能给一个简易的版本: void 禁止多开() { HANDLE event = CreateEventA(NULL, true, false, \"random_id\"); SetEvent(event); std::thread th([event]{ ResetEvent(event); WaitForSingleObject(event, INFINITE); ExitProcess(0); }); th.detach(); } ","date":"2021-10-14","objectID":"/posts/c++%E5%BC%80%E5%8F%91/%E7%A6%81%E6%AD%A2%E5%A4%9A%E5%BC%80/:0:0","tags":["高级C++","Event"],"title":"禁止程序多开","uri":"/posts/c++%E5%BC%80%E5%8F%91/%E7%A6%81%E6%AD%A2%E5%A4%9A%E5%BC%80/"},{"categories":["C++开发"],"content":"​ 在开发TCP有关的程序的时候，我们就会遇到粘包的这个单词了。 ​ 首先要知道TCP是\"完美的\"，久经考验的TCP协议能够确保数据被有序而准确地发送和接受，因此粘包问题是个伪问题，本质上其实是应用层接收和发送数据双方之间未做好约定。 ​ 我们都知道发送和接受的数据分别是send和recv，假设客户端发送两次数据，如下: std::string msg1=\"1234\"; send(ConnectSocket, msg1.c_str(), msg1.size(), 0); std::string msg2=\"5678\" send(ConnectSocket, msg2.c_str(), msg2.size(), 0); 客户端发送数据每4个字节当作一帧，那么根据服务端设置的接受数据长度的不同，有以下几种情况: recv和send数据长度相等，数据正常接收。 recv长度小于send数据长度，数据少接收，前面的数据和后面的数据都被破坏。 recv长度大于send数据长度，数据将多接收，前面的数据和后面的数据都被破坏。 //数据正常接受 char buffer1[4]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[4]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); //数据遭到破坏 char buffer1[3]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[3]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); //数据遭到破坏 char buffer1[5]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[5]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); ​ 看到这里，我自己都觉得自己废话多，其实所谓粘包无非就是send和recv的长度不对等而已，网上说的都是屁话。 完美情况下，每次发送约定好的长度，每次接受约定好的长度，什么事都没有。但是由于实际情况比较复杂，例如客户端需要发送文件给服务端，文件的长度是会动态变化的，因此需要自己设计应用层的协议算法，一般来说有下面几种想法: 1、双方约定好数据长度 //客户端 std::string msg=\"1234\"; int msgLen=msg.size(); send(ConnectSocket,\u0026msgLen,4,0) send(ConnectSocket,msg.cstr(),msgLen,0); //服务端 int msgLen = 0; recv(ConnectSocket, (char*)\u0026msgLen, 4, 0); char* pBuf = new char[msgLen]; recv(ConnectSocket, pBuf, msgLen, 0); delete pBuf; 核心思想就是服务端在第一次接收到数据的时候，确认好后续的数据长度。 但是上面的代码有一个潜在的问题，比如客户端连续多次发送数据，由于网络原因存在某一个send没发送出去呢？这样服务端的解析会全乱，因此上述代码还需要进一步优化。 2、以指定字符串标记作为包的结束标志 不管三七二十一，我们自定一个值，例如0xCCDDEEFF，服务端处理每帧数据的时候，会进行判断和分包处理。 ","date":"2021-10-11","objectID":"/posts/c++%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88tcp%E7%B2%98%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/:0:0","tags":["高级C++","TCP"],"title":"浅谈TCP粘包的理解","uri":"/posts/c++%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88tcp%E7%B2%98%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Github碎片"],"content":"brynet 项目地址:https://github.com/Microsoft/vcpkg/tree/master/ports/brynet 这个库的优点是只需要包含头文件就能使用，而且属于小型库，可以很方便地深入底层代码调试分析，方便网络库初学者研究。 但是就功能上看，我的评价是不稳定，慎用。 evpp 项目地址:https://github.com/Qihoo360/evpp 从配置上看，有一个缺点是需要引入很多lib。 从功能上看，我的评价是不好用。 asio2 项目地址:https://github.com/zhllxt/asio2 从配置上看，只需要包含头文件就能使用，有一个缺点是只支持C++ 17，对老项目不友好。 从功能上看，我的评价是还行。 ","date":"2021-10-10","objectID":"/posts/github%E7%A2%8E%E7%89%87/tcp%E9%80%9A%E8%AE%AF%E5%BA%93/:0:0","tags":["TCP","Network"],"title":"TCP通讯库","uri":"/posts/github%E7%A2%8E%E7%89%87/tcp%E9%80%9A%E8%AE%AF%E5%BA%93/"},{"categories":["C开发"],"content":"FreeRDP FreeRDP是由C语言编写的一个远程桌面连接软件，使用标准的RDP协议。 搭建编译环境 1、下载openssl和libusb三方库。 vcpkg.exe install openssl:x86-windows vcpkg.exe install openssl:x64-windows vcpkg.exe install libusb:x86-windows vcpkg.exe install libusb:x64-windows libusb:https://github.com/libusb/libusb/releases OpenSSL:http://slproweb.com/products/Win32OpenSSL.html ","date":"2021-10-09","objectID":"/posts/c++%E5%BC%80%E5%8F%91/freerdp/:0:0","tags":["远程控制"],"title":"FreeRDP开源远程控制","uri":"/posts/c++%E5%BC%80%E5%8F%91/freerdp/"},{"categories":["C++开发"],"content":"Windows创建计划任务 schtasks create | Microsoft Docs ","date":"2021-10-09","objectID":"/posts/c++%E5%BC%80%E5%8F%91/windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/:0:0","tags":["高级C++","Windows"],"title":"Windows应用开发","uri":"/posts/c++%E5%BC%80%E5%8F%91/windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"categories":["Linux"],"content":"Docker容器学习 docker查询容器 docker ps docker进入容器 docker exec -it 容器id ash docker exec -u root -it 容器id ash docker列举本地已有镜像 docker images docker 保存镜像 docker save 镜像仓库名 -o 文件路径 docker 杀掉一个运行中的容器 docker kill 容器id docker查看容器内的标准输出 docker logs 容器id docker拷贝文件 从容器内拷贝至主机 docker cp 容器id:文件路径 文件路径 远程调试Docker内的进程 1、根据容器的id获取容器的pid docker inspect –format {{.State.Pid}} 834e73bf3caa 2、使用nsenter进程gbd调试 nsenter -t 容器PID -m -p gdb -p 容器内进程PID 容器端口映射 端口也可以映射多个 docker run -it -d -p 0.0.0.0:3000:3000 -p 9988:9988 容器镜像名称 设定网络模式 –network host ","date":"2021-10-08","objectID":"/posts/linux/docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/:0:0","tags":["Docker"],"title":"Docker容器学习","uri":"/posts/linux/docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["易语言"],"content":"因为工作的原因，需要判断文件是否为易语言程序，这里稍微记录一下。 首先了解到易语言EXE程序大致上可以分为编译、独立编译、静态编译、黑月编译这几种。 1、读取文件的版本信息 大部分易语言程序的文件说明和产品名称是固定的值。 2、读取程序资源中的MANIFEST数据 判断其中是否含有E.App这个关键字。 这种做法的好处是静态判断，有些程序即便是加了一些稀奇古怪的壳(SE、VMP、SP等)，也依然可以检测出来。 缺点是可能无法检测一些感染了蠕虫病毒的易语言样本。 3、判断xor eax,eax 已知易语言程序代码段第一句为xor eax,eax，所以可以利用它来进行快速检测。 优点是简单、快速。 缺点是只支持静态编译的程序，且部分程序即便是静态编译开头也不是xor eax,eax指令。 4、特征码扫描 易语言程序有太多的特征码，这里就不详细说明了。 这个方法缺点是对于加了壳的程序，需要动态运行起来才能进行识别。 优点是支持一些被蠕虫病毒(例如Synaptics)感染的样本。 ","date":"2021-09-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/:0:0","tags":["易语言"],"title":"如何判断文件是否为易语言程序","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/"},{"categories":["C++开发"],"content":"​ unique_ptr指针的出现是为了解决指针释放的问题，在将指针升级为unique_ptr指针的时候，需要注意这二者之间的区别。 在C++项目中我们一般这样定义头文件: class A; class B { A* a; } 没毛病，非常完美，但是升级到unique_ptr之后: class A; class B { std::unique_ptr\u003cA\u003e a; } 这样实际上是存在隐患的，因为std::unique_ptr需要静态检测类型的大小，我们需要额外声明B的析构函数，像下面这样: class A; class B { std::unique_ptr\u003cA\u003e a; public: ~B() = default; } 总的来说，unique_ptr相较之前的裸指针传递，还是好用的，就是得多撸很多代码… ","date":"2021-09-25","objectID":"/posts/c++%E5%BC%80%E5%8F%91/unique_ptr%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/:0:0","tags":["高级C++"],"title":"unique_ptr使用注意事项","uri":"/posts/c++%E5%BC%80%E5%8F%91/unique_ptr%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":["C++开发"],"content":"以下谈一下自己感想 使用原生数据类型 很多项目喜欢自建自己的数据类型，比如std::vector、std::list，这个项目来一个qvector、qlist，另外一个项目又是QVector、QList。又或者一个很普通的int数据类型，在这个项目中是typedef char int8，另外一个项目又是typedef long long int8。 而这样容易出现头文件不兼容，无法引用各种问题，给我们这些代码搬运工带来了很大的麻烦。这里我只能建议尽可能使用自己的数据类型，例如在Windows平台上我们使用的最多的是vector和string，如果上述方案仍然无法解决，最终的办法是建立自己的中间件，例如封装一个Wrapper类，重新封装一遍要调用的库函数。 ","date":"2021-09-20","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/:0:0","tags":["C++"],"title":"C++个人感想","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"},{"categories":["C++开发"],"content":"​ volatile单词意思为易变的，这里作为关键字是用来提示编译器它后面所定义的变量随时有可能改变。具体看下面这个源码例子: void test() { int a=2; while(1){ if(a==1){ break; } } } ​ 按照C++的编译优化逻辑，汇编伪代码可能会变成下面这个样子: void test() { //申请四个字节堆栈空间 var a=alloc(0x4); //初始化变量a mov a,0x2; //将变量a存储到寄存器上 mov eax,a; while(1){ if(eax==1){ break; } } } ​ 如果像这个样子，即使a的值在其他的地方发生了改变，循环也无法跳出去了。因此我们需要指定volatile关键字，提示编译器不要随便使用寄存器来缓存变量，汇编代码就是这个样子: void test() { //申请四个字节堆栈空间 var a=alloc(0x4); mov a,0x2; while(1){ if(a==1){ break; } } } ","date":"2021-08-17","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["高级C++"],"title":"C++中的volatile关键字","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["Linux"],"content":"​ 在我们遇到与跨平台有关的一些事的时候，估计就会碰上这玩意。Cygwin提供了一个在Windows下面使用Linux环境的平台。 ​ 这个cygwin实现的原理大概就是依赖一个能在windows平台运行的核心库，叫做cygwin1.dll，这个模块提供了底层的Linux API的所有功能，从而达到欺骗linux程序，让它以为自己在linux上面运行的目的。好家伙，这不就是中间人攻击吗？ ​ 而Wine可谓是和Cygwin互补，是linux系统下一个用来模拟windows环境的程序。 ","date":"2021-08-11","objectID":"/posts/linux/cygwin/:0:0","tags":["Cygwin","Wine"],"title":"Cygwin和Wine","uri":"/posts/linux/cygwin/"},{"categories":["反编译"],"content":"​ Ghidra项目地址:https://github.com/NationalSecurityAgency/ghidra ​ 在项目/Ghidra/Features/Decompiler/src/decompile/cpp目录下有一个C++写的开源反编译器。下载下来后一共有consolemain.cc、sleighexample.cc、slgh_compile.cc、test.cc、ghidra_process.cc这五个测试例子。 ​ ghidra_process.cc对应生成的文件decompile.exe。 ​ slgh_compile.cc对应生成的文件sleigh.exe。 ​ test.cc是一些测试代码，不用管。 ​ ​ 项目代码适用于linux上的编译器，因为其使用了linux下的bfd库，如果要移植到windows平台上，就得重写项目中loadimage_bfd.hh和loadimage_bfd.cc这两个文件。 项目文件介绍 项目中有doccore.hh和docmain.hh这两个帮助文档。 代码中还有几个比较有有用的例子，例如consolemain.cc、sleighexample.cc、slgh_compile.cc，可以让我们快速理解代码的运行。 类 说明 UserPcodeOp 用户自定义的Pcode操作指令，指令类型都属于CALLOTHER Pattern 指令匹配模板 StringManager 字符串管理类 ParamList 函数参数列表 Symbol 符号相关 Scope 命名空间或者函数范围，用来区分Symbol符号 Datatype 变量、函数的数据类型 Action 用来表示代码具体执行的行为动作。 LoadImage 二进制文件加载至映像内存中 Architecture 针对LoadImage实例化的处理器类 Translate 根据处理器将指令数据转换为汇编代码或者pcode。 PrintLanguage 生成高级语言 PcodeEmit Pcode生成器 TransformManager 根据数据流对代码逻辑进行转换 MemoryBank 用来表示二进制文件中的虚拟内存 JumpModel 跳转表模型 TypeModifier 类型修饰符 Emulate 基于Pcode的代码模拟执行 Widener 值扩展类，将值的字节大小自动进行扩充。 CapabilityPoint 反编译器的扩展能力。 Rule 用来表示反编译规则。 FlowBlock 控制流基本块。 TypeOp Op指令的类型大全 Address 用来表示地址，主要是用来存储offset这一个字段。 P-Code p-code 可以理解为一种新的指令集，能够适用于任何处理器的语言。 结构体解读 1、Varnode 变量节点，可以理解为pCode指令对应的变量，一个变量节点可以用来表示任何数据，包括寄存器、堆栈、内存、常量。 不同变量节点通过Address来进行标记。 2、FuncData 函数可以理解为Ghidra重要的反编译基本单位，此结构体包含与函数反编译有关的一切。 包含控制流、数据流、数据类型信息、跳转表、参数，其中比较重要的几个函数有: startProcessing()，开始对函数进行基本的分析。 followFlow()，跟踪代码流程，并根据遇到的每句汇编指令生成原始的PCode。 printBlockTree()，打印出控制流结构体。 numCalls()，getCallSpecs()，可用来遍历函数内的call指令信息。 源码解读 1、initializeProcess函数(DecompInterface.java) -\u003e 2、decompProcess.registerProgram函数 文件 类 说明 DecompInterface.java DecompInterface 与反编译进程通讯的接口类 Program.java Program 用来表示一个完整的程序，包括内存、函数、标签、符号等。 ","date":"2021-08-09","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8/:0:0","tags":["Ghidra"],"title":"Ghidra反编译器","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8/"},{"categories":["反编译"],"content":"​ 懒癌犯了，这里简要介绍一下吧。 ​ MinGw就是一个编译器，你可以理解为和Visual Studio差不多的一个玩意儿，只不过MinGw更原始质朴，Visual Studio则进行了大量封装。 ​ 比较好的下载地址是:[sourceforge](https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win64/Personal Builds/mingw-builds/) ​ 下载完成后，bin目录下有一个mingw32-make.exe程序，这个就是强大的make指令了，可以像linux上那样根据makefile文件进行make 编译。 ","date":"2021-08-09","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/mingw/:0:0","tags":["编译器"],"title":"MinGW编译器","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/mingw/"},{"categories":["Github碎片"],"content":"​ 项目地址:zneak/x86doc: HTML representation of the Intel x86 instructions documentation ​ 作者将Intel官方的指令集PDF手册转换成了HTML文档，转换后的结果如下:http://www.felixcloutier.com/x86，可以很方便地进行查阅。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E6%96%87%E6%A1%A3/:0:0","tags":["指令集","x86","amd64"],"title":"Intel指令集文档","uri":"/posts/github%E7%A2%8E%E7%89%87/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E6%96%87%E6%A1%A3/"},{"categories":["Github碎片"],"content":"nlohmann json nlohmann/json: JSON for Modern C++ 这可能是github上star数目最多的一个json库了，只需要包含一个头文件即可快速将库添加至开发环境，并且简单易用，快速上手。 用了这个库后，我就再也没有用过其它的了。 缺点:好像只支持utf-8。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/json%E8%A7%A3%E6%9E%90%E5%BA%93/:0:1","tags":["json"],"title":"json解析库","uri":"/posts/github%E7%A2%8E%E7%89%87/json%E8%A7%A3%E6%9E%90%E5%BA%93/"},{"categories":["Github碎片"],"content":"URL Parser 解析引擎似乎存在Bug? hcs-url 似乎无法对有缺失的URL进行解析。 EdUrlParser 功能太简单了。 CxxUrl 兼容性似乎不太行。 Url Parser 需要引入Boost三方库 Simple Url Parser 各方面都不错，但是似乎设计的解析结果不太合理? homer Url Parser seomoz Url Parser URL Dedupe 懒得评测了。 LUrlParser 最终我选用的是这款，虽然功能依旧比较简单，无法满足我的需求。 但是感觉代码写得不错，简单易读，可拿来根据自己的需求进行改造。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/url%E8%A7%A3%E6%9E%90%E5%BA%93/:0:0","tags":["parser","URL"],"title":"URL解析库","uri":"/posts/github%E7%A2%8E%E7%89%87/url%E8%A7%A3%E6%9E%90%E5%BA%93/"},{"categories":["Github碎片"],"content":"​ 首先简单介绍一下kafka吧。 Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。 主要应用场景是：日志收集系统和消息系统。 Kafka主要设计目标如下： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out:支持在线水平扩展 ​ 显然，有了这么牛逼的东西，我们可以对方便地存储数据和消费数据了，为了编写代码，我们需要用到kafka的第三方库。 ","date":"2021-07-26","objectID":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/:0:0","tags":["kafka"],"title":"kafka三方库","uri":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["Github碎片"],"content":"librdkafka 项目地址:https://github.com/edenhill/librdkafka 这玩意要是自己手动安装会比较累，因此这里推荐使用vcpkg进行安装，可以参考一下项目介绍中的命令行，可以很方便地得到所需要的库文件。 另外项目中作者也提供了很多用来学习的示例代码，参考这个东西就行了。 ","date":"2021-07-26","objectID":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/:0:1","tags":["kafka"],"title":"kafka三方库","uri":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["QQ"],"content":"利用QQ群的查询接口来获取QQ群的一些信息。接口: https://qun.qq.com/cgi-bin/group_search/pc_group_search post数据: 传递值 说明 选项 keyword 关键字，可为QQ群号,QQ群名称 必填 wantnum 想要查询的个数 必填 from 来源，填1 必填 在发送请求时，需要携带好QQ的Cookie。 请求返回值示例如下: {\"ec\":0,\"errcode\":0,\"em\":\"\",\"keywordSuicide\":0,\"exactSearch\":1,\"gTotal\":1,\"endflag\":1,\"penetrate\":\"eyJwb3MiOjEsInAiOiJ7XCJyZWNvbW1lbmRcIjp0cnVlfSJ9\",\"usr_cityid\":null,\"exact\":1,\"group_list\":[{\"code\":633783602,\"owner_uin\":425063169,\"name\":\"E-debug兴趣小组\",\"class\":27,\"class_text\":\"\",\"dist\":null,\"face\":0,\"flag\":150995985,\"flag_ext\":2163040,\"geo\":null,\"gid\":633783602,\"latitude\":\"0\",\"level\":0,\"longitude\":\"0\",\"max_member_num\":500,\"member_num\":175,\"group_label\":[{\"item\":\"文件多\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"00cafc\"},{\"item\":\"管理员活跃\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"c573ff\"},{\"item\":\"男生多\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"ff80ca\"}],\"memo\":\"E-debug Plus插件交流与反馈群.https:github.comfjqisbaE-debug-plus\",\"richfingermemo\":\"\",\"option\":2,\"app_privilege_flag\":67731665,\"url\":\"http:\\/\\/p.qlogo.cn\\/gh\\/633783602\\/633783602\\/140\",\"calc\":null,\"join_auth\":\"iGo2gTpSQ3GUGtZJkOrvSQCfjWanN9xTC0wCfnVGo0RRyc+kZC0llDIFthXkv0j1\",\"certificate_type\":0,\"certificate_name\":\"\",\"bitmap\":1024,\"labels\":[{\"label\":\"王者荣耀\",\"tagid\":\"1955f30159a44e2800005e21\",\"time\":1503940136},{\"label\":\"小学生\",\"tagid\":\"1955f30159a44e2d0000ab6a\",\"time\":1503940141},{\"label\":\"PUBG\",\"tagid\":\"1955f3015a3a53fb0000dc32\",\"time\":1513772027}],\"uin_privilege\":1,\"activity\":9,\"cityid\":10282,\"qaddr\":[\"江西省\",\"上饶市\"],\"gcate\":[\"人物\"]}]} 其中group_list.option这个值表示QQ群的加群方式，有以下几种: option1:允许任何人加群 option2:需要验证消息 option4:需要正确回答问题 option5:需要回答问题并由管理员审核 ","date":"2021-07-23","objectID":"/posts/qq/qq%E7%BE%A4%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/:0:0","tags":["协议逆向"],"title":"QQ群查询信息协议","uri":"/posts/qq/qq%E7%BE%A4%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/"},{"categories":["QT"],"content":"​ Qt中控件中的弹出菜单(ContextMenu)，依据ContextMenuPolicy的值的不同，有五种形式： 一、无菜单 此时,ContextMenuPolicy的值为Qt::NoContextMenu 二、默认菜单 此时，ContextMenuPolicy的值为Qt::DefaultContextMenu，这是默认值，其将显示控件定义的默认菜单 三、由Action定义菜单 此时，ContextMenuPolicy的值为Qt::ActionsContextMenu,要为此部件定义这种菜单，很简单，只要把已经定义好的Action部件插入到要显示此菜单的部件中，部件将自动按顺序显示菜单。 QWidget::addAction(QAction *action); 四、自定义菜单 此时，ContextMenuPolicy的值为Qt::CustomContextMenu，这回，有两种方式来定义菜单，一种是响应 customContextMenuRequested(const QPoint\u0026)这个signal，在响应的槽中显示菜单(QMenu的exec()方法)。第二种是需要从这个部件的类中派生一个类，重写contextMenuEvent()这个函数显示菜单(QMenu的exec()方法显示)。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/:0:0","tags":["入门","新手教程"],"title":"QT控件中的菜单","uri":"/posts/qt/qt%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"categories":["QT"],"content":"在QT的开发中，免不了要用到列表(QListWidget)这个控件。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:0","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["QT"],"content":"一、初始化表格 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:1","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["QT"],"content":"信号大全 QListWidget控件的信号 void itemPressed(QListWidgetItem *item); void itemClicked(QListWidgetItem *item); void itemDoubleClicked(QListWidgetItem *item); void itemActivated(QListWidgetItem *item); void itemEntered(QListWidgetItem *item); void itemChanged(QListWidgetItem *item); void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous); void currentTextChanged(const QString \u0026currentText); void currentRowChanged(int currentRow); void itemSelectionChanged(); itemPressed，当在项目上按下鼠标按钮时，此信号随指定项目一起发出 。 itemClicked，当在项目上单击鼠标按钮时，此信号随指定项目一起发出。 itemDoubleClicked，当在项目上双击鼠标按钮时，此信号随指定项目一起发出。 itemActivated，当项目被激活时发出这个信号。 当用户单击或双击它时，该项目将被激活，具体取决于系统配置。 当用户按下激活键时它也会被激活（在 Windows 和 X11 上这是返回键，在 Mac OS X 上是 Command+O）。 itemEntered，当鼠标光标进入一个项目时发出这个信号，item指针指向进入的项目。 此信号仅在mouseTracking选项开启，或者在鼠标光标移动进入项目的过程中按下鼠标按钮时发出。 itemChanged，每当 item 的数据发生变化时，就会发出此信号。 currentItemChanged，每当当前选中项发生改变时就会发出此信号。 previous 是先前具有焦点的项目； current 是新的当前项目。 currentTextChanged，每当当前选中项发生改变时就会发出此信号。 currentText 是当前选中项中的文本数据。 如果当前项为空，则 currentText 无效。 currentRowChanged，每当当前选中项发生改变时就会发出此信号。currentRow是当前项的行，如果没有当前项，则为-1。 itemSelectionChanged，每当当前选中项发生改变时就会发出此信号。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:2","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["杂文"],"content":"1.注册表检测 [HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS] “SystemManufacturer”=“VMware, Inc.” 根据SystemManufacturer中的内容计算出一个hash值，判断是否为0x6A7BDBF4。 可以通过修改注册表来绕过此检测。 2.特权指令检测 通过以下代码来检测是否在虚拟机内 bool IsInsideVMWare() { bool rc = true; __try { __asm { push edx push ecx push ebx mov eax, ‘VMXh’ mov ebx, 0 // 将ebx设置为非幻数’VMXH’的其它值 mov ecx, 10 // 指定功能号，用于获取VMWare版本，当它为0x14时用于获取VMware内存大小 mov edx, ‘VX’ // 端口号 in eax, dx // 从端口dx读取VMware版本到eax //若上面指定功能号为0x14时，可通过判断eax中的值是否大于0，若是则说明处于虚拟机中 cmp ebx, ‘VMXh’ // 判断ebx中是否包含VMware版本’VMXh’，若是则在虚拟机中 setz [rc] // 设置返回值 pop ebx pop ecx pop edx } } __except(EXCEPTION_EXECUTE_HANDLER) //如果未处于VMware中，则触发此异常 { rc = false; } return rc; } 目前没有找到什么好办法，可以在虚拟机vmx文件中加入以下配置绕过检测: monitor_control.restrict_backdoor = TRUE\r但这样有一个缺点就是会使Vmware Tools工具失效。 3.vpcext指令检测 DWORD __forceinline IsInsideVPC_exceptionFilter(LPEXCEPTION_POINTERS ep) { PCONTEXT ctx = ep-\u003eContextRecord; ctx-\u003eEbx = -1; // Not running VPC ctx-\u003eEip += 4; // skip past the \"call VPC\" opcodes return EXCEPTION_CONTINUE_EXECUTION; // we can safely resume execution since we skipped faulty instruction } // high level language friendly version of IsInsideVPC() bool IsInsideVPC() { bool rc = false; __try { _asm push ebx _asm mov ebx, 0 // Flag _asm mov eax, 1 // VPC function number // call VPC _asm __emit 0Fh _asm __emit 3Fh _asm __emit 07h _asm __emit 0Bh _asm test ebx, ebx _asm setz [rc] _asm pop ebx } // The except block shouldn't get triggered if VPC is running!! __except(IsInsideVPC_exceptionFilter(GetExceptionInformation())) { } return rc; } 这套代码是用来检测VPC虚拟机的，Vmware不用管。 4.cpuid指令检测 据说是检测cpuid一号功能 ecx的最高位。 .vmx文件中添加下面配置可绕过检测。 cpuid.1.ecx = \"0111:1111:1101:1010:1111:1011:1011:1111\"\r有一些AMD处理器的电脑似乎不支持上面的配置，修改后会无法正常启动虚拟机。这个时候添加下面的代码: hypervisor.cpuid.v0 = \"FALSE\"\r参考资料 sanbarrow.com 绕过SE的虚拟机检测 ","date":"2021-07-04","objectID":"/posts/%E6%9D%82%E6%96%87/se%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/:0:0","tags":["SafeEngine"],"title":"SE过虚拟机检测流程","uri":"/posts/%E6%9D%82%E6%96%87/se%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/"},{"categories":["杂文"],"content":"​ x64Dbg的Ctrl+G功能，有的时候能够自动补全Api名称，有的时候不行，我一开始没太注意这个功能，后来观察x64Dbg的源码才发现，作者设置了x32Dbg.ini两个配置项，CaseSensitiveAutoComplete和DisableAutoComplete。 CaseSensitiveAutoComplete：用来设置补全功能是否大小写敏感。 DisableAutoComplete：是否禁用自动补全功能。 将这两个配置项都设置为0就好了。 ​ ","date":"2021-07-04","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%BC%80%E5%90%AF%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/:0:0","tags":["x64Dbg"],"title":"x64Dbg开启补全功能","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%BC%80%E5%90%AF%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/"},{"categories":["产品试用"],"content":"​ 在起手开发一个程序的时候，我们总是想先决定好程序的图标，毕竟只有图标选好了，程序的代码才放心敲下去不是吗？ 图标素材库 https://www.flaticon.com http://flat-icon-design.com http://www.fontawesome.com.cn/ 将任意图片转成ico格式的工具:https://icofx.ro 在线抠图 https://www.shiliuai.com/koutu/ 在线PS https://www.photopea.com/ ","date":"2021-06-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E5%9B%BE%E6%A0%87%E8%AE%BE%E8%AE%A1/:0:0","tags":["开发","图标"],"title":"图标设计","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E5%9B%BE%E6%A0%87%E8%AE%BE%E8%AE%A1/"},{"categories":["易语言逆向"],"content":"要研究易语言，第一步应该是要将语言中出现的代码进行分类，转换成更低一级的中间指令。 函数头: 易语言的函数头部，都由以下两条指令组成。 push ebp\rmov ebp,esp\r申请局部变量空间 如果函数内含有局部变量，那么编译器便会通过下列指令申请变量空间，指令会紧跟着易语言函数头。 sub esp,0x4\r局部变量初始化 局部变量初始化指令会紧跟着申请局部变量空间指令，默认数据类型都是初始化为0 mov dword ptr ss:[ebp-0x4],0x0\rmov dword ptr ss:[ebp-0x8],0x0\rmov dword ptr ss:[ebp-0xC],0x0\r文本型局部变量赋值 易语言的文本型变量，可以理解为const char*，因此常量赋值无需拷贝，直接传递eax即可。 mov eax,0x47B2FB\r如果是变量赋值给一个另外一个变量，那么易语言会通过以下指令进行拷贝。 mov eax,dword ptr ss:[ebp-0x4]\rtest eax,eax\rje short $+18\rpush eax\rmov ebx,eax\rcall Strlen //获取字符串长度\rinc eax\rpush eax\rcall AllocMemory //申请新内存\rpop ecx\rpop esi\rmov edi,eax\rrep movs byte ptr es:[edi],byte ptr ds:[esi] //字符串拷贝\r字节集局部变量赋值 易语言的字节集类型变量，本质上是一块存储了大小的Buffer，常量可通过直接传递eax来进行赋值。 mov eax,0x47B2B3\r如果是变量赋值给一个另外一个变量，那么易语言会通过以下指令进行拷贝。 test eax,eax\r易语言的类 push 0x4\rcall malloc\radd esp,0x4\rmov var,eax\rmov ebx,eax\rmov dword ptr ds:[ebx],0x0\rmov dword ptr ds:[ebx],classVt\r1.类的构造函数不在虚表中，而会直接以call的形式进行调用。类的析构函数是虚表中的第一个函数。 2.如果类含有继承类，那么这两个类函数合并使用一张虚表，构造函数 = 父类构造函数 + 子类构造函数。 类的析构函数同样是虚表中的第一个函数，析构函数 = 子类的析构函数 + 父类的析构函数。 ","date":"2021-05-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/:0:0","tags":["IDA","特征码","易语言"],"title":"易语言模块函数特征码识别","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"categories":["反编译"],"content":"递归下降分析法 如果我们需要对某一段代码进行流程分析，那么首先需要思考一下这些代码有什么特点。 这些代码有一个非常重要的特点是，cpu执行指令的时候默认逻辑是按照地址从上往下执行的. 我们可以根据这个特定，来制定一个递归下降分析代码的算法。 首先，对cpu指令进行以下几种分类: 普通指令(push,call) 无条件跳转指令(jmp) 条件跳转指令(jcc) 结束指令(ret) 分析引擎的关键点如下: 1、循环从地址分析队列中取出最新的一个地址，进行解析，直到分析队列为空。 2、如果当前地址所处的指令为普通指令，压入此指令的下一条指令至分析队列，结束分析。 如果当前地址所处的指令为无条件跳转指令，压入此指令的跳转地址至分析队列，结束分析。 如果当前地址所处的指令为条件跳转指令，压入此指令的跳转地址和此指令的下一条指令至分析队列，结束分析。 如果当前地址所处的指令为结束指令，结束分析 3、分析地址的时候需要对已分析过的地址进行记录，由于我们是按照指令的执行顺序递归向下进行分析的，那么不难得出如果一个地址已经分析过，这个地址后面的所有地址必然全都分析过的结论。 通过上面这几点，我们很容易编写出一个简单的流程分析引擎。 另外我们还需要对代码进行分块，那么就需要了解到一些关于基本块(BasicBlock)的基本概念。 BasicBlock定义: 只有一个入口指令，一个出口指令 执行时从入口指令进入，从出口指令退出 基本块的一个典型特点是：只要基本块中第一条指令被执行了，那么基本块内的代码都将按照顺序执行有且仅有一次。 划分BasicBlock的关键点: 1、在上述分析引擎的基础上，按照顺序进行指令分析。 2、如果当前地址是普通指令，且不在任何基本块中，则添加当前地址至当前的基本块中，继续向下分析。 如果当前地址是是普通指令，但已处于某个基本块中，则结束分析。 如果当前地址是跳转指令,且跳转地址在已生成的Block代码之内，则将之前的Block块分割成至多两块。 如果当前地址是跳转指令,且跳转地址不在基本块中，则结束当前的Block，并将新地址作为Block的头部。 如果当前地址是结束指令，结束分析。 3、代码是否处于基本块中与代码是否分析过等价。 必经节点(dominators) 在程序流图中，对任意两个节点m和n，如果从流图的首节点出发，到达n的任一通路都要经过m，则称m是n的必经节点，记为m DOM n。 回边(back edge) 假设a-\u003eb是流图中的一条有向边，如果b DOM a，则称a-\u003eb是流图中的一条回边。 ","date":"2021-05-16","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/:0:1","tags":["Branch"],"title":"反编译之分支流程图的生成","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/"},{"categories":["CTF"],"content":"第一题 拜师学艺 软件有一段内存解密代码，将解密后的EXE DUMP出来，看到一个字符串ZmxhZ3trYW54dWV9，结合算法猜测是BASE64算法，解密后得到flag{kanxue}，测试通过即得解。 ","date":"2021-05-11","objectID":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/:1:0","tags":["看雪CTF","Windows逆向"],"title":"看雪2021 KCTF春季赛","uri":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/"},{"categories":["CTF"],"content":"第二题 南冥神功 从最后判断的结果往上寻找逻辑，从下面这段代码我们可以得到以下信息： 1.存在一张大小为90字节的Table_Misc表，这张表一开始有些数据为0，有些数据不为0。 2.最终要使得这张表里面的数据全部不为0，才能通过校验。 再结合中间的逻辑代码，推测这很可能是迷宫求解，最后理解出题目的意思如下: 这张大小90字节Table_Misc表，对应的是一个9x10的迷宫，数据为1的部分不可通过，为0则表示可通过，我们的初始下标是(0,0)，需要走过整个迷宫，期间不得重复路线，求路线解。 将迷宫整理如下: ***#**##**\r*##**#*#*#\r**####*#*#\r##*###*#*#\r**#**#**##\r*##*#**#**\r**#*#####*\r##**#**#**\ro*#**#**##\r代码中的switch case分支可以转换为以下的移动规则: 0:如果上一个格所在行是奇数，则向下移动一格，如果上一个所在行是偶数，则向右下移动一格。 1:向右移动一格。 2:如果上一个格所在行是奇数，则向上移动一格；如果上一格所在行是偶数，则向右上移动一格。 3:如果上一个格所在行是偶数，则向上移动一格；如果上一格所在行是奇数，则向左上移动一格。 4:向左移动一格。 5:如果上一个格所在行是偶数，则向下移动一格，如果上一格所在行是奇数，则向左下移动一格。 我们输入的flag每个字符可以转换为迷宫的两个移动规则，最后人工看图求解迷宫，得出移动步骤，再编写代码将步骤转换回flag。 char Table_seed[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char StepindexToAlpha(unsigned int nIndex, unsigned char firstStep, unsigned char secondStep) { char ret = 0; for (unsigned int n = 0; n \u003c 36; ++n) { unsigned char result_firstStep = 5 - ((n + nIndex) % 6); unsigned char result_secondStep= (nIndex + n / 6) % 6; if (result_firstStep == firstStep \u0026\u0026 result_secondStep == secondStep) { return Table_seed[n]; } } return ret; } int main() { unsigned char buff_Step[] = { 1,2,3,4,3,2,1,2, 3,4,3,2,1,1,0,1, 2,1,0,0,5,0,5,4, 3,4,5,0,5,0,1,2, 1,0,1,2,1,2,3,4, 3,2,2,3,2,1 }; std::string flag; int n = 0; int nStep = 0; while (n \u003c sizeof(buff_Step)) { char tmp = StepindexToAlpha(nStep, buff_Step[n], buff_Step[n + 1]); flag = flag + tmp; nStep = nStep + 1; n = n + 2; } std::cout \u003c\u003c flag.c_str() \u003c\u003c std::endl; return false; } ","date":"2021-05-11","objectID":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/:2:0","tags":["看雪CTF","Windows逆向"],"title":"看雪2021 KCTF春季赛","uri":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/"},{"categories":["QQ"],"content":"因为工作需要，需要对QQ群文件协议进行逆向分析。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:0","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"1.分析准备流程 首先我们要知道QQ群文件的静态页面网址是https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602， 其中gid这个值就是QQ群号。 我们正常情况下访问这个页面是一片空白，因为缺少QQ登录的Cookie，这个时候我们需要到QQ群官网登录一下我们的QQ，然后再访问静态页面，就会发现能看到QQ群内的群文件，可以开始进行协议分析了。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:1","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"2.BKN算法 在分析的过程中，会遇到一个重要的参数BKN，我们其实不必理解这个参数有什么含义，只需要找到值的来源就行了。算法很简单，由Cookie中的skey转换得到，算法如下: function getBKN(skey) { var hash = 5381; for (var n = 0, len = skey.length; n \u003c len; ++n) hash += (hash \u003c\u003c 5) + skey.charCodeAt(n); return hash \u0026 2147483647 }; ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:2","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"3.获取群文件列表 请求协议如下: Request URL:https://pan.qun.qq.com/cgi-bin/group_file/get_file_list?gc=633783602\u0026bkn=xxxx\u0026start_index=0\u0026cnt=50\u0026filter_code=0\u0026folder_id=%2F\u0026show_onlinedoc_folder=1 referer:https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602 cookie:skey=xxxx gc就是QQ群号，bkn是根据cookie中的skey转换得到的值，cnt是显示的群文件个数。 返回的数据如下: { \"ec\": 0, \"file_list\": [ { \"create_time\": 1620539743, \"id\": \"\\/5637b4d6-1216-4d84-bbbe-579d4c65f6e2\", \"modify_name\": \"💀\", \"modify_time\": 1620539743, \"modify_uin\": 425063169, \"name\": \"新建文件夹\", \"owner_name\": \"💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"size\": 0, \"type\": 2 }, { \"bus_id\": 104, \"create_time\": 1620539142, \"dead_time\": 1621403742, \"download_times\": 2, \"id\": \"\\/5fc46b55-5ff8-47dc-bf2a-7171752843e9\", \"local_path\": \"\", \"md5\": \"3f26d3be679d81b5d9bd4fdf046d3eed\", \"modify_time\": 1620539144, \"name\": \"VMware.exe\", \"owner_name\": \"﻿﻿﻿💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"safe_type\": 0, \"sha\": \"d52d301385647f4dab3fee94734534a0385c22147c\", \"sha3\": \"\", \"size\": 241597204, \"type\": 1, \"upload_size\": 241597204 }, { \"bus_id\": 102, \"create_time\": 1618906774, \"dead_time\": 0, \"download_times\": 3, \"id\": \"\\/9366e551-cb4e-49c5-922a-17bc25f6cc3e\", \"local_path\": \"\", \"md5\": \"d9a985b55c724f4912fe5f80e21463aef3\", \"modify_time\": 1618906775, \"name\": \"VMOS.APK\", \"owner_name\": \"💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"safe_type\": 0, \"sha\": \"b4de8c3c29f4911bae322ea2c2fc5c306ca8c9ec43\", \"sha3\": \"\", \"size\": 15365031, \"type\": 1, \"upload_size\": 15365031 }, ], \"next_index\": 50, \"open_flag\": 0, \"total_cnt\": 63, \"user_role\": 2 } bus_id推测表示文件的类型，102表示是永久文件，104表示是缓存文件。 id表示文件的唯一ID，比较重要的一个值。 total_cnt表示群内文件的总数。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:3","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"4.获取文件下载地址 请求协议如下: Request URL:https://pan.qun.qq.com/cgi-bin/group_share_get_downurl?uin=425063169\u0026groupid=633783602\u0026pa=%2F102%2F9366e551-cb4e-49c5-951a-17bc25f6cc3e\u0026charset=utf-8\u0026g_tk=xxxx referer:https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602 cookie:skey=xxxx uin是我们的QQ号。 groupid是QQ群号。 pa其实是文件的bus_id和id的组合路径。 g_tk的值等于bkn。 结果如下: { \"code\": 0, \"data\": { \"cookie\": \"6138633965635533\", \"dns\": \"tj-ctfs.ftn.qq.com\", \"ismember\": 1, \"md5\": \"d9a985b50d4f4912fe5f80e21463aef3\", \"ret\": 0, \"sha\": \"b4de8c3c29f4911bae322ea2c2fc006ca8c9ec43\", \"sha3\": \"\", \"sip\": \"133.150.76.225\", \"url\": \"http:\\/\\/tj-ctfs.ftn.qq.com\\/ftn_handler\\/daab4b510d965064e12d4586ad5e2967167c95610b0188f29f5655fa607f83aa6f29326e8cf806300b4d2a8f11c0756601abc5698bf8df4ff4896f0865c08ccb\" }, \"default\": 0, \"message\": \"\", \"subcode\": 0 }); url是文件的下载地址直链。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:4","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["易语言逆向"],"content":"注意:本文所说的PUSH进入窗体，是指忽略程序的一般功能，目的只是为了进入窗体。 ","date":"2021-04-28","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/:0:0","tags":["IDA"],"title":"易语言程序万能进入主窗体","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/"},{"categories":["易语言逆向"],"content":"PUSH窗口 PUSH窗体其实比较简单，一般我们只需要在载入或者载入启动窗口这个函数上下断点就可以了，之后修改此命令的参数，将原先的窗体ID修改为我们想要进入的窗体ID即可。 之后观察是否能够进入窗体，如果能进，那么直接PUSH成功！ 不能成功的话，有可能是以下几种情况: 窗口载入后的窗口_创建完毕，或者窗口_首次激活等事件中有额外的代码处理。 窗口已经成功载入了，只不过是不可视的。 窗体时钟周期事件中有额外的代码处理。 如果是第一种情况，我们只需要将这些事件统统都干掉即可。 如果是第二种情况，我们需要找到窗体的可视属性在资源中位置，修改为真即可。 ","date":"2021-04-28","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/:0:1","tags":["IDA"],"title":"易语言程序万能进入主窗体","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/"},{"categories":["易语言逆向"],"content":"基础介绍 通过寻找易语言静态编译的程序规律，我们可以找到一处结构体，寻找的特征码是50 64 89 25 00 00 00 00 81 EC AC 01 00 00 53 56 57，找到后这个结构体大概是下面这个样子: struct EHead { unsigned int dwMagic; //未知,值固定为3 unsigned int szNone2; //未知,值固定为0 unsigned int szNone3; //未知,好像是个随机数,修改不影响程序 unsigned int lpStartCode; //用户代码起始地址,不可修改 unsigned int lpEString; //常量资源,如果没有常量资源,则为0 unsigned int dwEStringSize; //常量资源大小,如果没有常量资源,则为0 unsigned int lpEWindow; //创建组件信息 unsigned int dwEWindowSize; //创建组件信息大小 unsigned int dwLibNum; //支持库数量 unsigned int lpLibEntry; //支持库信息入口 unsigned int dwApiCount; //Api数量 unsigned int lpModuleName; //指向模块名称 unsigned int lpApiName; //指向Api名称 }; 可以看到这些结构体包含着易语言程序中的很多重要数据，今天我们要研究的是界面资源部分。 易语言所有的GUI信息都放在lpEWindow这个指针所指向的位置，dwEWindowSize则为信息的总大小，通过对这个信息进行解析，理论上我们可以还原与易语言IDE中几乎一模一样的控件设计。 具体解析规则，我就懒得介绍了，请自行参考E-Decompiler源码中的GuiParser::ParseGUIResource函数。通过不断尝试进行拆解还原，我们最终大概可以看到这样一个结构: 窗口结构窗口结构 \"\r窗口结构\r 每个窗口都是一棵树，窗口内的控件则为这个树的子节点，不难理解，通过窗口ID -\u003e 控件ID，我们就能对应到每个控件了。其中值得说明的是窗口本身也属于控件，每个窗口的第一个控件就是窗口控件。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:1","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件类型 控件类型控件类型 \"\r控件类型\r 在上图中我们可以看到，窗口.取窗口句柄()这样一个命令的参数中，0x52010001表示控件所属窗口ID，0x6010000表示控件ID，而0x10001这个参数则表示控件的类型ID。 每个控件都有一个控件类型ID，比如窗口的控件类型ID是0x10001，按钮的控件类型是0x1000B。 这个控件类型ID是有规律的，因为易语言有一个支持库机制，我们不妨看看易语言核心支持库的介绍: 提供了51种库定义数据类型，提供了686种命令，提供了335个库定义常量 而编辑框、按钮这些控件就属于核心支持库中的数据类型的一部分，控件ID中的高四位对应的是控件所属支持库在易语言程序中的加载顺序，低四位对应的则是控件在所属支持库中的数据类型数组中的下标，因此窗口控件ID0x10001表示的含义其实是程序所加载的第一个支持库中的第一种控件。 由于系统支持库默认最先加载，所以核心支持库中的控件的高四位必定是1。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:2","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件属性 在易语言中，属性可以分基本属性和附加属性两种，像左边、顶边、宽度、高度这些几乎每个控件都有的属性就属于基本属性了，这些字段每个控件排列顺序、排列方式都是一样的，我们可以通用解析。基础属性之后跟着的则是每个控件独特的附加属性，以序列化的形式存储，因此如果我们想要把这些属性还原出来，就必须对每个控件的属性进行反序列化解析。 另外，易语言为了节省空间，控件的附加属性都有一个默认值，即如果控件在IDE中的附加属性未进行任何改动，那么控件的信息结构中，附加属性字段占用大小为0。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:3","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件事件 事实上，控件的事件属于控件基本属性的一部分，事件的结构体很简单: struct ControlEvent { int EventIndex; //事件索引 uint32 EventOffset; //事件地址便宜 }; EventIndex表示事件类型，EventOffset值等于事件地址相对于用户代码起始地址的偏移。 每个控件都有自己的一张事件列表，例如0表示窗口_创建完毕事件，1表示窗口_可否被关闭事件。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:4","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"总结 其实还有一些细节，像子控件、父控件，菜单控件之类的，由于作者太懒也没有进行介绍，本文只是一个科普贴。。。。。。 啥也不说了，都在代码里。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:5","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["C++开发"],"content":"​ 虽然很久以前在还原C++代码的时候就已经接触到工厂类这个概念了，但是其实由于懒得理解，所以一直处于一知半解的状态，直到我今天写代码遇到了一个实际问题，并且发现这个问题的答案似乎工厂类是最优解的时候，我才终于领悟了工厂类的核心思想。 试想这样一个问题:存在100个类 class A,B,C,D,E….，这100个类继承基础类class base，而class base存在一个纯虚函数void func()，那么 ","date":"2021-04-19","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%9D%99%E6%80%81%E7%B1%BB/:0:0","tags":["高级C++"],"title":"C++工厂类","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%9D%99%E6%80%81%E7%B1%BB/"},{"categories":["QT"],"content":"QT工程转换为Visual Studio工程 打开QT 命令行工具，使用如下命令，得到工程文件 qmake -r -tp vc xx.pro ","date":"2021-04-18","objectID":"/posts/qt/qt%E7%AC%94%E8%AE%B0%E6%9C%AC/:0:0","tags":["入门","新手教程"],"title":"QT笔记本","uri":"/posts/qt/qt%E7%AC%94%E8%AE%B0%E6%9C%AC/"},{"categories":["C++开发"],"content":"使用函数指针作为参数 例如某个函数 int func(string arg); 将函数表示为参数的形式为int(*)(string); 如果非要带上个参数的话，那么是int(* funcDef)(string); 定义一个常量字符串数组 声明一个const char*数组即可，这使得每个元素都是一个char指针，并且指针会指向常量字符串。 const char * cities[5]= { \"Gribble City\", \"Gribbletown\", \"New Gribble\", \"San Gribble\", \"Gribble Vista\" }; 原始字符串 原始字符串是C++ 11新增的一个功能，一般被用来处理那些反人类的转义字符。语法为R\"(text string)\"，所见即所得。 cout \u003c\u003c R\"(I print '\\', \"\\n\" as I like.)\" \u003c\u003c endl; 查看类的关系图 在阅读大型项目源码的时候，使用Visual Studio中的生成类图功能能帮助我们快速了解代码。 首先需要安装此功能，在Visual Studio Installer中选择其他工具集-\u003e Visual Studio扩展开发，勾选右侧安装详细信息中的类设计器，安装完成之后重启电脑。 如果需要一次性生成项目中的所有类关系图，可以尝试对项目右键选择查看-\u003e查看类图，如果生成类图失败，我们可以手动将所有的类头文件筛选出来，再批量选中右键选择查看类图。 如果想要将类图保存下来，可以在类图上右键选择将关系图导出为图像，如果类图过大，导出来的图片可能会很模糊，这个时候只能选择导出增强的图元文件格式(*.emf)。 进程入口点的源码 熟悉逆向的我们知道，我们在源码中看到的main函数并非一个进程的原始入口点，真实的入口处源码参考exe_common.inl。 ","date":"2021-04-13","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/:0:0","tags":["C++"],"title":"C++常用知识","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"categories":["静态分析"],"content":"解除函数名称的限制 默认配置情况下我们是不能将函数名称修改为中文的，会提示bad character，意思就是包含非法字符，那么怎样让中文成为合法的字符呢？ 通过在网上查找资料，这个合法字符的定义在ida.cfg文件中，我们定位到文件，搜索Block_CJK_Unified_Ideographs，如下图所示: // the following characters are allowed in user-defined names: NameChars =\"$?@\" // asm specific character \"_0123456789\" \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\", // This would enable common Chinese characters in identifiers: // Block_CJK_Unified_Ideographs, CURRENT_CULTURE; 我们去掉Block_CJK_Unified_Ideographs这一行前面的注释，就可以给函数名字起中文了。 ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:1","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["静态分析"],"content":"解除IDA反汇编代码限制 虽然通过上述操作函数可以起名为中文，但是实际上使用F5功能的时候，得到的伪代码，中文函数名称却会变成下划线，如下图所示: 中文变成下划线中文变成下划线 \"\r中文变成下划线\r 通过对IDA进行逆向得知，原来hexray在生成伪代码的时候会调用一个calc_c_cpp_name函数，该函数会试图针对C/C++的函数名称进行优化，结果却误伤中文字符，我们将此处代码给NOP掉，就可以了。 合法化名称合法化名称 \"\r合法化名称\r ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:2","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["静态分析"],"content":"最终效果 我已制作Patch好的DLL，替换后效果如下: 中文函数中文函数 \"\r中文函数\r ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:3","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["QT"],"content":"在QT的开发中，免不了要用到表格(QTableWidget)这个控件。 ","date":"2021-04-05","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/:0:0","tags":["TableWidget","新手教程","QT"],"title":"QT组件之QTableWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/"},{"categories":["QT"],"content":"一、初始化表格 设置基本属性 ui.FileTableWidget-\u003esetColumnCount(2); //设置列数 ui.FileTableWidget-\u003esetColumnWidth(0, 100); //设置第一列宽度 ui.FileTableWidget-\u003esetColumnWidth(1, 300); //设置第二列宽度 //使行列头自适应宽度，最后一列将会填充空白部分 ui.FileTableWidget-\u003ehorizontalHeader()-\u003esetStretchLastSection(true); //使行列头自适应宽度，所有列平均分来填充空白部分 ui.FileTableWidget-\u003ehorizontalHeader()-\u003esetResizeMode(QHeaderView::Strtch); //设置表头标题 ui.FileTableWidget-\u003esetHorizontalHeaderLabels(QStringList()\u003c\u003c\"property\"\u003c\u003c\"value\"\"); //设置选中的模式,有禁止选择、单选、多选等5种模式 ui.tableView-\u003esetSelectionMode(QAbstractItemView::ExtendedSelection); //设置整个表格不可被编辑 ui.tableView-\u003esetEditTriggers(QAbstractItemView::NoEditTriggers); //设置某一列不可编辑 QTableWidgetItem *item1 = new QTableWidgetItem(“xxx”); item1-\u003esetFlags(item1-\u003eflags() \u0026 (~Qt::ItemIsEditable)); ui-\u003etableView-\u003esetItem(i, 0, item1); 添加代理 如果我们想让表格中的单元不仅仅是显示文本，而是其他的控件，例如编辑框、复选框等，这个时候我们就得使用代理了，可以给所有的单元添加代理控件: //给所有的单元添加代理控件 ui.tableView-\u003esetItemDelegate(new ReadOnlyDelegate()); 或者只给某一列或某一行添加代理控件: //给特定的单元添加代理控件 ui.tableView-\u003esetItemDelegateForColumn(0, new ReadOnlyDelegate()); ui.tableView-\u003esetItemDelegateForRow(0, new ReadOnlyDelegate()); 假设我们想要通过代理控件达到的需求是，控件列表中的内容不可编辑、但是可以选中且被复制，那么我们需要实现以下代码: #include \u003cQLineEdit\u003e#include \u003cQStyledItemDelegate\u003eclass ReadOnlyDelegate : public QStyledItemDelegate { Q_OBJECT public: ReadOnlyDelegate(QObject* parent = 0) :QStyledItemDelegate(){} QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem\u0026 option, const QModelIndex\u0026 index) const override { QLineEdit* editor = new QLineEdit(parent); editor-\u003esetFrame(false); editor-\u003esetReadOnly(true); return editor; } void setEditorData(QWidget* editor, const QModelIndex\u0026 index) const { QString value = index.model()-\u003edata(index, Qt::EditRole).toString(); QLineEdit* spinBox = static_cast\u003cQLineEdit*\u003e(editor); spinBox-\u003esetText(value); } void setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex\u0026 index) const { QLineEdit* spinBox = static_cast\u003cQLineEdit*\u003e(editor); QString value = spinBox-\u003etext(); model-\u003esetData(index, value, Qt::EditRole); } void updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem\u0026 option, const QModelIndex\u0026 index) const { editor-\u003esetGeometry(option.rect); } }; 二、获取选中的行 QModelIndexList selectedsList = ui.tableView-\u003eselectionModel()-\u003eselectedRows(); for (unsigned int n = 0; n \u003c selectedsList.size(); ++n) { int row = selectedsList.at(n).row(); } 三、动态插入数据 ui.tableView-\u003esetSortingEnabled(false); //关闭排序功能 int insertRow = ui.tableView-\u003erowCount(); ui.tableView-\u003einsertRow(insertRow); ui.tableView.setItem(insertRow,0,new QTableWidgetItem(\"name\")); ui.tableView-\u003esetSortingEnabled(true); //开启排序功能 这里需要注意的是，在插入数据的时候，必须关闭表头的排序(对应上述代码中的setSortingEnabled函数)，否则表格数据会错乱。 四、清空所有数据 ui.tableView-\u003esetRowCount(0); ui.tableView-\u003eclearContents(); ","date":"2021-04-05","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/:0:1","tags":["TableWidget","新手教程","QT"],"title":"QT组件之QTableWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/"},{"categories":["Github碎片"],"content":"因为工作的需要，不可避免地要对csv进行解析，但是自己写解析引擎的话只能写几句玩具代码，上限太低，不堪入目，所以一个好用的CSV解析引擎库就显得比较重要的。 fast-cpp-csv-parser 轻量小巧，好用，只需要包含一个头文件即可使用。特点如下： 可以按照标题将不同列的信息解析出来 可以使用多线程技术读取CSV文件并且解析 可以在编译时使用模板启用和禁用解析功能（例如转义字符串），按需定制功能 可以在合理的时间内读取多个GB大小的文件 支持自定义列分隔符（即支持制表符分隔值文件），引用转义字符串，自动空格修剪 使用*nix和Windows换行符，并自动忽略UTF-8 BOM 具有足够上下文以格式化有用的错误消息的异常类。 what（）返回错误消息准备好显示给用户 rapidcsv 使用了C++ 11，支持多平台。只需要包含一个头文件即可使用。个人认为就提供的库接口函数来说，rapidcsv比fastcsv更加简单，不过代价可能就是牺牲了一些效率吧。作者更新也挺勤劳。个人认为这个比较适合用来解决平时的一些小需求。 ","date":"2021-03-14","objectID":"/posts/github%E7%A2%8E%E7%89%87/csv%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E/:0:0","tags":["开源项目","csv","parser"],"title":"CSV解析引擎","uri":"/posts/github%E7%A2%8E%E7%89%87/csv%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E/"},{"categories":["QT"],"content":"例如我们想让主窗口能接受到拖放来的文件，要点如下: 1.设置属性 在Qt Designer中点击主窗口，右侧会出现属性编辑器，我们在属性acceptDrops上打√。 或者在初始化ui代码中添加 this-\u003esetAcceptDrops(true); 事实上这二者是等价的。 2.实现虚函数dragEnterEvent() 当窗口触发拖放事件的时候，就会进入到这个函数，这个时候我们可以检查一下拖进来的是什么东西(文件或者文本之类的)。 void MainWindow::dragEnterEvent(QDragEnterEvent* event) { //判断是否是文件 if (event-\u003emimeData()-\u003ehasFormat(\"text/uri-list\")) { event-\u003eacceptProposedAction(); } } 3.实现虚函数dropEvent() 这里可以填写触发的动作代码 void MainWindow::dropEvent(QDropEvent* event) { QList\u003cQUrl\u003e urls = event-\u003emimeData()-\u003eurls(); if (urls.isEmpty()) { return; } //To do... //拿到文件路径后，就可以执行想做的事了 } ","date":"2021-03-14","objectID":"/posts/qt/qt%E6%8E%A5%E5%8F%97%E6%8B%96%E6%94%BE%E6%96%87%E4%BB%B6/:0:0","tags":["入门","新手教程"],"title":"QT接受拖放文件","uri":"/posts/qt/qt%E6%8E%A5%E5%8F%97%E6%8B%96%E6%94%BE%E6%96%87%E4%BB%B6/"},{"categories":["产品试用"],"content":"由于不同的应用都有的自己的音乐版权，而我们如果想要存储自己想听的歌，那么该怎么做呢？ 使用物理硬盘存储 现在的机械硬盘容量很大，又十分便宜，把歌曲放在这里是个可取的选择。 稳定性:⭐⭐⭐⭐⭐ 传输速度:⭐⭐⭐⭐⭐ 容量:⭐⭐⭐⭐⭐ 便利性:⭐⭐ 评价:传输到自己的机械硬盘里，就不会像某音乐网盘一样会删掉你上传的歌曲了，数据安全性得到极大的保证，传输速度和容量也有保证。唯一的缺点就是传输不太方便了。 使用音乐网盘存储 每家音乐App其实都用的是自家的云盘，例如QQ音乐对接腾讯微云、网易云音乐对接网易云盘、酷狗音乐对接酷我云盘。然而不知何时开始，因为版权等原因，有一些歌曲经过扫描后，有可能不被允许上传到云盘中，有的甚至上传之后会被悄悄删除。 稳定性:⭐⭐⭐ 传输速度:⭐⭐⭐⭐ 容量:⭐⭐⭐⭐ 便利性:⭐⭐⭐⭐⭐ 评价:如果能够忍受自己上传的歌曲被删除，那么可以考虑使用这个方案；传输速度方面也暂时不用担心会像某度盘一样被限速，容量也能满足大部分人的需求。 使用坚果云 我目前就在尝试这个方案，因为坚果云个人版是不限制容量的，但是限制上传和下载流量，所以这个传输速度和容量，就不好评价了，如果你和我一样，只是为了将歌曲慢慢地存起来，只是为了等到想听的时候能快速找到资源(有可能是收集癖)，那么这个流量限制也就不用太在意。坚果云在我心目中的评价是: 稳定性:⭐⭐⭐⭐ 传输速度:⭐⭐⭐⭐ 容量:⭐⭐⭐⭐⭐ 便利性:⭐⭐⭐⭐ 使用国外云盘 像微软的OneDrive或者谷歌的云端网盘，都是不错的选择。大家也都可以尝试，这里我就懒得评测了。 ","date":"2021-03-14","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E9%9F%B3%E4%B9%90%E5%AD%98%E5%82%A8/:0:0","tags":["坚果云"],"title":"音乐存储","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E9%9F%B3%E4%B9%90%E5%AD%98%E5%82%A8/"},{"categories":["QT"],"content":"QT是一个跨平台的C++开发库，主要用来开发图形用户界面程序，不过QT还自带很多其它的开发库，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等。 参考教程 http://c.biancheng.net/qt/ 安装QT 由于QT版本较多，初学者建议选择稳定的老版本，而不是追求那些最新版本，否则可能踩各种坑，从而失去对QT的兴趣。 QT最后一个比较稳定且支持离线安装包版本是5.12，下载地址如下，自行选择一个版本即可，例如QT 5.12.10。 https://download.qt.io/official_releases/qt/5.12/ 进入到安装界面后，在安装的组件中，QT 5.12.10部分选择以下项: MSVC 2017 32-bit MSVC 2017 64-bit MinGW 7.3.0 32-bit 而Developer and Designer Tools部分选择以下项: Qt Creator 4.13.1 CDB Debugger Support MinGW 7.3.0 32-bit 因为我个人习惯了使用Visual Studio 2019，为了配合还需要下载一个VS插件，下载地址如下，选最新版的即可: https://download.qt.io/official_releases/vsaddin/ 在安装完成了上述两个程序，打开Visual Studio还需要配置一下QT的关键路径: Visual Studio菜单 -\u003e 扩展 -\u003e QT VS Tools -\u003e Qt Versions，在此添加对应的QT版本，路径选择QT目录下的qmake程序，例如C:\\Qt\\Qt5.12.10\\5.12.10\\msvc2017\\qmake.exe ","date":"2021-03-12","objectID":"/posts/qt/qt%E5%85%A5%E9%97%A8%E4%B9%8Bwindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["入门","新手教程"],"title":"QT入门之Windows开发环境搭建","uri":"/posts/qt/qt%E5%85%A5%E9%97%A8%E4%B9%8Bwindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["产品试用"],"content":"kinhdown https://kinhdown.kinh.cc/ 用来下载百度云盘里面的东西，速度的话还算是能满足日常使用需求的。不过据说会窃取用户的cookie，如果对这一点不在意的话，那么还是选择这个软件吧，因为真的没什么太好的选择。 ","date":"2021-03-12","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/:0:0","tags":["下载","百度云"],"title":"下载工具","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"},{"categories":["易语言逆向"],"content":"通过寻找易语言静态编译的程序规律，我们可以找到一处结构体，这个结构体大概是下面这个样子: struct EHead { unsigned int dwMagic; //未知,值固定为3 unsigned int szNone2; //未知,值固定为0 unsigned int szNone3; //未知,好像是个随机数,修改不影响程序 unsigned int lpStartCode; //起始用户代码地址,不可修改 unsigned int lpEString; //常量资源,如果没有常量资源,则为0 unsigned int dwEStringSize; //常量资源大小,如果没有常量资源,则为0 unsigned int lpEWindow; //创建组件信息 unsigned int dwEWindowSize; //创建组件信息大小 unsigned int dwLibNum; //支持库数量 unsigned int lpLibEntry; //支持库信息入口 unsigned int dwApiCount; //Api数量 unsigned int lpModuleName; //指向模块名称 unsigned int lpApiName; //指向Api名称 }; 可以看到这些结构体包含着易语言程序中的很多重要数据，今天我们要研究的就是常量资源部分。 lpEString这个指针指向着易语言代码中所用到的全部常量，包括文本字符串、字节集、浮点数、类虚表、数组头、数组数据等，而dwEStringSize则表示常量的总大小。 这些数据十分复杂，无论是在理论上还是实际上，我们仅凭数据本身，是很难分辨出这些数据的类别的，因此本文的主题就诞生了——基于交叉引用来解析易语言常量资源。 基于交叉引用来解析资源，原理就是通过对数据进行代码交叉引用，观察代码是怎么使用数据的，我们根据固定的数据使用模板就能识别出数据类别了。 但是在实际情况下，有大量的代码被保护，是无法得知使用代码的，如果代码100%全部被虚拟化保护，那么基于交叉引用来识别数据类型就彻底不可行了。幸运的是，大部分程序只会对少量关键代码进行虚拟化保护，如何最大化地利用交叉引用来识别这些被保护的程序的资源便是一个值得研究的问题了。 ","date":"2021-03-08","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/:0:0","tags":["IDA"],"title":"基于交叉引用来解析易语言常量资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"固定的数据使用模板 因为在易语言程序中，不同的常量数据类型有不同的使用模板，因此首先我们要记录下这些模板。 浮点数模板 使用到数据的指令是fadd、fsub、fmul、fdiv、fcomp、fld其中的一种。 空白字符串模板 一种是jnz$+0x5,mov eax,addr。 一种是push addr 字符串模板 一种是push addr 一种是mov eax,addr 空白字节集模板 一种是jnz$+0x5,mov eax,addr。 一种是push addr 一种是mov esi,addr,0xABADABAD 字节集模板 一种是push addr 一种是mov eax,addr 数组头模板 一种是 mov esi,addr\rlodsd\rstosd\rlodsd\rstosd\r数组模板 一种是mov eax,addr ","date":"2021-03-08","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/:0:1","tags":["IDA"],"title":"基于交叉引用来解析易语言常量资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/"},{"categories":["C++开发"],"content":"一般情况下，创建一个类对象，可以在栈或者堆中分配空间。 比如，这样编写代码，就是在栈中建立类对象 int main() { A Obj; } 这句代码对于编译器来说可以转换为近似等于下面的代码: int main() { obj = 申请栈空间(sizeof(A)); A(Obj); ~A(Obj); } 1.分配好类的栈空间 2.调用类的构造函数 3.在变量生命周期结束的地方调用析构函数(编译器负责识别出在哪里结束) 因此，如果我们想让编译器无法在栈上建立类对象，可以将类的析构函数设为private，因为编译器便无法执行第三步。 而动态建立类对象，就是将对象建立在堆空间中，代码如下： int main() { A* ptr = new A; } 实际上编译器是怎么理解这句代码的呢? 1.判断对象A是否有重载operator new函数，如果有，使用对象A的operator new函数，否则，使用默认的operator new函数 2.使用operator new函数返回得到的空间指针，调用类的构造函数 因此，如果我们想让编译器无法在堆上建立类对象，可以重载类的operator new函数，再将属性设为private，这样编译器将无法调用类的operator new函数，便达到了限制的目的。 ","date":"2021-03-06","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%99%90%E5%88%B6%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/:0:0","tags":["高级C++"],"title":"C++限制堆和栈的对象空间分配","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%99%90%E5%88%B6%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/"},{"categories":["心情文学"],"content":"在这个信息碎片化时代，感觉到以个人的力量越来越难抗衡那些信息的洪流了，尽管其中的大部分信息其实并没有什么意义。 像B站、微博、知乎、豆瓣、小黑盒、抖音等软件，你可能不会全部都使用，但一定会花费很多碎片时间在这些App上面。就连打开个搜索引擎，旁边全都充斥着大量的新闻广告，一不留神人的注意就被吸引了过去，甚至忘了之前要干什么。 这对做学术的人来说是不利的，不利于人沉下心来专心搞研究，尤其像逆向这样需要深度钻研的领域。 就我个人来说，我平时的碎片时间基本都花在了B站、知乎、小黑盒上面。可能目前的大环境就是这样吧，连很多大学生都不会去深入阅读学习，更何况996的上班族了。 借着这次离开996公司的机会，我想重新选择一下自己的生活，因为我是属于相信下面这句话的那类人:人吃饭的时候并不一定要看手机，思考也是挺有意思的。 另外世上的很多东西并无对错，只看个人的选择罢了，我也并不认为另外一种选择就是错的，只不过我个人的性格就是喜欢去深入研究自己感兴趣的东西。 简单地总结一下就是，我认为那些碎片化阅读打断了我的状态，让我变得浮躁起来了，我想尝试抵制一下这些东西。 具体上升到行为就是: 1.我决定卸载手机上的小黑盒这个软件，并减少BiliBili、知乎这类App的打开次数。 2.安装百度药丸浏览器插件，去除百度热榜. 3.多听纯音乐,比如我就喜欢听麦振鸿的音乐,有利于静心思考(不适用于每个人). ","date":"2021-01-31","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E4%BF%A1%E6%81%AF%E7%A2%8E%E7%89%87%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%9D%E8%80%83/:0:0","tags":["鸡汤"],"title":"信息碎片化时代的思考","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E4%BF%A1%E6%81%AF%E7%A2%8E%E7%89%87%E5%8C%96%E6%97%B6%E4%BB%A3%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Github碎片"],"content":"Github项目地址:graphviz Graphviz 是一款由 AT\u0026T Research 和 Lucent Bell 实验室开源的可视化图形工具，用于绘制DOT语言脚本描述的图形。它可以很方便的用来绘制结构化的图形网络，并且支持GIF,PNG,SVG,PDF等多种格式输出。 官方文档地址:Documentation 要想使用Graphviz就得先熟悉DOT语言，这是一种用来描述图形的脚本语言。 DOT语言 DOT语言是一种文本图形描述语言。它提供了一种简单的描述图形的方法，并且可以为人类和计算机程序所理解。DOT语言文件通常是具有.gv或是.dot的文件扩展名。 graph表示无向图，例如下面的dot脚本 graph graphname { a -- b -- c; b -- d; } digraph为有向图，例如下面的dot脚本 digraph graphname { a -\u003e b -\u003e c; b -\u003e d; } 在线画图工具 项目地址:https://github.com/dreampuf/GraphvizOnline 工具地址:https://dreampuf.github.io/GraphvizOnline/ ","date":"2021-01-30","objectID":"/posts/github%E7%A2%8E%E7%89%87/graphviz/:0:0","tags":["开源项目","Graphviz"],"title":"Graphviz","uri":"/posts/github%E7%A2%8E%E7%89%87/graphviz/"},{"categories":["Github碎片"],"content":"Github项目地址:NetworKit NetworKit是用一个用于高性能网络分析的开源工具包，其目标是为了分析上千或者上亿条边的大型网络节点。为此，它实现了有效的图算法，并且部分算法实现了并行处理。 该项目底层核心使用C++编写，上层再封装一层python库，因此性能较高。 不过国内资料实在太少，文档都看不懂，我是小白，不会用(⊙﹏⊙)…… ","date":"2021-01-30","objectID":"/posts/github%E7%A2%8E%E7%89%87/networkit/:0:0","tags":["开源项目","NetworKit"],"title":"NetworKit","uri":"/posts/github%E7%A2%8E%E7%89%87/networkit/"},{"categories":["产品试用"],"content":"今天看到一款产品，据说能将DLL或者EXE转换为可编译的C/C++代码，官网地址如下: https://www.dll-decompiler.cn/dll2c.html 官方介绍如下: DLL to C 是一个能够把所有DLL文件和部分EXE文件转换为可编译的C/C++代码的工具，转换之后生成的代码高度可靠，可直接编译运行，并且可以很容易地阅读和编辑。 带着好奇心，我便下载了产品试了试。 EXE的话需要付费版才能进行转换，要650RMB。额，那就试试DLL的转换效果，随便找了几个DLL，发现稍微复杂一点的便提示不支持。 于是自己编译了一个DLL，代码也就一句MessageBox，使用OD加载该模块并运行的话就会弹出一个提示框。 那就用这工具转换试试吧，转换成功后，得到了一个Visual Studio工程，看了看转换后的工程代码，发现里面并没有我写的代码，大部分都是一些作者写的函数和原始DLL的十六进制数据。这和官方的描述不符啊，说好的可以很容易地阅读和编辑呢。。。 不过也罢，工程倒是生成出来了，也确实能编译出DLL，那么试试编译后的DLL模块吧。 使用OD载入此模块并没有弹出提示框，这样的话功能等价性就测试失败了。也有可能是我没有掌握使用方法吧，也懒得再进行测试了。 好的，经过上面一番测试，也大概了解了该工具的原理，和内存加载DLL的方向有点相似，区别就在于多了一些杂七杂八的代码，换汤不换药，还不如内存加载DLL呢。 ","date":"2021-01-24","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/:0:0","tags":["Decompiler"],"title":"DLL2C试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/"},{"categories":["产品试用"],"content":"总结: 没什么用的工具，我也很难找到其应用场景。如果是想要窃取他人的产品，最笨同时也是最有效的方法是花费人力来对产品进行人工逆向还原，取得产品核心代码和原理后再在此基础上进行重新架构开发，这样能一定程度上避免法律的风险。像这种把二进制集成到源码里面，和直接调用模块本身并无实质区别，通过二进制对比等技术手段取证之后，无法规避法律风险。没啥用的工具，已卸载。 ","date":"2021-01-24","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/:0:1","tags":["Decompiler"],"title":"DLL2C试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/"},{"categories":["杂文"],"content":"系统又又又重装了，又又又忘了怎么配置博客，所以做笔记是有多么重要。。。。 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 1.下载Hugo 地址如下，找到对应平台的二进制包，下载后将工具目录添加至系统环境变量。 https://github.com/gohugoio/hugo/releases 需要注意的是，由于LoveIt主题使用了一些特性，因此我们需要下载hugo_extended版本，否则可能会生成博客失败。 2.创建博客 执行以下命令 hugo new site testDemo cd testDemo git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 之后修改testDemo目录下的config.toml文件，该文件可以用来配置主题信息，例如修改为如下 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 3.添加文章 我们可以在testDemo/content/posts目录下添加md文件，例如first_post.md --- title: \"我是第一篇文章\" date: 2021-01-24 tags: [\"笔记\",\"博客\"] categories: [\"杂文\"] --- 这是我的第一篇文章 4.调试 添加完成后，执行下面的命令开启动态预览博客。 hugo server 执行完成后，命令会返回一个本地网址，我们可以通过该网址查看博客内容。 5.发布 使用以下命令行，生成html内容 rm -f -r docs hugo -b \"https://fjqisba.github.io\" -d docs git add . git status git commit -m \"content update\" git push 这个生成的docs文件夹其实就是Github Pages要展示的内容了，因此在项目配置中的Settings -\u003e Pages -\u003e Source这一栏，我们需要将目录/root修改为/docs。 ","date":"2021-01-24","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","博客"],"title":"Hugo搭建LoveIt博客","uri":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/"},{"categories":["杂文"],"content":"遇到的坑 markdown文件在网页的路径中不能出现小数点之类的特殊字符。 ","date":"2021-01-24","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/:0:1","tags":["Hugo","博客"],"title":"Hugo搭建LoveIt博客","uri":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言逆向"],"content":"易语言数据操作支持库一中存在这样一对算法函数 调用格式： 〈字节集〉 加密数据 （字节集 字节集数据，文本型 密码文本，［整数型 加密算法］） - 数据操作支持库一-\u003e数据加解密\r英文名称：Encrypt\r加密一段字节集数据，返回加密后的结果字节集。如果失败，返回空字节集。本命令为初级命令。\r参数\u003c1\u003e的名称为“字节集数据”，类型为“字节集（bin）”。为命令提供所需的字节集数据。\r参数\u003c2\u003e的名称为“密码文本”，类型为“文本型（text）”。\r参数\u003c3\u003e的名称为“加密算法”，类型为“整数型（int）”，可以被省略。指定具体使用的加密算法，可以为以下常量值之一：1: #DES算法； 2: #RC4算法。加密和解密必须使用相同的算法，有关算法的具体说明请参阅有关文献。如果本参数被省略，则默认值为1，即DES算法。\r调用格式： 〈字节集〉 解密数据 （字节集 字节集数据，文本型 密码文本，［整数型 加密算法］） - 数据操作支持库一-\u003e数据加解密\r英文名称：Decrypt\r解密一段加密后的字节集数据，返回解密后的结果字节集。注意本命令并不对密码文本进行校验，如果密码提供错误，将返回错误的结果。如果失败，返回空字节集。本命令为初级命令。\r参数\u003c1\u003e的名称为“字节集数据”，类型为“字节集（bin）”。为命令提供所需的字节集数据。\r参数\u003c2\u003e的名称为“密码文本”，类型为“文本型（text）”。\r参数\u003c3\u003e的名称为“加密算法”，类型为“整数型（int）”，可以被省略。指定具体使用的加密算法，可以为以下常量值之一：1: #DES算法； 2: #RC4算法。加密和解密必须使用相同的算法，有关算法的具体说明请参阅有关文献。如果本参数被省略，则默认值为1，即DES算法。\r这个函数里面的DES算法是不标准的，如果我们需要逆向算法或者移植语言，就会陷入坑中。。。。 根据别人研究的资料， 得知将密钥进行变换就可以对齐结果，实现Go语言代码如下: package Utils import ( \"bytes\" \"crypto/des\" \"encoding/binary\" \"math/bits\" ) func zeroPadding(ciphertext []byte, blockSize int) []byte { padding := blockSize - len(ciphertext) % blockSize padtext := bytes.Repeat([]byte{0}, padding) return append(ciphertext, padtext...) } func E_加密数据_DES(加密数据 []byte,密码文本 string)([]byte,error) { key := make([]byte,8) //压缩密钥 sIndex := 0 for _,eKey := range 密码文本{ key[sIndex] = byte(eKey) ^ key[sIndex] sIndex = sIndex + 1 if sIndex == 8{ sIndex = 0 } } //转换密钥 for n,_ := range key{ key[n] = bits.Reverse8(key[n]) } block,err := des.NewCipher(key) if err!=nil{ return nil,err } //需要在数据前面追加长度 inputData := make([]byte,4) binary.LittleEndian.PutUint32(inputData,uint32(len(加密数据))) inputData = append(inputData, 加密数据...) inputData = zeroPadding(inputData,block.BlockSize()) //开始执行加密 encryptedData := make([]byte, len(inputData)) data := inputData dst := encryptedData bs := block.BlockSize() for len(data) \u003e 0 { // Mandarin encryption is made according to blocksize // Can use the Go key to encrypt block.Encrypt(dst, data[:bs]) data = data[bs:] dst = dst[bs:] } return encryptedData, nil } func E_解密数据_DES(解密数据 []byte,密码文本 string)([]byte,error) { key := make([]byte,8) //压缩密钥 sIndex := 0 for _,eKey := range 密码文本{ key[sIndex] = byte(eKey) ^ key[sIndex] sIndex = sIndex + 1 if sIndex == 8{ sIndex = 0 } } //转换密钥 for n,_ := range key{ key[n] = bits.Reverse8(key[n]) } block,err := des.NewCipher(key) if err!=nil{ return nil,err } //开始执行解密 decryptedData := make([]byte, len(解密数据)) data := 解密数据 dst := decryptedData bs := block.BlockSize() for len(data) \u003e 0 { // Mandarin encryption is made according to blocksize // Can use the Go key to encrypt block.Decrypt(dst, data[:bs]) data = data[bs:] dst = dst[bs:] } //读取头部数据 recvLen := binary.LittleEndian.Uint32(decryptedData) return decryptedData[4:recvLen+4], nil } 另外附上一份别人写的python版本 from Crypto.Cipher import DES import struct def reverse_bytes(b): assert type(b) == bytes ba = bytearray(b) for i in range(0, len(b)): ba[i] = int(format(b[i], '0\u003e8b')[::-1], 2) return bytes(ba) def get_new_key(key): ba = bytearray(8) i = 0 for b in key: ba[i] = b ^ ba[i] i = i + 1 if i \u003c 8 else 0 return bytes(ba) # zero padding def padding(d): ba = bytearray(d) while len(ba) % 8 != 0: ba.append(0) return bytes(ba) def append_len(d): assert type(d) == bytes length = struct.pack('\u003cL', len(d)) return bytes(length + d) def remove_len(d): assert type(d) == bytes return d[4:] def e_des_encrypt(plain, key): des = DES.new(reverse_bytes(get_new_key(key)), DES.MODE_ECB) return des.encrypt(padding(append_len(plain))) def e_des_decrypt(raw, key): des = DES.new(reverse_bytes(get_new_key(key)), DES.MODE_ECB) t = des.decrypt(raw) return remove_len(t) # 易语言： # 输出调试文本(字节集_字节集到十六进制 (加密数据 (到字节集 (“123456789”), “123456789”, #DES算法))) # 输出： # 53DEE70DD231541839EB99553B8B056D # -------------------------------- # python: plain = b'123456789' key = b'123456789' ciph = e_des_encrypt(plain, key) print(ciph.hex().upper()) print(e_des_decrypt(ciph, key).decode()) # 输出: # 53DEE70DD231541839EB99553B8B056D123456789 # 123456789 参考资料 https://monvvv.github.io/2019/10/09/A-weird-way-of-DES-implementation-of-Elang.html ","date":"2021-01-11","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E5%BA%93%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/:0:0","tags":["易语言","DES"],"title":"易语言支持库中的加密数据与解密数据","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E5%BA%93%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/"},{"categories":["LLVM"],"content":"LLVM的核心是中间端表达式，即LLVM IR(Intermediate Representation)，这是一种类似汇编的底层语言。 中间端表达式有三种存在形态: 一种文本形态，可以直接被人类阅读; 一种内存对象形态，存在于运行中的C++代码中; 一种文件形态，为序列化的bitcode。 官方手册地址:LLVM Language Reference Manual — LLVM 12 documentation 摘要 LLVM 语言是基于Static Single Assignment (SSA)策略的语言。LLMV IR的语言特点是：类型安全、 低级别操作、灵活且具有清晰表示所有高级语言的能力。它作为一个统一的代码表示，贯穿LLVM编译的各个阶段。 标识符 LLVM标识符有2个基本类型：全局的和局部的。全局的标识符（函数，全局变量）以@字符开头。局部的标识符（注册名称，类型）以％字符开头 注释 注释行以;符号开头。 ","date":"2021-01-09","objectID":"/posts/llvm/llvm-ir%E7%AE%80%E4%BB%8B%E4%B8%89/:0:0","tags":["LLVM"],"title":"LLVM IR简介(三)","uri":"/posts/llvm/llvm-ir%E7%AE%80%E4%BB%8B%E4%B8%89/"},{"categories":["产品试用"],"content":"福昕PDF阅读器(目前的选择) 感觉比较专业，标签页结构清晰，支持多种形式保存标签，功能较为齐全。 Sumatra PDF 一款开源的PDF阅读器，只能满足基本的阅读功能，中规中矩，没有出彩的地方。 万兴PDF专家 必须得注册账号并登录才能使用PDF阅读功能，安装后我立马就卸载了。。 ","date":"2021-01-08","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/pdf%E9%98%85%E8%AF%BB%E5%99%A8%E8%AF%95%E7%94%A8/:0:0","tags":["PDF"],"title":"PDF阅读器试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/pdf%E9%98%85%E8%AF%BB%E5%99%A8%E8%AF%95%E7%94%A8/"},{"categories":["Python"],"content":"python安装Crypto这个库非常的坑，正确步骤似乎是: 1、pip install pycryptodome 2、将python lib库目录下面的crypto文件夹名改成大写的Crypto。 这里要吐槽一下，网上的一些库，对Windows实在是太不友好了😭 ","date":"2021-01-08","objectID":"/posts/python/python%E5%AE%89%E8%A3%85crypto%E5%BA%93/:0:0","tags":["Crypto","pip"],"title":"Python安装Crypto库","uri":"/posts/python/python%E5%AE%89%E8%A3%85crypto%E5%BA%93/"},{"categories":["Python"],"content":"bytes转换为十六进制字符串 Python高版本直接用hex函数即可。 input = b'12345678' print(input.hex()) ","date":"2021-01-08","objectID":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","tags":["Crypto","pip"],"title":"Python常见数据类型转换","uri":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["LLVM"],"content":"前端代码生成LLVM IR 使用以下命令将源代码转换成LLVM IR文本。 clang -emit-llvm -S test.c -o test.ll 前端代码生成可执行程序 基本选项是定义目标体系结构，语法为-target \u003ctriple\u003e triple的格式一般为\u003carch\u003e\u003csub\u003e-\u003cvendor\u003e-\u003csys\u003e-\u003cabi\u003e，其中: arch = x86_64、i386、arm、thumb、mips等 sub = 与arch对应，例如在ARM上有 v5、v6m、v7a、v7m等。 vendor = none、linux、win32、darwin、cuda等 abi = eabi、gnu、android、macho、elf等 简单举个例子就清楚了，例如对于某个test.c文件，我们想要将它编译成不同平台下的可执行程序。 如果想要编译成Windows下的64位可执行程序，使用以下命令行即可 clang test.c -target x86_64-pc-windows-msvc 在上面这个例子中，arch就是x86_64，sub则没有，vendor是pc，sys是windows，abi是msvc。 另外如果我们想要编译成Windows下的32位可执行程序，使用以下命令行即可 clang test.c -target i386-pc-windows-msvc LLVM IR生成可执行程序 使用clang可以直接将LLVM IR编译成可执行文件，命令如下 clang test.ll -o test.exe ","date":"2021-01-07","objectID":"/posts/llvm/llvm%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BA%8C/:0:0","tags":["LLVM","Clang"],"title":"LLVM整体架构(二)","uri":"/posts/llvm/llvm%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BA%8C/"},{"categories":["LLVM"],"content":"LLVM是一个非常有名的开源编译器框架，由C++编写。 介绍:LLVM - 维基百科，自由的百科全书 (wikipedia.org) Github项目地址:llvm-project 编译LLVM前需要准备的环境 Git，工具地址为https://git-scm.com/download CMake，工具地址为https://cmake.org/download/ Visual Studio 2017或者以上 Python 1.克隆代码仓库 执行以下命令即可 git clone --config core.autocrlf=false https://github.com/llvm/llvm-project.git 2.配置VS工程 执行以下命令即可 cd llvm-project mkdir build cd build cmake -DLLVM_ENABLE_PROJECTS=clang -G \"Visual Studio 16 2019\" -A x64 -Thost=x64 ..\\llvm 这样就得到了生成好的LLVM.sln工程 3.编译程序 在Visual Studio中打开LLVM.sln工程，里面项目有很多，还包含一些测试用例，如果全部编译的话，占用空间估计得上百G。 LLVM工程中的项目介绍: Clang: LLVM中的前端，可用来输出源代码对应的抽象语法树(Abstract Syntax Tree, AST)，并将代码编译成LLVM Bitcode，最后在后端编译出平台相关的机器语言。Clang命令行参数文档:Clang command line argument reference llvm-as LLVM的汇编器，它可以将LLVM IR转换为bitcode(就像把普通的汇编代码转换为可执行文件)。 llvm-dis LLVM的反汇编器，它可以将bitcode转回为LLVM IR。 llvm-link LLVM bitcode的链接器，可以将多个bitcode链接成一个bitcode。 opt LLVM模块化的优化器和分析器。可以通过使用PASS对LLVM IR或者LLVM bitcode进行优化处理。 ","date":"2021-01-06","objectID":"/posts/llvm/%E5%9C%A8windows%E4%B8%8B%E6%90%AD%E5%BB%BAllvm%E7%8E%AF%E5%A2%83%E4%B8%80/:0:0","tags":["LLVM"],"title":"在Windows下搭建LLVM环境(一)","uri":"/posts/llvm/%E5%9C%A8windows%E4%B8%8B%E6%90%AD%E5%BB%BAllvm%E7%8E%AF%E5%A2%83%E4%B8%80/"},{"categories":["项目管理"],"content":"积累的一些想法，根本不一定是对的: 1、要么就提战略上的宏观目标，要么就提具体的需求，永远不要将目标当成需求交给底层人员解决。 2、项目中，去除项目之间的依赖性，分开业务逻辑一定比合在一起好，俗称解耦? ","date":"2021-01-01","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/:0:0","tags":["笔记","经验"],"title":"项目经验总结","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"categories":["杂文"],"content":"Crypto++ 官网:https://www.cryptopp.com/ 也被称为CryptoPP,libcrypto++和libcryptopp，是免费开源的C++算法库。该库支持多种加密算法，且代码运行性能较高，例如AES算法使用了AES-NI，计算性能较普通的AES算法有显著提高。 OpenSSL 官网:https://www.openssl.org/source/ 二进制包下载地址:http://slproweb.com/products/Win32OpenSSL.html openssl是一个安全套接字层密码库，囊括主要的密码算法、常用密钥、证书封装管理功能及实现ssl协议。 ","date":"2020-12-30","objectID":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:0","tags":["Github"],"title":"开源项目","uri":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["杂文"],"content":"Emscripten Github项目地址:Emscripten Emscripten 是 Mozilla 的 Alon Zakai 开发的一个独特 LLVM 后端，可以将任意LLVM中间码编译成JavaScript。 LLVM负责解析C/C++代码，输出初步解析后的中间代码，后端Emscripten负责将中间代码转换为JavaScript代码，作者设计了一套转换语法，想办法在JavaScript中创建出C/C++的特性，但很明显并不是所有的C/C++的代码都能进行完美转换。 为了提高速度，生成出来的JS代码被优化成了WebAssembly，这是一种类似于二进制的文件，这样可以在js中编写一套解释执行框架去执行这些字节码。 ","date":"2020-12-30","objectID":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:1","tags":["Github"],"title":"开源项目","uri":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["杂文"],"content":"虽然说我天天和Windows X86平台下的汇编指令打交道，大部分指令都已经掌握了，但直到有一天需要对这些指令进行逐个解析处理的时候，才发现自己对这些指令的掌握远远不够。 首先X86平台下的这些指令，是可以进行分类的。 由于不知道专业术语是什么，我自己定义了名称: 下列这些指令，我称之为灵活的双操作数指令: ADD ADC MOV SBC SUB XOR 它们的特点就是支持mov [eax],eax;mov eax,[eax]这样的操作。 如何在不改变标志位的情况，对寄存器进行增减? 使用add,sub,inc,dec等指令会修改标志位，使用lea指令即可。 lea eax,[eax+0x1];\rlea eax,[eax-0x1];\r","date":"2020-12-27","objectID":"/posts/x86%E6%8C%87%E4%BB%A4%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/:0:0","tags":["指令集 X86"],"title":"X86指令进阶学习","uri":"/posts/x86%E6%8C%87%E4%BB%A4%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"16位、32位、64位指令 80x86系列处理器有一个逐渐发展的过程。 8086、8088、80286是16位结构处理器，支持16位指令系统。 常用的汇编器有以下几种: 编译器 开发者 优点 缺点 MASM 微软 微软自家软件和系统兼容性好；支持invoke/.if等伪指令将汇编变得和C++差不多 就一个编译器，没有资源编译器和链接器，也没有头文件 TASM Borland 支持伪指令，有资源编译器和链接器 没有Windows数据结构和预定义的头文件，现在官方似乎不维护了 NASM 开源 同时支持Windows和Linux 不支持伪指令，没有Windows数据结构和预定义的头文件 MASM是Microsoft Macro Assembler的缩写，它是微软为x86 微处理器家族所写的一套宏汇编器。 masm虽然产品年龄比较大，但是它是最受各方支持的汇编器，在最新版的Visual Studio中，我们能在bin目录中找到一个ml.exe，这个就是masm中编译部分的一个核心程序。 我们可以在http://www.masm32.com/网址上找到MASM32开发包。 安装好开发包后我们可以在masm32目录下找到一个qeditor.exe可视化开发工具。 新建一个test.asm文件，编写以下代码 .386 ; 编译器指令，使用386指令集 .model flat, stdcall ; model汇编指令，程序的内存模式, flat是windows程序，没有远近指针，stdcall是windows函数用的参数方式，即参数从右向左传递 option casemap :none ; 标签是否区分大小写 include \\masm32\\include\\windows.inc ; 包含了Win32 API 的一些常量和函数定义 include \\masm32\\include\\kernel32.inc ; 包含了后面使用的ExitProcess函数 include \\masm32\\include\\masm32.inc ; 包含了后面使用的StdOut函数，不是标准的Win32函数，由MASM提供 includelib \\masm32\\lib\\kernel32.lib ; 库文件 includelib \\masm32\\lib\\masm32.lib .data HelloWorld db \"Hello World!\", 0 ; 定义使用的字符串常量,db代表define byte。最后跟一个NUL，表示ANSI字符集结束符 .code ; 开始代码区 start: ; 所有的代码要在start标签后、end start前 invoke StdOut, addr HelloWorld ; 调用函数StdOut，参数量HelloWorld的地址。注意StdOut是MASM提供的宏。其它编辑器里可以使用WriteConsole之类win32函数代替。 invoke ExitProcess, 0 ; 调用ExitProcess end start 选择菜单Project-\u003eAssemble ASM file，我们就可以根据asm文件生成出obj文件。 再选择菜单Project -\u003e Link OBJ File，就可以根据obj文件链接得到可执行文件。 以上两个步骤实质上是通过调用masm32/bin目录下的ml.exe和link.exe这两个程序来完成的，我们也可以在控制台输入以下命令，完成编译链接操作: ml.exe /c /Zd /coff test.asm link.exe /SUBSYSTEM:WINDOWS test.obj 编写16位程序 masm默认编译出来的程序是32位的，但目录下其实也有一个link16.exe用来生成16位程序。 示例代码如下: .MODEL SMALL .data HelloWorld db \"Hello World!\", 0 .code start: mov ax,2 end start 我们可以执行以下命令行，来生成16位的程序 ml.exe /Zm /c test.asm link16.exe test.asm %1,,,,, ","date":"2020-12-23","objectID":"/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/:0:0","tags":["汇编 MASM"],"title":"MASM学习","uri":"/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"categories":["C++逆向"],"content":"C++存在非常令人头疼的STL模板库，如果不去了解它的话，还原C++代码又会特别吃力。。。 不同的VC版本或者Debug\\Release版，STL库都可能有一定的差别。 这里以VS2017 Release版本为示例: String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-09-24","objectID":"/posts/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["爬虫"],"content":"想标题想了很久，最后感觉还是用这个标题比较合适。 问题情景是这样的： 有一个较为古老的CEF程序，需要对程序里面的内容进行爬取，获取数据。 众所周知，CEF框架无非就是个浏览器，最终访问的还是网页，那么我们直接访问网页进行爬取不就好了吗? 但实际上能否这样做是值得商榷的，例如我要爬取的那个程序，通过CEF注册JS扩展的方式，使网页与本地的其它进程建立起了通讯，这样我就不能脱离这个CEF程序而独立去访问网页了，否则页面将无法正常运作。 遇到这种情况，我们可以根据远程调试协议开启浏览器的远程调试功能，再用Selenium或者Puppeteer等爬虫工具挂接浏览器，这样我们就可以对浏览器进行一些自动化操作了。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:0","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"开启远程调试 开启方法很简单，在要调试的浏览器进程快捷方式属性上加上参数: --remote-debugging-port=9222 --user-data-dir=C:\\ChromeDebug\r远程调试端口一般为9222，用户数据目录我们随便创建一个就好。 这个时候我们可以访问127.0.0.1:9222/json/version，其中有一个值叫webSocketDebuggerUrl，调试程序主要就是根据这个URL来连接上浏览器的。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:1","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"Selenium爬虫 为什么使用Selenium而不是Puppeteer呢？先前已经提到，该CEF程序是一个古老的程序，Chromium浏览器内核版本为V58左右，而Puppeteer框架对浏览器版本有着严格的限制，官方也有说明:每一个版本的Puppeteer理论上只适配一个特定版本的Chromium浏览器。而Selenium框架对版本支持更加友好，不管老版本还是新版本，都有适配的浏览器驱动，我们只需要去下载相应版本的WebDriver即可。下载地址如下: http://chromedriver.storage.googleapis.com/index.html 至于Selenium的使用教程，参考一下: https://selenium-python-zh.readthedocs.io/en/latest/ 编写代码连接上浏览器 from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option('debuggerAddress','127.0.0.1:9222') browser = webdriver.Chrome(executable_path=\"C:\\chromedriver.exe\",chrome_options=chrome_options) browser.get('http://www.baidu.com') 之后后面的模拟点击、爬取内容就不再细谈了。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:2","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["Github碎片"],"content":"1.DocFx是微软的一款开源的文档生成工具，下载地址如下:https://github.com/dotnet/docfx/releases 软件的官网是https://dotnet.github.io/docfx，在里面还可以获取到一些教程 2.此软件的运行需要.Net Framework 4.7.2环境，需要自行安装 3.创建一个DocFx工程 docfx init -q\r4.建立网站 docfx docfx_project\\docfx.json --serve\r这样就可以通过访问http://localhost:8080来查看文档页面了，里面包含了一些基本的页面。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"docfx.json解析 docfx.json是docfx用于生成文档的配置文件，目前docfx.json只包含了两个键值对，分别是metadata和build。 metadata属性如下(暂时对我来说好像没什么用，我就不管了): Key Description src 工程源码的位置 dest 存放生成的metadata文件的目录 force shouldSkipMarkup filter useCompatibilityFileName properties build属性如下: Key Description content 用于生成文档的全部文件 resources 资源文件或者元数据文件，例如图片文件。 overwrite Contains all the conceptual files which contains yaml header with uid and is intended to override the existing metadata yml files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadata 应用于每个文件的配置选项，例如在globalMetadata中定义\"_appTitle\": \"我是标题\",则每个页面都会追加标题文本。 fileMetadata Contains metadata that will be applied to specific files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadataFiles Specify a list of JSON file path containing globalMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. fileMetadataFiles Specify a list of JSON file path containing fileMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. template The templates applied to each file in the documentation. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, embedded default template will be used. theme The themes applied to the documentation. Theme is used to customize the styles generated by template. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, no theme will be applied, the default theme inside the template will be used. xref Specifies the urls of xrefmap used by content files. Currently, it supports following scheme: http, https, ftp, file, embedded. xrefService Specifies the url patterns of xref service. Please read Section3.2.4 for detail. exportRawModel If set to true, data model to run template script will be extracted in .raw.json extension. rawModelOutputFolder Specify the output folder for the raw model. If not set, the raw model will be generated to the same folder as the output documentation. exportViewModel If set to true, data model to apply template will be extracted in .view.json extension. viewModelOutputFolder Specify the output folder for the view model. If not set, the view model will be generated to the same folder as the output documentation. dryRun If set to true, template will not be actually applied to the documents. This option is always used with --exportRawModel or --exportViewModel, so that only raw model files or view model files are generated. maxParallelism Set the max parallelism, 0 (default) is same as the count of CPU cores. markdownEngineName Set the name of markdown engine, default is dfm, other available engines are gfm and markdig. markdownEngineProperties Set the parameters for markdown engine, value should be a JSON string. noLangKeyword Disable default lang keyword, it can be downloaded from here. keepFileLink If set to true, docfx does not dereference (aka. copy) file to the output folder, instead, it saves a link_to_path property inside manifest.json to indicate the physical location of that file. A file link will be created by incremental build and copy resouce file. sitemap In format SitemapOptions Specifies the options for the sitemap.xml file. disableGitFeatures Disable fetching Git related information for articles. Set to true if fetching git related information is slow for huge Git repositories. Default value is false. ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"更换主题模板 我个人对官方默认的主题不是特别满意，我们可以去官网下载其它的主题模板。 下载完成后进行以下步骤使用模板 在Doxfx网站根目录创建一个templates文件夹 将主题文件夹拷贝至templates文件夹目录下 在docfx.json中的template项中添加模板文件夹的路径，例如我使用的是mathew主题模板 { \"template\": [ \"default\", \"templates/mathew\" ], } 主题文件夹中有一个main.css可以用来修改主题的一些属性 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"配置文档目录 docfx工程默认结构如下: docfx_project/index.md为主页的显示内容 docfx_project/toc.yml为文档目录配置文件，对应docfx_project/api和docfx_project/articles这两个目录 我们可以通过修改docfx_project/toc.yml来配置文档目录，例如默认配置文件如下 - name:Articleshref:articles/- name:Api Documentationhref:api/homepage:api/index.mdyml这种数据格式可能不太熟悉，其实和json差不多，转换成json如下 [ { \"name\": \"Articles\", \"href\": \"articles/\" }, { \"name\": \"Api Documentation\", \"href\": \"api/\", \"homepage\": \"api/index.md\" } ] 在添加目录或者修改目录的时候，同时也要修改docfx_project/docfx.json中的content，因为content包含用于生成文档的全部文件。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"开启搜索功能 如果想要开启程序自带的搜索功能，需要进行以下两步: 程序其实预留了一些配置项，通过修改globalMetadata可以设置它们，在docfx_project/docfx.json中添加以下globalMetadata项 \"globalMetadata\": { \"_enableSearch\": \"true\", }, 这样我们就开启了页面上的搜索栏。 程序如果要对生成后的HTML文件继续处理，可以通过添加postProcessors项来进行操作，在docfx_project/docfx.json中添加postProcessors项 \"postProcessors\": [ \"ExtractSearchIndex\" ], 这表示程序会在生成HTML文件之后提取里面的单词生成一个数据库，可用于搜索。 程序完整的预留MetaData如下: Metadata名称 类型 描述 _appTitle string Will be appended to each output page’s head title. _appFooter string 页脚内容，如果未设置则默认为Generated by DocFX _appLogoPath string Logo file’s path from output root. Will show DocFX’s logo if not specified. Remember to add file to resource. _appFaviconPath string Favicon file’s path from output root. Will show DocFX’s favicon if not specified. Remember to add file to resource. _enableSearch bool 用于设置是否在页面上方显示搜索栏 _enableNewTab bool Indicate whether to open a new tab when clicking an external link. (internal link always shows within the current tab) _disableNavbar bool Indicate whether to show the navigation bar on the top of page. _disableBreadcrumb bool Indicate whether to show breadcrumb on the top of page. _disableToc bool Indicate whether to show table of contents on the left of page. _disableAffix bool Indicate whether to show the affix bar on the right of page. _disableContribution bool Indicate whether to show the View Source and Improve this Doc buttons. _gitContribute object Customize the Improve this Doc URL button for public contributors. Use repo to specify the contribution repository URL. Use branch to specify the contribution branch. Use apiSpecFolder to specify the folder for new overwrite files. If not set, the git URL and branch of the current git repository will be used. _gitUrlPattern string Choose the URL pattern of the generated link for View Source and Improve this Doc. Supports github and vso currently. If not set, DocFX will try speculating the pattern from domain name of the git URL. _noindex bool File(s) specified are not returned in search results ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["心情文学"],"content":"以下是个人对于创业的一点小小的思考。 作为一名创业者，思路应该是这样的: 深入挖掘社会的潜在需求 -\u003e 根据需求来设计项目 -\u003e 评估项目可行性(资金、人员、周期) -\u003e 组织人员推动项目进展 ","date":"2020-09-13","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/:0:0","tags":["创业","社会需求"],"title":"社会需求与创业","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/"},{"categories":["心情文学"],"content":"社会的潜在需求: 为什么要说是潜在需求呢？因为明面上的需求大家都看得见，要么是已经被人解决了，要么是解决不了遗留着的。只有找到社会的潜在需求才能创造价值、创造财富。 就目前来说我个人能想到的需求有: 远程办公需求:未来某些职业(互联网相关?)在条件上是可以实施云办公的吧。如果能够在家中工作，我想员工的幸福度也许会大幅度提升，而且远程办公一旦能够落地实施，终将会成为一种趋势。但是目前的情况是软硬件环境跟不上，目前仍需要一套成熟的远程办公的解决方案。需要5G + 全息投影 + 软件 + 办公规则的制定。 开发一款能锻炼视力的VR游戏。 ","date":"2020-09-13","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/:0:1","tags":["创业","社会需求"],"title":"社会需求与创业","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E7%A4%BE%E4%BC%9A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%88%9B%E4%B8%9A/"},{"categories":["爬虫"],"content":"Puppeteer，木偶框架，是谷歌开源的一个浏览器控制框架。它提供了一组可以用来操控Chrome的API，使得我们可以很方便地进行一些浏览器模拟、自动化操作，例如: 生成网页截图或者 PDF 高级爬虫，爬取大量异步渲染内容的网页 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试 捕获站点的时间线，以便追踪网站，帮助分析网站性能问题 至于为什么选择Puppeteer，而不使用Selenium、CEF等其它框架来模拟浏览器操作，是因为Puppeteer有以下优点: Puppeteer是站在用户使用的角度上来设计操作接口，而不是浏览器的角度，使用起来较为简单、更人性化 由Chrome官方团队进行维护，拥有更好的前景 功能比Selenium更强大，可以很方便地对网络请求进行拦截 使用与浏览器相同的语言，与浏览器衔接更好 Puppeteer同样也有缺点，缺点如下: 只支持Chrome、FireFox浏览器，不支持IE浏览器 只支持NodeJs、C#两种语言 Puppeteer实际上为NodeJs的一个库，NodeJs部署也较为简单，首先到NodeJs官网 https://nodejs.org/en/配置好NodeJs环境。 之后可以在cmd中运行以下指令安装puppeteer库。 npm install puppeteer --save npm介绍: NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 到此puppeteer环境就已经配置好了，如果要编写puppeteer相关的代码，那么还需要配置一下NodeJs的编程环境，可选的编程环境有 webstorm、Visual Studio、VSCode等。这里笔者使用的是Visual Studio，不要问我为什么，Visual Studio天下第一！ 不过在使用Visual Studio的时候，可能会出现一点问题，例如以下代码 var 百度主页 = \"https://www.baidu.com\"; Visual Studio将无法编译通过，这是因为Visual Studio中的源码默认字符集设置问题，需要将字符集编码改为UTF-8。 但是VS 2019隐藏了高级保存功能，导致没办法直接去设置代码编码为UTF-8。具体开启步骤参考如下: 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 之后我们就可以通过高级保存选项来设置源码的字符集编码了。 官方API文档:https://zhaoqize.github.io/puppeteer-api-zh_CN/#/，请务必频繁查看此API文档。 Browser类 一个Browser可以理解成一个浏览器实例，这个类较为简单，使用Browser创建Page例子如下: const puppeteer = require('puppeteer'); puppeteer.launch().then(async browser =\u003e { const page = await browser.newPage(); //浏览器创建一个新标签页 await page.goto('https://www.baidu.com'); //标签页导航到指定网址 await browser.close(); //关闭浏览器 }); Page类 这个类最为关键，可能是要用到的最多的一个类。Page提供对单个标签页进行操作的方法，一个Browser实例可以有多个Page实例。 ","date":"2020-09-01","objectID":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["爬虫"],"content":"实际应用场景模拟 就以爬取百度搜索结果为例吧，目标是爬取出指定搜索结果。 1、新建浏览器，定位到页面 ","date":"2020-09-01","objectID":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["二进制特征码识别"],"content":"我们首先从数学的角度去考虑，如何对比两个值是否为相似的呢？ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:0","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"1、 欧式距离（Euclidean Distance） 欧式距离全称是欧几里距离，是最易于理解的一种距离计算方式，源自欧式空间中两点间的距离公式。 平面空间内的(x1,y1) 与(x2,y2) 间的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2} $$ 三维空间里的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2} $$ 当两个点之间的距离为0时，代表两个值完全相似，两个点之间的距离越大，则相似度越低。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:1","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"2、 余弦相似度（Cosine） 在坐标中存在两条向量，通过计算两条向量之间的夹角来对比差异。 平面坐标中向量(x1,y1)与向量(x2,y2)之间可以构成一个三角形，根据三角形余弦夹角公式，得到两个向量之间的夹角计算公式如下： $$ \\cos(\\theta) = \\frac{x1x2+y1y2}{\\sqrt{x1^2+y1^2}\\sqrt{x2^2+y2^2}} $$ 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，夹角等于0，即两个向量相等，这就叫\"余弦相似性\"。 欧式距离和夹角余弦的区别： 夹角余弦更能反映两者之间的变动趋势，两者有很高的变化趋势相似度，而欧式距离较大是因为两者数值有很大的区别，即两者拥有很高的数值差异。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:2","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"3、皮尔逊相关系数（Pearson Correlation Coefficient） pearson相关系数p是一个介于[-1,1]之间的值。 如果p=1，称X与Y完全线性相关; 如果p=0，称X与Y无线性关系; 如果p\u003e0，称X与Y正相关; 如果p\u003c0，称X与Y负相关。 如果两个随机变量相关独立，则它们的相关系数为0；如果两个随机变量的相关系数为0，这两个随机变量却未必独立。 皮尔逊相关系数与余弦相似度较为相似。 在数据标准化后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:3","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"4、汉明距离（Hamming distance） 汉明距离可以理解为两个向量中不相等的值的个数。 例如X为1001，Y为1110，不同的值有3个，汉明距离就是3。 其实说简单点就是暴力对比，相同的点位越多，越相似。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:4","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"5、曼哈顿距离（Manhattan Distance） 在平面上，坐标(x1,y1)与坐标(x2,y2)之间的曼哈顿距离为: $$ d = |x1-x2|+|y1-y2| $$ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:5","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"项目管理 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"克隆含有子模块的项目 当一个git项目含有子模块(submodule)时，直接克隆下来的子模块目录里面是空的。 这时可以在执行git clone时加上–recursive参数，它会自动初始化并更新每一个子模块，例如 git clone --recursive https://github.com/x64dbg/x64dbg.git 如果项目已经克隆到了本地，执行下面的步骤： 1.初始化本地子模块配置文件 git submodule init 2.更新项目，抓取子模块内容。 git submodule update ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置Git信息 第一次使用git的时候需要配置一下用户名和邮箱 git config --global user.name fjqisba git config --global user.email fjqisba@sohu.com 清空所有的commit 想要删掉仓库中所有的commit，得到一个新的仓库且当前代码不变，可以使用下面的命令 git checkout --orphan newBranch git add -A git commit -am \"commit message\" git branch -D master git branch -m master git push -f origin master 关闭Github的换行符自动转化功能 git config --global core.autocrlf false 搜索功能 1、搜索star数目超过1w的项目，stars:\u003e10000 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["静态分析"],"content":"当前IDA能用的版本勉强只有一个泄露出安装包+跑出安装包Key的IDA 7.2版本 + x64 Hex-Rays 可以参考一下此文档: https://github.com/jas502n/IDA_Pro_7.2 由于没有完整的Hex-Rays插件，因此只好去杂交7.0版本的Hex-Rays，插件在此下载。 下载完成后覆盖在IDA目录下，即可拥有IDA7.2 + 7.0 Hex-Rays。 展望未来 目前发现一个IDA7.4比较完整的安装包，但是尚未跑出Key，个人觉得比较悬了，暂且关注一下吧 https://bbs.pediy.com/thread-261050-1.htm 2020年12月23日更新 IDA已泄露出7.5 SP3版本，https://bbs.pediy.com/thread-264354.htm ","date":"2020-08-17","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/:0:0","tags":["IDA"],"title":"配置IDA环境","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/"},{"categories":["Github碎片"],"content":"ZyDis库 Zydis是一个开源的反汇编引擎库，项目地址为:https://github.com/zyantific/zydis。 1.克隆存储库，得到Zydis源码。 2.由于笔者使用的是Windows平台下的Visual Studio环境，因此可以直接运行源码目录zydis\\msvc\\Zydis.sln的工程。 3.在工程中编译库，大致分为DLL动态库或者静态库两种方式，笔者比较喜欢静态编译的方式，因此工程配置选择Release MT，编译x86和x64两个版本的库。 4.提取出include头文件和lib文件，即得到反汇编引擎库。 新建一个测试工程 1.附加包含目录中添加Zydis\\include 2.附加库目录视编译平台选择Zydis\\lib\\X86或者Zydis\\lib\\X64 3.附加依赖项中添加Zycore.lib和Zydis.lib 4.预处理器定义中添加两行 ZYCORE_STATIC_DEFINE\rZYDIS_STATIC_DEFINE\r编写代码进行测试，可以正常地使用Zydis库函数，则代表反汇编引擎配置成功! ","date":"2020-08-16","objectID":"/posts/github%E7%A2%8E%E7%89%87/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:1","tags":["反汇编引擎","ZyDis"],"title":"反汇编引擎","uri":"/posts/github%E7%A2%8E%E7%89%87/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":["心情文学"],"content":"由于没有任何工作经验,大老远跑来北京实习,住在这边的公租房实习生宿舍,获取网络成了我第一个要解决的问题. 幻影WIFI暴力枚举的话我并不是很喜欢,幻影PIN倒是可以用来搞那些开了WPS的旧版路由器,可惜我的手机并没有完整的ROOT权限. 于是我下载了一个万能钥匙显密码版,扫了一下,只发现一个能用的WIFI——JIUBUGAOSUNI, 然而这个WIFI信号质量太差了,我必须将我的笔记本放在窗边才能勉强得到较好的网速… 于是我查看了一下网关,进入路由器后台,熟悉的斐讯K2界面..填路由器管理员密码,我试了试WIFI密码,结果一试就中… 我将路由器带宽改成了20MHZ,信道试了试13号,似乎信号有了明显的小改善,可是信号质量依旧还是不稳定. 我不得不会会一个信号质量更好点的WIFI,小米共享WIFI,首先光听名字就感觉有点东西,这是我一开始不愿意接触这个的理由. 在查询了一些关于这个WIFI的资料后,发现: 这个WIFI每个客户每次上网都需要访问一个访问网络地址,每次只能免费3分钟,3分钟过后想要联网就必须得重新访问,而且重复次数达到一定次数就提示免费次数已达到上限,不给用网了. 对这个协议进行了小小的分析,发现要想联网只需访问 http://api.miwifi.com/wifirent/api/ad_apply_rent?callback=jsonpCallback\u0026router_id=06136143-ce88-1b71-fe90-e9479fe1fd4d\u0026client_info=1THJz%2BvESwpnKmn6RtvxtrJEyra%2BgBFDjl9Z7vBOMFtwMD5gmH8PsAPUS3MP1wnR 这个地址即可, 其中只有两个参数,router_id是路由器设备号,client_info是包含用户MAC地址在内的加密字符串. 仔细想想,如果我是一台控制路由器的服务器,客户要想连我的网,就必须发送给我MAC地址,那么我对此MAC地址进行计时,只允许使用3分钟,再进行计次,每隔N小时只能使用3次,那么站在程序员的角度来说, 客户是无论怎样试图篡改网络协议中的参数,也是没办法突破小米路由器的限制,来达到单MAC地址无限使用网络的.毕竟功能在服务器上面,逆向破解软件的我对此深有体会… 那么这样就没有必要再继续研究下去了,我发现整个流程中唯一我能攻击的漏洞就在于每个用户能体验三分钟网络本身. 我下载了一个TMAC(修改MAC地址),结合自动联网程序(易语言简单迅速),不到一会就开发出了一个简易的暴力联网程序. 该程序每隔一段时间随机修改MAC地址,然后访问联网API进行联网,总之我暂时是能舒服地用这个带宽10MB的网络了(打游戏还是有点勉强….) ","date":"2018-11-17","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/:0:0","tags":["实习"],"title":"获取网络小记","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/"},{"categories":["心情文学"],"content":"个人所思，如有雷同，与我无关。 1、一定要勤于记录。 2、赚钱是解开人生束缚的第一步。 3、人和人之间外表相差无几，内在却千奇百怪。 4、三思而后行，第一思是思考做这件事的意义，人生少做徒劳之事。 5、一个人从什么时候开始渐渐丧失快乐的呢，从他开始建立宏伟的目标开始。 6、人是健忘的动物，努力和懒惰飘忽不定，唯有记录永恒。 7、 ","date":"1998-05-13","objectID":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E8%AE%A4%E7%9F%A5/:0:0","tags":["笔记"],"title":"关于认知","uri":"/posts/%E5%BF%83%E6%83%85%E6%96%87%E5%AD%A6/hidden/%E5%85%B3%E4%BA%8E%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"fjqisba，毕业于南京邮电大学软件工程系。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]