[{"categories":["反编译"],"content":"记一次修复Ghidra反编译混淆代码的Bug经历 最近在尝试使用Ghidra来对混淆代码进行反编译，然而在反编译一段代码的时候出现了问题，这里记录一下修复的过程，希望对其他人有起到一点帮助。 ","date":"2023-09-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/:0:0","tags":["Ghidra"],"title":"记一次修复Ghidra反编译混淆代码的Bug经历","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/"},{"categories":["反编译"],"content":"复现问题 为了方便描述代码经过了简化处理，大概是下面这个样子的: 00401009 push 0x2F9D6707\r0040100E push 0xD915B19B\r00401013 push 0x1\r00401015 mov ecx,dword ptr ss:[esp+0x6]\r00401019 mov dword ptr ss:[esp+ecx-0x6707D915],0x2\r00401024 pop eax\r00401025 retn 通过实际运行这段代码很明显eax最终的值是0x2，然而Ghidra在这里算出来的eax是0x1。 我们调试一下Ghidra的反编译过程，在Action::perform函数里面插个日志打印代码，将执行Action后的pcode全部都打印出来，从而快速定位到最关键的Action。 最终发现是执行oppool1这个动作后，pcode发生了错误，错误之前的pcode是下面这样的; 0x00401009:2: u0x10000014(0x00401009:2) = #0x2f9d6707\r0x00401009:1e: s0xfffffffc:2(0x00401009:1e) = SUB42(u0x10000014(0x00401009:2),#0x0)\r0x0040100e:5: u0x10000010(0x0040100e:5) = #0xd915b19b\r0x0040100e:1d: s0xfffffffa:2(0x0040100e:1d) = SUB42(u0x10000010(0x0040100e:5),#0x2)\r0x00401013:8: s0xfffffff4(0x00401013:8) = #0x1\r0x00401015:1b: u0x1000000c(0x00401015:1b) = CONCAT22(s0xfffffffc:2(0x00401009:1e),s0xfffffffa:2(0x0040100e:1d))\r0x00401015:a: u0x00007a00(0x00401015:a) = u0x1000000c(0x00401015:1b)\r0x00401019:c: u0x00002700(0x00401019:c) = ESP(i) + #0x98f826df\r0x00401019:e: u0x00002880(0x00401019:e) = u0x00002700(0x00401019:c) + u0x00007a00(0x00401015:a)\r0x00401019:1a: s0xfffffff4(0x00401019:1a) = s0xfffffff4(0x00401013:8) [] i0x00401019:10(free)\r0x00401019:10: *(ram,u0x00002880(0x00401019:e)) = #0x2\r0x00401024:11: EAX(0x00401024:11) = s0xfffffff4(0x00401019:1a)\r0x00401025:15: return(EAX(0x00401024:11)) 然而执行完oppool1之后，pcode直接变成了 0x00401019:e: u0x00002880(0x00401019:e) = ESP(i) + #0xfffffff4\r0x00401019:10: *(ram,u0x00002880(0x00401019:e)) = #0x2\r0x00401024:11: EAX(0x00401024:11) = #0x1\r0x00401025:15: return(EAX(0x00401024:11)) EAX(0x00401024:11) ","date":"2023-09-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/:1:0","tags":["Ghidra"],"title":"记一次修复Ghidra反编译混淆代码的Bug经历","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/"},{"categories":["反编译"],"content":"分析Bug原因 oppool1其实是Ghidra里面的核心Action之一，里面包含了一系列优化规则，再进一步调试oppool1里面的规则，可以定位到是RulePropagateCopy这个规则，RulePropagateCopy会对CPUI_COPY类型的节点进行传播，规则将 0x00401013:8: s0xfffffff4(0x00401013:8) = #0x1\r0x00401024:11: EAX(0x00401024:11) = s0xfffffff4(0x00401013:8) 转换成了 0x00401024:11: EAX(0x00401024:11) = #0x1 分析到这里，Ghidra反编译失败的原因就很明显了，在将*(ram,u0x00002880(0x00401019:e))识别成堆栈变量s0xfffffff4之前就进行了传播优化。 ","date":"2023-09-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/:2:0","tags":["Ghidra"],"title":"记一次修复Ghidra反编译混淆代码的Bug经历","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/"},{"categories":["反编译"],"content":"解决方案 那么怎么解决这个问题呢，Ghidra的oppool1老实说我感觉就像是一个大杂烩，啥规则都往里面扔，里面的优化逻辑就是一直优化，优化到pcode没有发生变化为止，然而优化顺序似乎不怎么能保证，因此我决定自己编写规则。 模仿oppool2中的RuleStoreVarnode规则，这个规则是尝试将store节点转换为stack变量，我们也写一个RuleVmpStoreVarnode规则，在每次遇到CPUI_STORE类型的pcode的时候，就尝试去计算写入的地址是否是堆栈。规则代码如下: class RuleVmpStoreVarnode : public Rule { public: RuleVmpStoreVarnode(const string\u0026 g) : Rule(g, 0, \"vmpstorevarnode\") {} ///\u003c Constructor virtual Rule* clone(const ActionGroupList\u0026 grouplist) const { if (!grouplist.contains(getGroup())) return (Rule*)0; return new RuleVmpStoreVarnode(getGroup()); } virtual void getOpList(vector\u003cuint4\u003e\u0026 oplist) const; virtual int4 applyOp(PcodeOp* op, Funcdata\u0026 data); }; void RuleVmpStoreVarnode::getOpList(vector\u003cuint4\u003e\u0026 oplist) const { oplist.push_back(CPUI_STORE); } int4 RuleVmpStoreVarnode::applyOp(PcodeOp* op, Funcdata\u0026 data) { VmpStackEvaluator evalCall; Varnode* offvn = op-\u003egetIn(1); int stackOffset = 0x0; if (!evalCall.EvaluateStackOffset(data, offvn, stackOffset)) { return 0; } int4 size = op-\u003egetIn(2)-\u003egetSize(); Address addr(data.getArch()-\u003egetStackSpace(), uint32_t(stackOffset)); data.newVarnodeOut(size, addr, op); op-\u003egetOut()-\u003esetStackStore(); // Mark as originally coming from CPUI_STORE data.opRemoveInput(op, 1); data.opRemoveInput(op, 0); data.opSetOpcode(op, CPUI_COPY); return 1; } 为了计算堆栈的偏移，写了一个类VmpStackEvaluator，核心思路就是不断遍历def节点，判断最终是否为esp + xxx这种偏移。 class VmpStackEvaluator { public: bool EvaluateStackOffset(Funcdata\u0026 data,Varnode* vn,int\u0026 outOffset); private: uintb traceVarnodeStack(Varnode* vn); uintb tracePcodeStack(PcodeOp* op); uintb eval(PcodeOp* op); private: bool bContainEsp = false; bool bError = false; VarnodeData espLoc; }; uintb VmpStackEvaluator::eval(PcodeOp* op) { if (bError) { return 0x0; } uintb val1 = traceVarnodeStack(op-\u003egetIn(0)); uintb val2 = traceVarnodeStack(op-\u003egetIn(1)); uintb calVal = op-\u003egetOpcode()-\u003eevaluateBinary(op-\u003egetOut()-\u003egetSize(), op-\u003egetIn(0)-\u003egetSize(), val1, val2); return calVal; } uintb VmpStackEvaluator::tracePcodeStack(PcodeOp* op) { if (bError) { return 0x0; } OpCode code = op-\u003ecode(); switch (code) { case CPUI_INT_ADD: case CPUI_INT_SUB: case CPUI_PIECE: case CPUI_SUBPIECE: return eval(op); case CPUI_COPY: return traceVarnodeStack(op-\u003egetIn(0)); default: bError = true; break; } return 0x0; } uintb VmpStackEvaluator::traceVarnodeStack(Varnode* vn) { if (bError) { return 0x0; } if (vn-\u003eisConstant()) { return vn-\u003egetOffset(); } if (vn-\u003eisInput()) { if (vn-\u003egetSpace() == espLoc.space \u0026\u0026 vn-\u003egetOffset() == espLoc.offset) { bContainEsp = true; } else { bError = true; } return 0x0; } PcodeOp* defOp = vn-\u003egetDef(); if (!defOp) { bError = true; return 0x0; } return tracePcodeStack(defOp); } bool VmpStackEvaluator::EvaluateStackOffset(Funcdata\u0026 data, Varnode* vn,int\u0026 outOffset) { espLoc = data.getArch()-\u003etranslate-\u003egetRegister(\"ESP\"); if (!vn-\u003eisWritten()) { return false; } PcodeOp* defOp = vn-\u003egetDef(); if (defOp-\u003ecode() != CPUI_INT_ADD \u0026\u0026 defOp-\u003ecode() != CPUI_INT_SUB) { return false; } outOffset = tracePcodeStack(defOp); if (bError) { return false; } return bContainEsp; } 不管效率怎么样，往oppool1里面扔进去这个规则，执行后最终的代码变成了: 0x00401024:11: EAX(0x00401024:11) = #0x2\r0x00401025:15: return(EAX(0x00401024:11)) 也算是勉强完成了修复吧 ","date":"2023-09-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/:3:0","tags":["Ghidra"],"title":"记一次修复Ghidra反编译混淆代码的Bug经历","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8Dghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81%E7%9A%84bug%E7%BB%8F%E5%8E%86/"},{"categories":["产品试用"],"content":"休闲类游戏 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:0:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["产品试用"],"content":"Raft 生存部分刚开始设计得挺有意思，但是后期内容就严重不足了，无法支撑这么久的故事剧情。还是只能当作一个小游戏来消遣消遣。 卡牌策略游戏 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:1:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["产品试用"],"content":"神州志西游 杀戮尖塔类的游戏，界面太粗糙了，搭配卡牌上五颜六色的文字就更辣眼睛了，还不如十年前的swf小游戏呢，玩法再多也没用。 策略游戏 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:2:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["产品试用"],"content":"Tower of Chaos 美术挺糟糕的，界面太烂了，没法玩。 战棋游戏 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:3:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["产品试用"],"content":"三角战略 中规中矩吧，我不太喜欢多周目，第一周目玩的普通难度，在没看攻略的情况，走到了真结局路线，结果告诉我之前破坏了机关无法到达真结局。。。无奈玩个高难度二周目打真结局。游戏性方面我认为还是设计得过于传统保守了，在高难度下友军只能猥琐堆在一起，寸步难行地一边防守一边对付弱智AI，把敌人数值加强的意义是什么呢？ 经营类游戏 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:4:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["产品试用"],"content":"Farming Simulator 22 未知 ","date":"2023-07-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/:5:0","tags":["坚果云"],"title":"游戏评测","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/"},{"categories":["反编译"],"content":"关于Sleigh指令转换器 Sleigh::oneInstruction负责将二进制转换为反汇编或者PCode指令。 这是一个转换器，通过递归查表来实现快速转换。 关于反编译核心Perform函数 反编译的核心动作类是在Architecture::buildAction进行构建的。 Action类就是执行一个反编译动作。 ActionGroup是按照固定的顺序执行一组反编译动作。 有各种各样的ActionGroup，根动作是ActionRestartGroup 每个动作都有一个名称，所有的规则保存在actionmap中，规则还有不同的种类: 有只执行一次的动作，还有每次函数发生改变都执行一次的动作。 动作是非常多的 ActionRestartGroup { ActionStart,非常关键，基本块和流程图生成 ActionConstbase,搜寻常量输入节点 ActionDefaultParams,初步确定每个子函数的原型,基本都是置为空 ActionExtraPopSetup ActionPrototypeTypes, ActionFuncLink actfullloop { actmainloop { ActionUnreachable,移除掉无法达到的Block块 ActionVarnodeProps, ActionHeritage,非常关键，执行SSA转换 ActionParamDouble,处理参数可能为浮点数的子函数 ActionSegmentize,处理区段相关的东西,貌似没什么用 ActionForceGoto,处理强制跳转 ActionDirectWrite,优化直接写入pcode ActionActiveParam,分析子函数的参数 ActionReturnRecovery,分析return的结果 ActionRestrictLocal,分析局部变量 ActionDeadCode,非常关键，移除未被使用的代码 ActionDynamicMapping, ActionRestructureVarnode, ActionSpacebase, ActionNonzeroMask, ActionInferTypes, //不断继续优化,循环执行多遍 actstackstall { oppool1 { //针对OP规则进行优化 } ActionLaneDivide, ActionMultiCse, ActionShadowVar, ActionDeindirect, ActionStackPtrFlow, } ActionRedundBranch, ActionBlockStructure, ActionConstantPtr, oppool2 { //针对OP规则进行优化 } ActionDeterminedBranch, ActionUnreachable, ActionNodeJoin, ActionConditionalExe, ActionConditionalConst, } ActionLikelyTrash ActionDirectWrite ActionDirectWrite ActionDeadCode ActionDoNothing ActionSwitchNorm ActionReturnSplit ActionUnjustifiedParams ActionStartTypes ActionActiveReturn } ActionStartCleanUp { opcleanup { //针对OP规则进行优化 } }, ActionPreferComplement, ActionStructureTransform, ActionNormalizeBranches, ActionAssignHigh, ActionMergeRequired, ActionMarkExplicit, ActionMarkImplied, ActionMergeMultiEntry, ActionMergeCopy, ActionDominantCopy, ActionDynamicSymbols, ActionMarkIndirectOnly, ActionMergeAdjacent, ActionMergeType, ActionHideShadow, ActionCopyMarker, ActionOutputPrototype, ActionInputPrototype, ActionRestructureHigh, ActionMapGlobals, ActionDynamicSymbols, ActionNameVars, ActionSetCasts, ActionFinalStructure, ActionPrototypeWarnings, ActionStop, } ","date":"2023-06-02","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BA%8C/:0:0","tags":["Ghidra"],"title":"Ghidra反编译器(二)","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BA%8C/"},{"categories":["Python"],"content":"Windows搭建Python源码编译环境 1、下载源码 https://www.python.org/downloads/release/python-273/ 下载Source release版本就行了 2、运行PCBuild目录下的get_externals.bat，没有就不用运行了。 3、编译失败，提示找不到timezone、daylight、tzname等标识符，在变量名称前加一个下划线符号就行了。 4、编译失败，提示无法解析的外部符号 imp__pioinfo，找到PythonCore工程中的_PyVerify_fd函数，修改为以下代码 /* This function emulates what the windows CRT does to validate file handles */ int _PyVerify_fd(int fd) { // const int i1 = fd \u003e\u003e IOINFO_L2E; // const int i2 = fd \u0026 ((1 \u003c\u003c IOINFO_L2E) - 1); // static int sizeof_ioinfo = 0; // /* Determine the actual size of the ioinfo structure, // * as used by the CRT loaded in memory // */ // if (sizeof_ioinfo == 0 \u0026\u0026 __pioinfo[0] != NULL) { // sizeof_ioinfo = _msize(__pioinfo[0]) / IOINFO_ARRAY_ELTS; // } // if (sizeof_ioinfo == 0) { // /* This should not happen... */ // goto fail; // } // /* See that it isn't a special CLEAR fileno */ // if (fd != _NO_CONSOLE_FILENO) { // /* Microsoft CRT would check that 0\u003c=fd\u003c_nhandle but we can't do that. Instead // * we check pointer validity and other info // */ // if (0 \u003c= i1 \u0026\u0026 i1 \u003c IOINFO_ARRAYS \u0026\u0026 __pioinfo[i1] != NULL) { // /* finally, check that the file is open */ // my_ioinfo* info = (my_ioinfo*)(__pioinfo[i1] + i2 * sizeof_ioinfo); // if (info-\u003eosfile \u0026 FOPEN) { // return 1; // } // } // } //fail: // errno = EBADF; //a call to _get_osfhandle with invalid fd sets errno to EBADF if (_get_osfhandle(fd) == INVALID_HANDLE_VALUE) return 0; else return 1; return 0; } ","date":"2023-05-05","objectID":"/posts/python/windows%E6%90%AD%E5%BB%BApython%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/:0:0","tags":["Python"],"title":"Windows搭建Python源码编译环境","uri":"/posts/python/windows%E6%90%AD%E5%BB%BApython%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"},{"categories":["godot"],"content":"GoDot游戏开发入门 Github地址:https://github.com/godotengine/godot 官方入门文档:https://docs.godotengine.org/zh_CN/stable/ ","date":"2023-02-08","objectID":"/posts/godot%E5%BC%80%E5%8F%91/godot%E5%BC%80%E5%8F%91%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:0","tags":["游戏开发","godot"],"title":"godot开发入门","uri":"/posts/godot%E5%BC%80%E5%8F%91/godot%E5%BC%80%E5%8F%91%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["C++开发"],"content":"有如下标志位: ","date":"2022-12-13","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/:0:0","tags":["C++"],"title":"C++编译标志位大全","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/"},{"categories":["C++开发"],"content":"常规 启用字符串池(是|否)，/GF /GF- 启用最小重新生成(是|否)，/Gm Gm- 启用C++异常(是)，/EHsc 启用C++异常(是，但有 SEH 异常)，/EHa 启用C++异常(是，且有 Extern C 函数)，/EHs 较小类型检查(是)，/RTCc 基本运行时检查(堆栈帧)，/RTCs 基本运行时检查(未初始化的变量)，/RTCu 基本运行时检查(堆栈帧 + 未初始化的变量)，/RTC1 或者 /RTCsu 运行库(多线程)，/MT 运行库(多线程调试)，/MTd 运行库(多线程 DLL)，/MD 运行库(多线程调试 DLL)，/MDd 结构成员对齐(1|2|4|8|16字节)，/Zp1 /Zp2 /Zp4 /Zp8 /Zp16 启用安全检查(是|否)，/GS /GS- 控制流防护(是)，/guard:cf 启用函数级链接(是|否)，/Gy /Gy- ","date":"2022-12-13","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/:1:0","tags":["C++"],"title":"C++编译标志位大全","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/"},{"categories":["C++开发"],"content":"优化 优化(禁用):/Od 最大优化(优选大小):/O1 最大优化(优选速度):/O2 优化(优选速度):/Ox 内联函数扩展(禁用):/Ob0 内联函数扩展(只适用于 __inline ):/Ob1 内联函数扩展(任何适用项 ):/Ob2 启用内部函数(是):/Oi 优化大小或速度(代码大小优先):/Os 优化大小或速度(代码速度优先):/Ot 省略帧指针(是|否):/Oy /Oy- 启动纤程安全优化(是):/GT 全程序优化(是):/GL ","date":"2022-12-13","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/:2:0","tags":["C++"],"title":"C++编译标志位大全","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E7%BC%96%E8%AF%91%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%A7%E5%85%A8/"},{"categories":["前端"],"content":"官网:https://dart.dev/ ","date":"2022-12-10","objectID":"/posts/%E5%89%8D%E7%AB%AF/dart%E5%AD%A6%E4%B9%A0/:0:0","tags":["Dart"],"title":"Dart学习","uri":"/posts/%E5%89%8D%E7%AB%AF/dart%E5%AD%A6%E4%B9%A0/"},{"categories":["后端开发"],"content":"域名备案查询服务 https://whois.xinnet.com 简单易用，缺点是数据库有点垃圾，查不到域名的信息。 http://whois.chinaz.com/ 数据库还是比较弱。 https://shop.whois.com/ 数据库很强，加密也很强 http://www.jucha.com/whois/ ","date":"2022-12-04","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2/:0:0","tags":["域名"],"title":"域名查询","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2/"},{"categories":["安卓逆向"],"content":"Objection学习 ","date":"2022-11-22","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/:0:0","tags":["Objection"],"title":"Objection学习","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/"},{"categories":["安卓逆向"],"content":"安装 pip3 install -U objection ","date":"2022-11-22","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/:1:0","tags":["Objection"],"title":"Objection学习","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/"},{"categories":["安卓逆向"],"content":"注入 常规注入 objection -g zs.miaohui.xin explore 启动注入 objection -g zs.miaohui.xin explore --startup-command \"android hooking watch class xxx\" ","date":"2022-11-22","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/:2:0","tags":["Objection"],"title":"Objection学习","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/"},{"categories":["安卓逆向"],"content":"探索 打印内存中的所有类 android hooking list classes 搜索类名 android hooking search classes \u003cname\u003e 搜索方法 android hooking search methods \u003cname\u003e 查看指定类的方法列表 android hooking list class_methods \u003cname\u003e 列出所有的活动 android hooking list activities 监控某一个类 android hooking watch class \u003cname\u003e --dump-args --dump-return --dump-backtrace ","date":"2022-11-22","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/:3:0","tags":["Objection"],"title":"Objection学习","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/"},{"categories":["安卓逆向"],"content":"主动调用 android heap search instances \u003cclassname\u003e ","date":"2022-11-22","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/:4:0","tags":["Objection"],"title":"Objection学习","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/objection%E5%AD%A6%E4%B9%A0/"},{"categories":["CSharp"],"content":"1、关于函数参数的传值和传引用 不加ref关键字，默认都是传值哦。 ","date":"2022-11-20","objectID":"/posts/csharp/csharp%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["菜鸟"],"title":"C#语言菜鸟系列","uri":"/posts/csharp/csharp%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["安卓逆向"],"content":"据说自从安卓7.0以后，系统默认不再信任用户自行安装的证书文件。这里以burpsuite为例，记录一下抓包过程。 1、导出burpsuite证书，例如123.cer Proxy -\u003e Options -\u003e export CA certificate -\u003e Export Certificate in DER format 2、转换证书格式，命令行如下 openssl x509 -inform DER -in 123.cer -out cacert.pem openssl x509 -inform PEM -subject_hash_old -in cacert.pem 会算出9a5ba575这么一个哈希，将文件cacert.pem重命名为9a5ba575.0 3、将证书粘贴到/etc/security/cacerts 目录下 一般来说，这个目录是无法直接拷贝的，可以通过chmod临时修改权限。 mount -o remount,rw /system mount -o rw,remount /system mount -o rw,remount -t auto / mount -o rw,remount / ","date":"2022-11-13","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/:0:0","tags":["抓包"],"title":"安卓抓包教程","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/"},{"categories":["安卓逆向"],"content":"抓包工具体验 Postern 不会用。 ProxyDroid 简单的小玩具，仍有不少Bug需要解决。 Drony 还算是能用了，台湾的繁字体让能头疼，设置莫名其妙。 ","date":"2022-11-13","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/:1:0","tags":["抓包"],"title":"安卓抓包教程","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/"},{"categories":["安卓逆向"],"content":"1、手机连接电脑，adb devices找不到设备。 可能是数据线有问题，也有可能是驱动的问题。简单的办法是下载一个豌豆荚、360手机助手之类的软件，看看它们能不能检测到。 检测到了，再卸载软件就行了。。。。 2、开启调试模式 装个面具，进adb shell。 magisk resetprop ro.debuggable 1 stop;start ","date":"2022-11-12","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["新手"],"title":"安卓逆向常见问题","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["安卓逆向"],"content":"​ Flutter难就难在Dart部分的逆向，这又是一套字节码执行引擎，目前没有好用的反编译工具。 1、先了解了解Dart语言吧 https://dart.dev/overview 博客 https://blog.tst.sh/reverse-engineering-flutter-apps-part-1/ 2、来到项目地址https://github.com/dart-lang/sdk，发现搭建项目需要准备以下条件: Visual Studio 2022 社区版。 Windows调试SDK，安装方法https://stackoverflow.com/questions/46237620/how-to-install-debugging-tools-with-visual-studio-2017-installer gclient，看起来像是Google自家的项目管理工具，下载地址是:https://www.chromium.org/developers/how-tos/depottools/，添加环境变量。 安装Python3，添加环境变量。 添加环境变量DEPOT_TOOLS_WIN_TOOLCHAIN为0 调试SDK 3、创建目录sdk，执行下载源码指令 使用cmd fetch dart 如果出现HTTP/2 stream 1 was not closed cleanly before end of the underlying stream错误，试试以下命令： git config --global http.version HTTP/1.1 git config --global http.postBuffer 524288000 如果网络环境不太好，可以去vultr租一个服务器，把下载好的包上传到Google云盘，再拉回来。。。。。。 4、生成项目 使用powsershell cd sdk python3 ./tools/build.py --no-goma --mode debug --arch x64 create_sdk #只生成runtime python3 ./tools/build.py --mode debug --arch x64 runtime 如果出现You must install Windows 10 SDK version 10.0.20348.0 including the \"Debugging Tools for Windows\" feature错误，安装对应版本的Windows调试SDK。 如果出现xxx.gn文件缺失，且执行gclient sync命令之后错误依然出现，可以直接删掉整个目录从第三步开始。 5、编译不同的版本 事实上，后面我们会知道每个dart版本都有一个不同的hash值，我们需要根据该值来编译不同的版本源码。 关于如何切换到指定的分支，首先找到dart版本对应的commit，执行以下命令 git checkout 5aa5cd76f00e7774f71367f34d9998cfa0034d04 git clean -ffd gclient sync -D --force --reset gclient sync -D --force --reset --with_branch_heads git -c core.deltaBaseCacheLimit=2g clone checkout 73c34f2ad73f3d5e89680206a3beabb510be818c --progress https://dart.googlesource.com/sdk.git ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E6%90%AD%E5%BB%BAdart%E6%BA%90%E7%A0%81%E4%B8%80/:0:0","tags":["Flutter","Dart"],"title":"Flutter逆向之搭建dart源码(一)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E6%90%AD%E5%BB%BAdart%E6%BA%90%E7%A0%81%E4%B8%80/"},{"categories":["安卓逆向"],"content":"参考资料 https://www.pnfsoftware.com/blog/dart-aot-snapshot-helper-plugin-to-better-analyze-flutter-based-apps/ Reverse engineering Flutter apps (Part 1) (tst.sh) ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E6%90%AD%E5%BB%BAdart%E6%BA%90%E7%A0%81%E4%B8%80/:1:0","tags":["Flutter","Dart"],"title":"Flutter逆向之搭建dart源码(一)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E6%90%AD%E5%BB%BAdart%E6%BA%90%E7%A0%81%E4%B8%80/"},{"categories":["安卓逆向"],"content":"1、dart是一门强类型语言。 2、编译打包的apk里面有两个so文件，libflutter.so是flutter的运行环境，libapp.so是dart编译生成的二进制代码。 ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/:0:0","tags":["Flutter","Dart"],"title":"Flutter逆向之分析dart源码(二)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/"},{"categories":["安卓逆向"],"content":"项目 gen_snapshot，生成二进制文件的核心。 dart_precompiled_runtime，可以模拟出一个runtime执行aot。 关于编译:https://dart.dev/tools/dart-compile dart编译模式，有以下几种: 编译模式 说明 aot-snapshot Compile Dart to an AOT snapshot exe Compile Dart to a self-contained executable jit-snapshot Compile Dart to a JIT snapshot js Compile Dart to JavaScript kernel Compile Dart to a kernel snapshot kernel生成dill文件，其实和源码差不太多，可以理解为对象序列化后的源码文件。 ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/:0:1","tags":["Flutter","Dart"],"title":"Flutter逆向之分析dart源码(二)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/"},{"categories":["安卓逆向"],"content":"dart编译aot的实现 dart.exe compile aot-snapshot C:\\Work\\main.dart 通过这条命令，我们可以将源码文件编译成二进制aot文件，通过procmon进行监视，可以发现，这条命令会调用以下命令: \u003e dart.exe C:\\dart-sdk\\bin\\snapshots\\gen_kernel.dart.snapshot --platform C:\\dart-sdk\\lib\\_internal\\vm_platform_strong_product.dill --aot -Ddart.vm.product=true -o C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\7c46dc67\\kernel.dill --invocation-modes=compile --verbosity=all --sound-null-safety c:\\Work\\main.dart \u003e gen_snapshot.exe --snapshot-kind=app-aot-elf --elf=c:\\work\\main.aot C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\7c46dc67\\kernel.dill 分析上面的命令，可以大概了解到dart先是生成dill代码，再将dill代码通过gen_snapshot.exe转换成aot文件。 事实上，通过procmon监视flutter app的生成，能发现libapp.so文件也是这么生成的: gen_snapshot.exe --deterministic --snapshot_kind=app-aot-elf --elf=app.so --strip app.dill 那么我们要的核心文件生成代码在gen_snapshot这个项目里面，需要看看它是怎么把dill文件转成二进制so文件的。 ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/:0:2","tags":["Flutter","Dart"],"title":"Flutter逆向之分析dart源码(二)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/"},{"categories":["安卓逆向"],"content":"gen_snapshot源码阅读 在调试gen_snapshot源码的过程中发现断点下不下来，分析了一下生成的exe，发现代码是被优化的，很明显不是debug模式。 分析项目的配置文件，就是BUILD.gn那些玩意儿，找到runtime目录下的runtime_args.gni配置文件，修改成如下结果: - dart_debug = false\r+ dart_debug = true\r- dart_debug_optimization_level = \"2\"\r+ dart_debug_optimization_level = \"0\" CreateAndWritePrecompiledSnapshot -\u003e CreateAndWritePrecompiledSnapshot 生成的区段解释: Dart VM 快照 (kDartVmSnapshotData): 代表 isolate 之间共享的 Dart 堆 (heap) 的初始状态。有助于更快地启动 Dart isolate，但不包含任何 isolate 专属的信息。 Dart VM 指令 (kDartVmSnapshotInstructions): 包含 VM 中所有 Dart isolate 之间共享的通用例程的 AOT 指令。这种快照的体积通常非常小，并且大多会包含程序桩 (stub)。 Isolate 快照 (kDartIsolateSnapshotData): 代表 Dart 堆的初始状态，并包含 isolate 专属的信息。 Isolate 指令 (kDartIsolateSnapshotInstructions): 包含由 Dart isolate 执行的 AOT 代码。 核心文件 app_snapshot.h FullSnapshotWriter::WriteVMSnapshot，生成头部 ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/:0:3","tags":["Flutter","Dart"],"title":"Flutter逆向之分析dart源码(二)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/"},{"categories":["安卓逆向"],"content":"参考资料 Flutter机器码生成gen_snapshot - Gityuan博客 | 袁辉辉的技术博客 ","date":"2022-11-06","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/:0:4","tags":["Flutter","Dart"],"title":"Flutter逆向之分析dart源码(二)","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/flutter%E9%80%86%E5%90%91%E4%B9%8B%E5%88%86%E6%9E%90dart%E6%BA%90%E7%A0%81%E4%BA%8C/"},{"categories":["前端"],"content":"TypeScript 总的来说就是javascript太乱，强制在javascript上定义了一种新的语言，最后再转换成js。因此ts本质上还是js。 教程:https://ts.xcatliu.com/ 数据类型 整数:number 字符串:string 一个函数的定义 export function add(x:number,y:number):number{ return x+y; } ","date":"2022-11-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/typescript%E5%AD%A6%E4%B9%A0/:1:0","tags":["TypeScript"],"title":"TypeScript学习","uri":"/posts/%E5%89%8D%E7%AB%AF/typescript%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"稍微记录一下吧: 看雪论坛:https://bbs.pediy.com/ ios逆向:https://iosre.com/ ","date":"2022-11-02","objectID":"/posts/%E6%9D%82%E6%96%87/%E9%80%86%E5%90%91%E7%A4%BE%E5%8C%BA/:0:0","tags":["论坛"],"title":"逆向社区","uri":"/posts/%E6%9D%82%E6%96%87/%E9%80%86%E5%90%91%E7%A4%BE%E5%8C%BA/"},{"categories":["动态调试"],"content":"官网教程: 官方文档:https://frida.re/docs/javascript-api/ 搭建开发环境 下载示例仓库: git clone git://github.com/oleavr/frida-agent-example.git cd frida-agent-example/ npm install 用VS Code打开文件夹，就可以在里面写typescript代码了。 开个控制台执行npm run watch，实时监控，将ts代码转换成js代码。 模块大全 ","date":"2022-11-01","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/frida%E6%95%99%E7%A8%8B/:0:0","tags":["Frida"],"title":"Frida教程","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/frida%E6%95%99%E7%A8%8B/"},{"categories":["动态调试"],"content":"Interceptor 参考资料 FRIDA 使用经验交流分享-Android安全-看雪论坛-安全社区 ","date":"2022-11-01","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/frida%E6%95%99%E7%A8%8B/:1:0","tags":["Frida"],"title":"Frida教程","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/frida%E6%95%99%E7%A8%8B/"},{"categories":["动态调试"],"content":"Triton 项目地址:https://github.com/JonathanSalwan/Triton ","date":"2022-10-18","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:0:0","tags":["符号执行"],"title":"Triton学习记录","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["动态调试"],"content":"Triton库安装 我习惯使用windows 64位开发环境，因此这里使用vcpkg，命令如下: vcpkg.exe integrate install vcpkg.exe install triton:x64-windows-static ","date":"2022-10-18","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["符号执行"],"title":"Triton学习记录","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["动态调试"],"content":"C++例子 https://github.com/JonathanSalwan/Triton/tree/master/src/examples/cpp ","date":"2022-10-18","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["符号执行"],"title":"Triton学习记录","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/triton%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["C++开发"],"content":"vcpkg 微软开源的项目，地址为:https://github.com/microsoft/vcpkg 经常写C++的老铁们就知道使用一个三方库有麻烦，下载源码 -\u003e 配置cmake -\u003e 编译lib。。。 而使用vcpkg就可以做到一键编译lib。 入门教程:https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md ","date":"2022-10-18","objectID":"/posts/c++%E5%BC%80%E5%8F%91/vcpkg%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:0:0","tags":["高级C++","Windows"],"title":"vcpkg使用指南","uri":"/posts/c++%E5%BC%80%E5%8F%91/vcpkg%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["C++开发"],"content":"使用方式 vcpkg install [package name]:x64-windows 例如，安装某个三方库 vcpkg install libevent:x64-windows-static\rvcpkg install libevent:x64-windows-dynamic\rvcpkg install libevent:x86-windows-static\rvcpkg install libevent:x86-windows-dynamic 忘了填啥，使用vcpkg help triplets打印一下。 搜索项目库 vcpkg search xxx ","date":"2022-10-18","objectID":"/posts/c++%E5%BC%80%E5%8F%91/vcpkg%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/:1:0","tags":["高级C++","Windows"],"title":"vcpkg使用指南","uri":"/posts/c++%E5%BC%80%E5%8F%91/vcpkg%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"categories":["动态调试"],"content":"Z3 Z3是微软研究院开发的高性能定理证明器。Z3用于许多应用，如:软件/硬件验证和测试，约束解决，混合系统的分析，安全，生物学(在硅分析)，和几何问题。 官网学习文档:https://microsoft.github.io/z3guide/ 1、在SMT公式中，所有的东西可以看成是一个函数。 2、没有参数的函数实际就是常量。 ","date":"2022-09-26","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/z3%E6%B1%82%E8%A7%A3%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Z3"],"title":"Z3求解初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/z3%E6%B1%82%E8%A7%A3%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"Angr 项目地址:https://github.com/angr/angr ","date":"2022-09-25","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Angr","符号执行"],"title":"Angr符号执行初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"配置Angr pip install angr -i https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-09-25","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Angr","符号执行"],"title":"Angr符号执行初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"使用说明 https://www.bookstack.cn/read/CTF-All-In-One/doc-5.3.1_angr.md 官方文档:https://docs.angr.io/ ","date":"2022-09-25","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Angr","符号执行"],"title":"Angr符号执行初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"CFG生成 有静态分析和动态分析两种，其中静态分析速度要快一点。 import angr p = angr.Project('/bin/true', load_options={'auto_load_libs': False}) #Generate a static CFG cfg = p.analyses.CFGFast() #generate a dynamic CFG cfg = p.analyses.CFGEmulated(keep_state=True) ","date":"2022-09-25","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Angr","符号执行"],"title":"Angr符号执行初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"训练题目 https://github.com/jakespringer/angr_ctf ","date":"2022-09-25","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/:4:0","tags":["Angr","符号执行"],"title":"Angr符号执行初体验","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["动态调试"],"content":"​ Unicorn这个引擎接口比较简单，比较容易上手，但是在实际使用的过程中还是会遇到不少问题的。 1、执行异常指令 例如执行下面的这种指令 FF15 64C24700 call dword ptr ds:[0x47C264] kernel32.GetCurrentThreadId 很明显这是个系统API调用CALL，unicorn无法找到调用的地址，会抛出一个UC_MEM_FETCH_UNMAPPED异常。问题就在于抛出这个异常之后，Esp寄存器发生了偏移，相较于之前偏移了-4。 我们可以尝试猜测一下:由于call指令可以近似分解为push nextInsAddr + jmp callAddr两步，unicorn在执行这条指令的时候很有可能是第一段push执行成功，后面的jmp则执行失败了，因此导致Esp寄存器偏移了-4，同时Eip地址发生错乱，变成了-1。 那么我们在使用unicorn模拟器的时候就要想办法去解决这种问题。 ","date":"2022-09-21","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/unicorn%E7%AC%94%E8%AE%B0/:0:0","tags":["Unicorn"],"title":"Unicorn笔记","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/unicorn%E7%AC%94%E8%AE%B0/"},{"categories":["易语言逆向"],"content":"首先编写一个3 * 3 * 3的三位数组，看看内存布局，发现内存的顺序如下: a [1] [1] [1] ＝ 1\ra [1] [1] [2] ＝ 2\ra [1] [1] [3] ＝ 3\ra [1] [2] [1] ＝ 4\ra [1] [2] [2] ＝ 5\ra [1] [2] [3] ＝ 6\ra [1] [3] [1] ＝ 7\ra [1] [3] [2] ＝ 8\ra [1] [3] [3] ＝ 9\ra [2] [1] [1] ＝ 10\ra [2] [1] [2] ＝ 11\ra [2] [1] [3] ＝ 12\ra [2] [2] [1] ＝ 13\ra [2] [2] [2] ＝ 14\ra [2] [2] [3] ＝ 15\ra [2] [3] [1] ＝ 16\ra [2] [3] [2] ＝ 17\ra [2] [3] [3] ＝ 18\ra [3] [1] [1] ＝ 19\ra [3] [1] [2] ＝ 20\ra [3] [1] [3] ＝ 21\ra [3] [2] [1] ＝ 22\ra [3] [2] [2] ＝ 23\ra [3] [2] [3] ＝ 24\ra [3] [3] [1] ＝ 25\ra [3] [3] [2] ＝ 26\ra [3] [3] [3] ＝ 27 不难理解了，内存索引顺序是按下标从后往前排列的。 假设某个三维数组边界分别为a、b、c（a\u003e1 且 b\u003e1 且 c\u003e1)，空间大小则为a * b * c。 那么下标分别是x、y、z的元素在内存中的位置应该是 xbc + yc + z。 ","date":"2022-09-01","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E7%A0%94%E7%A9%B6/:0:0","tags":["IDA"],"title":"易语言数组研究","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E7%A0%94%E7%A9%B6/"},{"categories":["易语言逆向"],"content":"编写易语言反编译器，需要对易语言的释放内存进行研究，在这里记录一下。 1、收集释放内存的代码类型 第一种，比较常见 004012C8 mov dword ptr ss:[ebp-0x38],eax\r004012CB mov ebx,dword ptr ss:[ebp-0x30]\r004012CE test ebx,ebx\r004012D0 je short 004012DB\r004012D2 push ebx\r004012D3 call 释放内存\r004012D8 add esp,0x4 可以看到从004012CB - 004012D8这里的代码可以理解为无效代码。 第二种，为什么要这么写呢 00401379 mov eax,dword ptr ss:[ebp-0x34]\r0040137C push eax\r0040137D mov ebx,dword ptr ss:[ebp-0x10]\r00401380 test ebx,ebx\r00401382 je short 0040138D\r00401384 push ebx\r00401385 call 释放内存\r0040138A add esp,0x4\r0040138D pop eax\r0040138E mov dword ptr ss:[ebp-0x10],eax ","date":"2022-08-25","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%A0%94%E7%A9%B6/:0:0","tags":["IDA"],"title":"易语言释放内存研究","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%A0%94%E7%A9%B6/"},{"categories":["易语言逆向"],"content":"编写易语言反编译器，需要对易语言的类进行研究，在这里记录一下。 1、易语言的类，只有继承这种关系，且每个类只准继承一个类。 这样的话就不存在什么菱形继承了。。。 2、编写测试用例，类3继承类2，类2继承类1，分别编写它们的构造函数和析构函数。 可以观察到函数调用顺序如下: 类1初始化 -\u003e 类2初始化 -\u003e 类3初始化 -\u003e 类3析构 -\u003e 类2析构 -\u003e 类1析构 继续观察测试用例，可以发现每个类都一定会有一个虚表。其中类的构造函数不会存在于虚表之内。 虚表中的第一个函数一定是析构函数，如果类含有继承，那么多个类的析构函数会被合并到这一个函数中。 虚表中的第二个函数一定是拷贝函数，虚表之后剩下的都是成员函数了。 3、再看类的成员函数调用，会发现函数总是以这种形式调用 push eax\rmov eax,dword ptr ss:[esp]\rmov eax,dword ptr ds:[eax]\rmov eax,dword ptr ds:[eax]\rcall dword ptr ds:[eax+虚表偏移] 很明显，这就是把thiscall转换成了stdcall，类成员函数的第一个参数一定是this指针。写个编译器懒成这样了。。。 4、再观察类的拷贝函数，发现第一条指令总是push eax，第二条指令总是push xxx。 特征码是50 68。 5、虚表命名为vtable好了，虚表指针命名为vfptr ","date":"2022-08-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%9A%84%E7%A0%94%E7%A9%B6/:0:0","tags":["IDA"],"title":"易语言类的研究","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["外贸"],"content":"做外贸的都知道国外邮编数据有多重要。 1、geo公开的一部分国家数据信息，长期保持更新状态，缺点是只有一些常见国家。 http://download.geonames.org/export/zip/ 2、邮编库，详细到城市，有很多小国家的数据: https://www.azpostalcodes.com/ + 国家2个字母缩写 3、邮编库，详细到省份，不错不错: https://postcodebase.com/ 4、国家缩写查询: https://www.17tr.com/tool/code/ ","date":"2022-07-16","objectID":"/posts/%E5%A4%96%E8%B4%B8/%E5%9B%BD%E5%AE%B6%E9%82%AE%E7%BC%96%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/:0:0","tags":["开源"],"title":"国家邮编相关数据","uri":"/posts/%E5%A4%96%E8%B4%B8/%E5%9B%BD%E5%AE%B6%E9%82%AE%E7%BC%96%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/"},{"categories":["Go语言"],"content":"Go语言程序添加图标 1、下载rsrc工具 go get github.com/akavel/rsrc 2、生成程序描述文件ico.manifest \u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?\u003e \u003cassembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"\u003e \u003cassemblyIdentity version=\"1.0.0.0\" processorArchitecture=\"x86\" name=\"controls\" type=\"win32\" \u003e\u003c/assemblyIdentity\u003e \u003cdependency\u003e \u003cdependentAssembly\u003e \u003cassemblyIdentity type=\"win32\" name=\"Microsoft.Windows.Common-Controls\" version=\"6.0.0.0\" processorArchitecture=\"*\" publicKeyToken=\"6595b64144ccf1df\" language=\"*\" \u003e\u003c/assemblyIdentity\u003e \u003c/dependentAssembly\u003e \u003c/dependency\u003e \u003c/assembly\u003e 3、制作syso文件 rsrc.exe -manifest ico.manifest -o rsrc.syso -ico myapp.ico 生成的rsrc.syso放到main.go目录下面就行了，会自动被编译器引用，这样生成出来的程序就有图标了。 ","date":"2022-06-28","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87/:1:0","tags":["Go","ICO"],"title":"Go语言程序添加图标","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%B7%BB%E5%8A%A0%E5%9B%BE%E6%A0%87/"},{"categories":["微信"],"content":"额额 ","date":"2022-06-17","objectID":"/posts/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E9%80%86%E5%90%91%E5%9B%9E%E5%BF%86%E5%BD%95/:0:0","tags":["软件逆向"],"title":"微信逆向","uri":"/posts/%E5%BE%AE%E4%BF%A1/%E5%BE%AE%E4%BF%A1%E9%80%86%E5%90%91%E5%9B%9E%E5%BF%86%E5%BD%95/"},{"categories":["Go语言"],"content":"关于DLL的加载 调用消息框示例 func callMsgBox() { hUser32,_ := syscall.LoadDLL(\"user32.dll\") callMessageBox, _ := hUser32.FindProc(\"MessageBoxW\") text := uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(\"我是内容\"))) title := uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(\"我是标题\"))) callMessageBox.Call(0,text,title,0) } ","date":"2022-06-14","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8windows-api/:0:0","tags":["Go","API"],"title":"Go语言调用Windows Api","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8windows-api/"},{"categories":["网络协议"],"content":"前言 本来想研究OpenVPN如何抓取流量的，可惜没研究出啥成果，备份一下资料而已。 OpenVpn 1、下载对应版本的代码 wget https://swupdate.openvpn.org/community/releases/openvpn-2.4.9.tar.gz 2、安装lzo压缩库，不同的操作系统选择不同的安装命令 sudo apt-get install liblzo2-dev sudo yum install lzo-devel 或者也可以直接通过源码来安装 wget http://www.oberhumer.com/opensource/lzo/download/lzo-2.10.tar.gz tar xf lzo-2.10.tar.gz cd lzo-2.10 ./configure make sudo make install 3、安装libpam yum install pam-devel ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:0:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"生成证书 1、cmd进入OpenVPN/eazy-rsa目录，执行初始化命令，vars里面的内容得修改修改，设置设置目录之类的。 init-config vars clean-all 2、创建CA根证书 build-ca 得到ca.key和ca.crt 3、创建dh证书 build-dh 得到dh2048.pem 4、创建服务端证书 build-key-server server 首先是直接生成一组证书server.key和server.csr，之后利用ca证书给server.csr签名得到server.crt。 5、创建客户端证书，这里注意的是Common Name不能和服务端一样。 build-key client 还是直接生成一组证书client.key和client.csr，之后利用ca证书给client.csr签名得到client.crt Windows开启路由转发 windows默认是没有启用IP转发的，因此需要开启，编辑注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters 将IPEnableRouter值修改为1后，重启操作系统。 ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:1:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"Config配置 服务器的配置如下: #监听的端口\rport 1195\r#TCP还是UDP服务\r;proto tcp\rproto udp\r#tap和tun两种模式\r;dev tap\rdev tun\r#服务器证书\rca ca.crt\rcert server.crt\rkey server.key # This file should be kept secret\r#dh证书\rdh dh2048.pem\r#网段设置\rserver 192.168.233.0 255.255.255.0\r#ip缓存池,不用管\rifconfig-pool-persist ipp.txt\r# If enabled, this directive will configure\r# all clients to redirect their default\r# network gateway through the VPN, causing\r# all IP traffic such as web browsing and\r# and DNS lookups to go through the VPN\r# (The OpenVPN server machine may need to NAT\r# or bridge the TUN/TAP interface to the internet\r# in order for this to work properly).\rpush \"redirect-gateway def1 bypass-dhcp\"\r#DNS服务器\rpush \"dhcp-option DNS 114.114.114.114\"\rpush \"dhcp-option DNS 8.8.8.8\"\r#支持多客户端\rduplicate-cn\r#心跳设置\rkeepalive 10 120\r#加密算法\rcipher none\rpersist-key\rpersist-tun\r#忽略错误日志\rverb 0\r#表示客户端无需证书,根据不同的版本有两种配置语句\rclient-cert-not-required\r#verify-client-cert none\rusername-as-common-name\rscript-security 3\r#开启用户名密码校验,bat脚本返回0则校验通过\rauth-user-pass-verify radiuscheck.bat via-env ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:2:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"运行OpenVPN服务 实际命令行如下，可用于源码调试。 openvpn --config \"server.ovpn\" ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:3:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"安装服务端 ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:4:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"端口转发 查看端口转发 netsh interface portproxy show v4tov4 netsh interface portproxy add v4tov4 listenaddress=10.8.8.1 listenport=139 connectaddress=0.0.0.0 connectport=80 删除端口转发 netsh interface portproxy delete v4tov4 listenaddress=127.0.0.1 listenport=80 ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:5:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"OpenVPN解析 socket.h link_socket_write_udp函数，写入 ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:6:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"参考资料 OpenVpn下载地址:https://github.com/portapps/openvpn-portable/releases OpenVpn官方手册:https://openvpn.net/community-resources/how-to/ Open命令行手册:https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage 维基百科介绍:https://wiki.wireshark.org/OpenVPN https://www.wumingx.com/others/openvpn-win.html https://www.junmajinlong.com/virtual/network/data_flow_about_openvpn/ https://discourse.mitmproxy.org/t/configuration-for-openvpn/1354 https://www.codeproject.com/Articles/5323785/OpenVPN-for-Windows-XP#topic08 https://paper.seebug.org/1648/ ","date":"2022-06-09","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/:7:0","tags":["OpenVPN"],"title":"OpenVPN研究","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/openvpn%E7%A0%94%E7%A9%B6/"},{"categories":["网络协议"],"content":"HTTP协议 首先从最高层，应用层的角度去理解请求: 1、客户端向目标服务端发送请求信息 POST http://api.live.bilibili.com/client/v1/Ip/getInfoNew HTTP/1.1\rHost: api.live.bilibili.com\rUser-Agent: python-requests/2.26.0\rAccept-Encoding: gzip, deflate\rAccept: */*\rConnection: keep-alive\rContent-Length: 8\rpostData 有请求类型，请求地址，协议版本、协议头、请求内容等信息。 2、目标服务端解析请求，返回响应数据至客户端。 HTTP/1.1 200 OK\rCache-Control: no-cache\rConnection: keep-alive\rContent-Length: 85\rContent-Type: text/html\rDate: Wed, 08 Jun 2022 12:53:05 GMT\rExpires: Wed, 08 Jun 2022 12:53:04 GMT\rServer: swoole-http-server\rVary: Accept-Encoding,Origin\rX-Cache-Webcdn: BYPASS from blzone10\r{\"code\":65530,\"msg\":\"invalid request\",\"message\":\"invalid request\",\"data\":\"bad token} ","date":"2022-06-08","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/:1:0","tags":["HTTP"],"title":"Http代理协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/"},{"categories":["网络协议"],"content":"HTTP代理 HTTP代理，其实相较于HTTP服务，多了一层转发而已，发送内容和形式都没有发生变化。 ","date":"2022-06-08","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/:2:0","tags":["HTTP"],"title":"Http代理协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/"},{"categories":["网络协议"],"content":"HTTPS协议 所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。首先从最高层，应用层的角度去理解请求: 1、客户端向目标服务端发送握手请求(Client Hello)，这个请求包含随机数，因此每次都不一样，十六进制如下 16030100ee010000ea0303e13910cc2593f2947644cefaaf028dc7c556be76b5c4c712cc4108681c430a6220a68a2cc1e0dfc2c5061ae656f2de7255424c5fdffbf15cc9caa43e428f08e1e20026c02bc02fc02cc030cca9cca8c009c013c00ac014009c009d002f0035c012000a1301130213030100007b000500050100000000000a000a0008001d001700180019000b00020100000d001a0018080404030807080508060401050106010503060302010203ff0100010000120000002b0009080304030303020301003300260024001d00209a8813b03ca4733ce74c0c327601fe1965a9f6a039d29a4fa96a326a226d705e 前五个字节16 03 01 00 EE为消息头部，解析如下: 第一个字节0x16，表示这是个握手记录。 接下来两个字节03 01，表示版本号为3.1，TLS1.0实际上基于SSL3.1构建。 ……. 如果目标服务器不是ip地址，请求内容中还会包含域名信息，会被目标服务端用来检索对应的证书。 2、目标服务端返回握手请求(Server Hello)，里面包含证书信息 160303007a020000760303d8e7d43f3932ca954321c2ba88e02b9efb02c626e72ba135c714254d5d8f3eb320a68a2cc1e0dfc2c5061ae656f2de7255424c5fdffbf15cc9caa43e428f08e1e2130100002e002b0002030400330024001d0020d5cff788e538fdb7747afa79abda55f32f799cfc98a91f5fae2ab4d526f824571403030001011703030017246dd8a5defd4178ef6d3e5d14159695a809772ceb6a7317030306214bbdfaf53a078c10144e20d8a22f592e908ccd8caaecc1208295cac53e88b881d2a1e21bc5e3d3a16b45610e24cc6e108cae7e435dd02fc9b91c8ff20de0b745daacafc70e4edf8e9d1e1ac48c077260b3d1435517df302f396ddca3580ce81d38feaecff2264b562cf90894ace99c65d0085bea138e09f0a391a22b1b0cc126dbb0170f8bf906fe483fb1ee0d14d9fcc1d1ca64cc671053ab6bbaadf398a0fc2870ffd50330be7cba881bd20c8d8a411fc99a8f7a4f03257c9f3ca029516da9ad2b255923f1eacd1fd8e449c1ba95efc398b50a40679e20bc76e6d46297a642bf982617139882e75155c4029c0341062740430b2089e642a03d66f334ced17d6f0faecd00cd0df2da43185da5f2352ae28b2f43f7fcffcef6b526fd9837ec16614fd5b000873c963d693c47404160e00f0a9640a135a9f2047a4ea4cac62cc81d9d9ddd7f0082fd8790c273d51d54eefe497048e8cc68f84f08c2263a6ca308d3d3df50f3e3b7e6cd2434789a02b161993bb86c238c0da9a64f7a2e8d1ad292db9134c1c01847f322e04f9629abfcf09b3a5843ff0d867b148c0c250d60932990432abd1732d213b85dffa63b11a5d68cc3c805118908068ea57646f57e7e51aeb63b52f17be3943ca1fba465615838d19d6b010a6239607fc7fa52d6013efcdc30c2eb40d30f8da7874bbef946bf3cdd7f945957b64114d55f47f92bbe25ab17059ef357d928d751028b05fd47ae97d8f00104690079dd5d1db8a2147b0840e314e1cb7af641411cd561066871e098e1707c7a99c4fe54d1a2720cc0cdf26efe789f4c76c740c19b4ef58658ba88377ea34b17d496b4f74b2db1fff50dc928272318f9ed9a1216201eea6eac7cf5ab6899800032e21286f15ceed91845f07c641f043e30b1d2a7092e15059222b72981362ec3140681749f810e92615a506fa8a3ac365fee25f6537720d35c949748c9869ecd2cd5d12b8a44f7b8ff0d44060ebd7ee5d4d9b83c4ba522ae99f02421a3cd2e684ce635ee50a3f84b41202b0f2c23736ead7da68afe67ad2592f80a2fe02fb9912d60235acf62af8c6d0957804c30b4c4a9283be89975fc336613235fe3b1eca457d23c3ee119301d6074595af412a3a70ab1043e75d823a9c014a7a674292689c93dd9bdb3e2a5ef79f31cd894a5c634971f6bd47a9cf253a85753fc544b25093728fb0e4072493c25da076400ebd1511ce14b8c9f69926712d73aa5e4c5db6cbcecb329c64116ae4f5b2dc85a89083d4d6f8704aa0934870461fdfb1281f78964251b97cfb559b2ebda6b42c94e25fedcfa34fb22df30a4806aa3a68c5db17314257a1e84cb6a81798a91f144c4862859e561cdb3f2847d7149cfc9db5a7bc8abcf477128cd3acfee4d4b9b179f3625120598695507b59e724032a2826a7b26901973942185b3416157287df68684e79952371a7b780528c5daa68c7f8b86aca311d35084da9be362dd511f931d2902d6bdf73cf3647690976b20193148a42eb2e199999422540fd09cc4f89bb571c64a7cfe3257657850b1904b476aee2b5c74b86ec88c21a37c629d0badf649990682fef26bcbf4af0592529bb5b51273cf4d760993efb1daea6328915f49c7324e7025a6807191c21dd21465d5c1f6d36c73283d543e61a2df2cf08a35c4e835113a77d6fd7ac4f0727970ed5a5aa69bb17f163a3f36b36ba4eade4b9a619129985d9f362d5fe938b1f40f7144ad0210e1401a8c106fa1e628386f968951e71ce376d56b98863c0a92b097edefed29c9409827c4143fa6573865179e45e4f8294ce1792d7544adc2a33dc3b78a29b96d5eb49568b2c08c78b0cdecaf1820445ccc62c9be7a86341ad089babb3aaa515025bc69a765e5678a7cda3650b9ca9c7f7b51313e5b6d778b1eb85bc7b34a25c0407b716e3a18e1084f806dbbf2d6ff7cdc4252667981c40014a76c0e3b257ed4e56449926aa7727cb904dcecffe3bcb8ffbf14353cb3c67bcc0b4195cc25d65874a51df5a78a622418b13b453fcbd","date":"2022-06-08","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/:3:0","tags":["HTTP"],"title":"Http代理协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/"},{"categories":["网络协议"],"content":"HTTPS代理 从最高层，应用层的角度去理解HTTPS代理请求: 1、客户端首先发送CONNECT请求至代理服务端(后面跟着两行换行符)。 CONNECT api.live.bilibili.com:443 HTTP/1.0 2、代理服务端返回OK信息(后面也跟着两行换行符) HTTP/1.0 200 OK 3、客户端向代理服务端发送Client Hello消息，代理服务端向客户端返回Server Hello消息(此时可以通过自签名来伪造证书)。 4、之后的逻辑其实和HTTP一样了，只不过数据全部被加密了。 ","date":"2022-06-08","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/:4:0","tags":["HTTP"],"title":"Http代理协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/http%E5%8D%8F%E8%AE%AE/"},{"categories":["书籍阅读"],"content":"​ 从初中的时候听到了这一名著，但是一直没有去完整地看过。最近买了本Kindle，打算好好看一看，做个笔记。 首先书籍研究了物品的价值，并给出了在理论中的定义，大概总结如下吧: 1、我们日常生活中所说的价值是使用价值，例如空气，具有能够用来呼吸的价值。 2、在经济世界中物品的价值一般指的是劳动价值，例如金刚石需要工人通过挖矿来获取，金刚石则具有劳动价值。 由上可以进一步得出以下观点: 1、对于交通运输来说，汽车的使用价值大于自行车的使用价值，汽车的劳动价值也大于自行车的劳动价值。对于呼吸生存来说，空气的使用价值趋近于无限高，但是由于空气太容易被获取，劳动价值却趋近于无限低。 由此可得，对于物品来说，使用价值和劳动价值之间并没有绝对的关系，只能说大多数情况下，物品的使用价值和劳动价值呈正相关吧? ","date":"2022-06-06","objectID":"/posts/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/%E8%B5%84%E6%9C%AC%E8%AE%BA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记"],"title":"资本论阅读笔记","uri":"/posts/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/%E8%B5%84%E6%9C%AC%E8%AE%BA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["爬虫"],"content":"解析Html 1、获取第一个元素 document.querySelector(\"p\"); document.querySelector(\"body\"); 2、获取第一个类为example的元素 document.querySelector(\".example\"); 3、选中 data-foo-bar 属性等于 someval 的元素 document.querySelectorAll('[data-foo-bar=\"someval\"]'); ","date":"2022-05-25","objectID":"/posts/%E7%88%AC%E8%99%AB/html%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/:0:0","tags":["html"],"title":"html查询语法","uri":"/posts/%E7%88%AC%E8%99%AB/html%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/"},{"categories":["Go语言"],"content":"项目地址:https://github.com/lxn/walk 示例代码:https://github.com/lxn/walk/tree/master/examples ","date":"2022-05-23","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8walk%E7%95%8C%E9%9D%A2%E5%BA%93/:0:0","tags":["Go","GUI","Walk"],"title":"Go语言使用Walk界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8walk%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"糟糕的布局 Walk只支持几种固定的布局方式，例如Hbox和VBox，用户很难去定义控件之间的位置关系。 ","date":"2022-05-23","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8walk%E7%95%8C%E9%9D%A2%E5%BA%93/:1:0","tags":["Go","GUI","Walk"],"title":"Go语言使用Walk界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8walk%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"项目地址:https://github.com/fyne-io/fyne 示例代码:https://github.com/fyne-io/fyne/blob/master/cmd/fyne_demo/main.go ","date":"2022-05-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/:0:0","tags":["Go","GUI","Fyne"],"title":"Go语言使用Fyne界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"Fyne不支持中文字符 一上来就遇到坑，带有中文的控件无法正常显示，得人工设置字体，参考这篇文章解决: https://github.com/fyne-io/fyne/issues/2660 ","date":"2022-05-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/:1:0","tags":["Go","GUI","Fyne"],"title":"Go语言使用Fyne界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"Fyne控件大全 单选框列表，widget.NewRadioGroup 选择框列表，widget.NewCheckGroup 列表框，widget.NewList和widget.NewListWithData 组合框，widget.NewSelect ","date":"2022-05-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/:2:0","tags":["Go","GUI","Fyne"],"title":"Go语言使用Fyne界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"关于主菜单的Quit选项 fyne为了兼容mac os，设定主菜单默认有quit这一选项，但是这对多语言程序就很不友好，菜单选项语言不一致看起来非常别扭。 有人提出了解决方案: https://github.com/fyne-io/fyne/pull/1982 大概意思就是给菜单加个IsQuit标记吧，代码如下： func (this *FyneApp)makeMainMenu()*fyne.MainMenu { quitAction := fyne.NewMenuItem(\"退出\", func() { this.app.Quit() }) quitAction.IsQuit = true menu_About := fyne.NewMenu(\"程序\", quitAction) mainMenu := fyne.NewMainMenu(menu_About) return mainMenu } ","date":"2022-05-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/:3:0","tags":["Go","GUI","Fyne"],"title":"Go语言使用Fyne界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"Fyne致命缺陷 1、Fyne组合框项目过多的时候，界面会卡死。 Fyne中的Select这一控件，当其中的选项较多的时候(上千个)，界面就卡死了，这是难以接受的。 2、Fyne为了适配各个平台，做出了很多功能上的牺牲，例如你无法在相对布局中定义控件的最小长度，这样的布局很难满足界面的设计需求。 3、Fyne程序无法在Windows Server上跑起来，因为服务器显卡驱动永远是OpenGL 1.1且无法升级，而Fyne使用的是OpenGL 2.0以上。 ","date":"2022-05-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/:4:0","tags":["Go","GUI","Fyne"],"title":"Go语言使用Fyne界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8fyne%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["反编译"],"content":"项目地址 https://github.com/avast/retdec ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:1:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"编译前置条件 该项目引用了不少github远程库，你得有比较好的网络环境，不然国内网络你懂的。我自己也是用SSR + SSTap才在visual studio中成功编译出了该项目。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:2:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"编译时遇到的坑 我在编译最新版的retdec-decompiler的时候，发现编译authenticode这个项目会出错，而且错误莫名奇妙，如下所示: 在 \u003c未知\u003e“null”后添加了“14455024”字节填充 后来发现是项目附加包含目录中没有OpenSSL。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:3:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"capstone2llvmir 是retdec反编译器的核心库，负责将二进制指令转换为llvmir。 核心函数是Capstone2LlvmIrTranslator::translate，调试了一下发现原理没那么复杂，稍微懂点反汇编和LLVM基础应该都能理解。 首先基于Capstone反汇编器将指令解析出来，之后基于LLVM库将这些PUSH,CALL指令转换成等价的LLVM基本指令。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:4:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"bin2llvmir 从名字可以猜到，在capstone2llvmir的基础上，将二进制文件转换llvmir。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:5:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"retdec-decompiler 反编译器exe示例程序。 1、核心函数就一个retdec::decompile，首先是调用initializeLlvmPasses初始化Pass，这里要注意的是，项目中的PASS是以静态模板类的方式注册的，例如下面这种: static RegisterPass\u003cSyscallFixer\u003e X( \"retdec-syscalls\", \"Syscalls optimization\", false, // Only looks at CFG false // Analysis Pass ); static RegisterPass\u003cLlvmIrWriter\u003e X( \"retdec-write-ll\", \"Generate the current LLVM IR\", false, // Only looks at CFG false // Analysis Pass ); //........ retdec注册的pass按照decompiler-config.json配置文件中的顺序进行添加，一共有以下: 类 pass 作用 ProviderInitialization retdec-provider-init 初始化信息 Decoder retdec-decoder 将二进制解码成LLVM IR X86AddressSpacesPass retdec-x86-addr-spaces 针对x86进行地址优化 X87FpuAnalysis retdec-x87-fpu Fpu寄存器优化 MainDetection retdec-main-detection main函数检测 IdiomsLibgcc retdec-idioms-libgcc Idioms retdec-idioms InstructionOptimizer retdec-inst-opt 指令优化，这个pass会多次调用 CondBranchOpt retdec-cond-branch-opt 条件跳转优化 SyscallFixer retdec-syscalls 优化syscall StackAnalysis retdec-stack 堆栈分析 ConstantsAnalysis retdec-constants 常量分析 ParamReturn retdec-param-return InstructionRdaOptimizer retdec-inst-opt-rda SimpleTypesAnalysis retdec-simple-types 简单的数据类型分析 DsmWriter retdec-write-dsm AsmInstructionRemover retdec-remove-asm-instrs ClassHierarchyAnalysis retdec-class-hierarchy SelectFunctions retdec-select-fncs UnreachableFuncs retdec-unreachable-funcs RegisterLocalization retdec-register-localization ValueProtect retdec-value-protect 变量保护，防止过度优化 StackPointerOpsRemove retdec-stack-ptr-op-remove 堆栈操作优化 PhiRemover retdec-remove-phi LlvmIrWriter retdec-write-ll 生成LLVM IR BitcodeWriter retdec-write-bc 生成bitcode信息 LlvmIr2Hll retdec-llvmir2hll ConfigWriter retdec-write-config 生成配置信息 DumpModule retdec-dump-module LLVMPASS分析 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:6:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"retdec-provider-init 程序首先执行这个pass，主要用来初始化变量，没啥好说的。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:7:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"retdec-decoder 这个是比较关键的的pass，将二进制中的每条指令全部解码转成LLVM IR。 Decoder::decode函数，一边翻译地址一边确定函数范围。 Decoder::initEnvironmentAsm2LlvmMapping函数，这个初始化函数是为了在转换出的LLVMIR里添加和原始ASM有关的元数据，方便后面解析LLVMIR。 例如指令mov ebx,0x6;call 0x00401004转换成了下面的LLVMIR: ; 0x40100f\rstore volatile i64 4198415, i64* @_asm_program_counter\rstore i32 6, i32* @ebx\r; 0x401014\rstore volatile i64 4198420, i64* @_asm_program_counter\r%5 = load i32, i32* @esp\r%6 = sub i32 %5, 4\r%7 = inttoptr i32 %6 to i32*\rstore i32 4198425, i32* %7\rstore i32 %6, i32* @esp\rcall void @__pseudo_call(i32 4198404)\r%8 = call i32 @sub_401004()\rstore i32 %8, i32* @eax Decoder::finalizePseudoCalls，处理pseudo_call pass是通过Config参数中的isSelectedDecodeOnly()函数来决定是反编译函数还是反编译整个bin的，通过遍历所有的跳转来得到可行路径，将decoder_debug.h中的变量debug_enabled设置为true，则会打印出日志。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:8:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"ParamReturn ParamReturn::collectExtraData函数尝试从config中采集函数的声明信息。 ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:9:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"LlvmIr2Hll 将LLVMIR转换为源码。 basic、simple、c、strict、dot、optim、pessim、readable ","date":"2022-04-25","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/:10:0","tags":["RetDec"],"title":"RetDec反编译器学习","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/retdec%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["Go语言"],"content":"Go语言使用QT界面库 Go语言要使用QT库的话，装起来也是比较麻烦 项目地址:https://github.com/therecipe/qt 文档地址:https://github.com/therecipe/examples 1、首先需要安装QT库，根据文档介绍来看，目前项目使用的版本是5.13.0，推荐保持一致，不然可能会出问题。 https://download.qt.io/archive/qt/5.13/5.13.0 安装的时候需要参考issue:https://github.com/therecipe/qt/issues/939，也就是在安装选项中需要选择Qt Script (Deprecated)这一选项，不然后面会出错。 2、下载完成后，安装Mingw64位版本，对应编译出来的64位Go语言程序。 3、将Go语言bin目录添加到path环境变量，在cmd中敲一下go version，看看能不能用就是了。 4、安装Go语言版本的QT库，命令如下，可能会执行比较久的时间。 go get -u -v github.com/therecipe/qt/cmd/qtsetup go get -u -v github.com/therecipe/qt/cmd/... 5、配置好环境变量 SET PATH=%PATH%;%GOPATH%\\bin; REM 配置Qt目录和Qt版本 SET QT_DIR=D:\\Qt\\Qt5.13.0 SET QT_API=5.13.0 SET QT_VERSION_MAJOR=5.13.0 REM 编译32位程序用386 SET GOARCH=amd64 REM 默认使用Mingw编译，使用MSVC编译的话开启下面的选项，qtsetup可以运行，但是后面qtdeploy会报cgo相关错误 REM SET QT_MSVC=true REM SET PATH=%PATH%;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build; REM call vcvarsall.bat amd64_x86 qtsetup 6、编译工程的时候，使用以下命令行 qtdeploy build ","date":"2022-04-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8qt%E7%95%8C%E9%9D%A2%E5%BA%93/:1:0","tags":["Go","GUI","QT"],"title":"Go语言使用QT界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8qt%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"有的时候编译工程不通过 使用qtdeploy命令编译工程，有的时候会失败。 这个时候可以试试先运行qmoc，再运行qtdeploy，玄学。 ","date":"2022-04-05","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8qt%E7%95%8C%E9%9D%A2%E5%BA%93/:2:0","tags":["Go","GUI","QT"],"title":"Go语言使用QT界面库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8qt%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":["Go语言"],"content":"Go语言编写加密算法 ","date":"2022-03-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/:0:0","tags":["Go"],"title":"Go语言编写加密算法","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"categories":["C++开发"],"content":"关于调用任意函数 为了调用任意函数，我首先写了这个一个简单的代码: int __declspec(naked) executeStdCall(LPVOID func, int argSize, int* argsBuffer) { __asm { mov eax, dword ptr[esp + 0x4]; mov esi, dword ptr[esp + 0x8]; mov ecx, dword ptr[esp + 0xC]; lea ecx, dword ptr[ecx + esi * 0x4 - 0x4]; label_loopPush : push dword ptr[ecx]; dec esi; sub ecx, 0x4; test esi, esi; jnz label_loopPush; call eax; ret; } } void __stdcall MyStdFunction(int a, std::string b) { printf(\"call stdcall:%d,%s\\n\", a, b.c_str()); } int getArgsCount(unsigned char* retAddress) { unsigned short addEspOpCode = *(unsigned short*)\u0026retAddress[0]; if (addEspOpCode == 0xC483) { return retAddress[2] / 4; } ; //先不管 return 0; } int __declspec(noinline) ExecuteStdCall(LPVOID pFunc, ...) { unsigned char* retAddress = (unsigned char*)_ReturnAddress(); int argCount = getArgsCount(retAddress); if (argCount \u003c= 1) { return 0; } va_list args; va_start(args, pFunc); int* argsStart = \u0026va_arg(args, int); va_end(args); return executeStdCall(pFunc, argCount - 1, argsStart); } int main() { std::string args = \"123\"; ExecuteStdCall(MyStdFunction, 3, args); } 经过验证发现，std::string对象被释放了两次，这证明框架是存在问题的。 ","date":"2022-03-10","objectID":"/posts/c++%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8E%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%87%BD%E6%95%B0/:0:0","tags":["AnyCall"],"title":"关于调用任意函数","uri":"/posts/c++%E5%BC%80%E5%8F%91/%E5%85%B3%E4%BA%8E%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%87%BD%E6%95%B0/"},{"categories":["Go语言"],"content":"Go语言注意事项 1、尽量避免使用init函数 init函数虽好，但随着项目代码的增加，这些init会成为隐患，满地的init函数，你根本理不清变量之间的关系。 如果非要使用，确保init函数里面只用来初始化包内的变量，这些变量不会被其它包所调用。 2、goland调试出问题，可能是dlv版本太低导致的，更换最新的dlv.exe。 ","date":"2022-02-20","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/:0:0","tags":["Go"],"title":"Go语言注意i事项","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":["动态调试"],"content":"dump某一块内存 我们在使用调试器的时候，经常想要dump出某一块内存数据，这时候可以使用savedata命令，示例如下 savedata \"D:\\1.bin\",0x401000,0x2A0 有三个参数，分别表示dump文件的保存地址，内存块起始地址，内存块大小。 ","date":"2022-02-19","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E5%91%BD%E4%BB%A4/:1:0","tags":["x64Dbg"],"title":"x64Dbg常用快捷键和命令","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E5%91%BD%E4%BB%A4/"},{"categories":["机器学习"],"content":"机器学习资料 GitHub:https://microsoft.github.io/ML-For-Beginners/#/ BiliBili:https://www.bilibili.com/video/BV164411b7dx ","date":"2022-02-16","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/:1:0","tags":["笔记"],"title":"机器学习入门","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"categories":["项目管理"],"content":"项目管理其实也包含着对人员的管理，那么说面试也就是管理人员的第一步了。 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"考察Windows逆向的基础 Windows下的调用约定 cdecl:C和C++程序的缺省调用方式，参数堆栈由调用者清除，即外平衡。\rstdcall:通常是Win32 API,堆栈是在函数内部平衡堆栈。\rfastcall: 先用ecx,edx传参，不够就使用stdcall模式。 调试器中的断点类型和原理 CC断点:置指令为CC，使得程序触发异常，之后调试器接管异常。\r内存断点:利用Page读写保护机制，使得程序触发异常，之后调试器接管异常。\r硬件断点:设置DR0-DR7调试寄存器，使得程序触发异常。 IDA里面的usercall，userpurge了解吗，讲解一下。 usercall = stdcall + 自定义寄存器 userpurge = cdecl + 自定义寄存器 讲解一下Hook有哪几种方式 有使用过HOOK库吗?例如Detours，Detours库中如果要hook的函数是一个类的成员函数，要如何处理? 禁止程序多开一般会使用哪个Windows Api CreateMutexA 进程之间通讯有哪几种方式 DLL劫持有实现过吗?DLL能够劫持成功的原因是什么?常见被用来劫持的DLL模块有哪些? 有使用过哪些反汇编库? 序列化和反序列化有听说过吗?原理是什么? 你能想到的，常见的反调试的方法有哪些? vmp有了解过吗? ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"考察对IDA/C++逆向的掌握程度 C语言当中的switch-case指令，汇编代码是怎么实现的? RTTI有听说过吗?原理是什么? try catch异常机制实现的原理是什么？如何还原其代码? 常见的加密算法了解程度怎么样?分析程序时遇到这些算法一般会怎么还原呢? ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:2:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"考察对C++/Python/Go语言的掌握程度 vector resize和reserve的区别 vector内存空间布局是什么样的 struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; map内存空间布局是什么样的 struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; 如何判断结构体是否相等？ 堆和栈的区别? C++在写代码的时候，如何限制堆和栈的对象空间分配?具体来说，一个类，我想让它只能在堆上分配，而不能在栈上分配，或者让它只能在栈上分配，不能在堆上分配。 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:3:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"Go语言 有接触过Go语言吗?Go语言是静态语言还是动态语言 是静态语言 Go语言里的map，遍历的顺序是固定的还是随机的呢 是随机的 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:4:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"易语言 有了解过易语言吗? 易语言中如果有一个字节集数组，它的内存布局大概是什么样的? ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:5:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"VB语言 大致讲讲遇到VB语言的程序是一般是怎样进行分析的 Native编译、PCode编译。 在VB的基本数据类型中，有一种变体类型(VARIENT)可以表示任何类型的变量，能讲解一下它的一些原理吗? VB中的数组SAFEARRAY有了解过吗?大概讲讲。 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:6:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"考察对协议的掌握程度 代理和反向代理有听说过吗？描述一下。 http和tcp之间的关系是怎么样的？ 使用过哪些抓包工具?它们抓包的原理是什么? ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:7:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["项目管理"],"content":"可选部分 根据工作经历，询问在之前公司工作的内容以及项目 ","date":"2022-02-05","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/:8:0","tags":["面试"],"title":"初级逆向面试题","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["C++开发"],"content":"问题记录 情景描述:项目A引用了静态库项目B，在Debug模式下，静态库项目B使用MT进行编译，项目A也使用MT进行编译，结果无法完成编译。 解决方案:去掉项目A中预处理器中的_DEBUG宏。 ","date":"2022-01-30","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E8%BF%90%E8%A1%8C%E5%BA%93/:1:0","tags":["高级C++"],"title":"C++运行库","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E8%BF%90%E8%A1%8C%E5%BA%93/"},{"categories":["Linux"],"content":"ubuntu替换apt源 有一些主机使用apt get命令会出现各种问题，那么很有可能是apt源有问题。 可以试试替换阿里云的软件源。 1、修改/etc/apt/sources.list，修改为以下内容 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\rdeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\rdeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse 2、执行 apt-get update -y apt-get upgrade -y 3、如果更新出现下面这种问题 The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 3B4FE6ACC0B21F32 那么执行以下命令，命令中的 公钥编码就是上述问题后面的PUBKEY了。 apt-key adv --keyserver keyserver.ubuntu.com --recv-keys '公钥编码' 完成后，重新执行步骤2。 ","date":"2022-01-23","objectID":"/posts/linux/ubuntu%E6%9B%BF%E6%8D%A2apt%E6%BA%90/:1:0","tags":["vnc"],"title":"ubuntu替换apt源","uri":"/posts/linux/ubuntu%E6%9B%BF%E6%8D%A2apt%E6%BA%90/"},{"categories":["Linux"],"content":"ubuntu开启远程桌面可视化 首先要让系统具备可视化桌面的能力。 ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:1:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["Linux"],"content":"安装X-Window X-Windows是一款桌面可视化系统。 执行以下命令 sudo apt-get install xserver-xorg sudo apt-get install x-window-system-core sudo apt-get install ubuntu-desktop sudo dpkg-reconfigure xserver-xorg sudo apt-get install gnome-core sudo apt-get install gdm3 xscreensaver sudo apt-get install ttf-arphic* ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:2:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["Linux"],"content":"安装VNC SERVER 关闭VNC SERVER vncserver -kill :1 ","date":"2022-01-22","objectID":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/:3:0","tags":["vncs"],"title":"ubuntu开启远程桌面可视化","uri":"/posts/linux/ubuntu%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"categories":["Go语言"],"content":"时间戳转换为时间 秒级别转换 timeStamp := 1642429952 timeStr := time.Unix(int64(timeStamp),0).Format(time.RFC3339) fmt.Println(timeStr) 毫秒级别转换 timeStamp := 1642430127727 timeStr := time.UnixMilli(int64(timeStamp)).Format(time.RFC3339) fmt.Println(timeStr) ","date":"2022-01-17","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/:1:0","tags":["Go","时间"],"title":"Go语言常用时间转换","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"},{"categories":["Go语言"],"content":"时间转换为时间戳 秒级别转换 timeStamp := 1642429952 timeStr := time.Unix(int64(timeStamp),0) fmt.Println(timeStr.Unix()) 毫秒级别转换 timeStamp := 1642430127727 timeStr := time.UnixMilli(int64(timeStamp)) fmt.Println(timeStr.UnixMilli()) ","date":"2022-01-17","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/:2:0","tags":["Go","时间"],"title":"Go语言常用时间转换","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"},{"categories":["Go语言"],"content":"Go语言加载时间错误 当Go语言调用了时区相关的代码时，生产环境没啥问题，但在缺乏Go环境的Windows机器上可能就会出错，例如下面这句代码 var err error time.Local, err = time.LoadLocation(\"Asia/Shanghai\") if err != nil{ log.Panicln(err) } 解决方案如下: 1、下载zoneinfo.zip文件，https://github.com/golang/go/blob/master/lib/time/zoneinfo.zip 2、配置环境变量ZONEINFO，变量值为zoneinfo.zip的绝对路径。 ","date":"2022-01-17","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/:3:0","tags":["Go","时间"],"title":"Go语言常用时间转换","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"},{"categories":["Go语言"],"content":"参考资料 https://github.com/ArtalkJS/ArtalkGo/issues/35 ","date":"2022-01-17","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/:4:0","tags":["Go","时间"],"title":"Go语言常用时间转换","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"},{"categories":["Go语言"],"content":"Sqlite3数据库 项目地址: https://github.com/mattn/go-sqlite3 ","date":"2022-01-16","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Csqlite3%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Go","Sqlite3"],"title":"Go语言操作sqlite3数据库","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9Csqlite3%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["浏览器框架"],"content":"Cef浏览器框架 1、Chromium不支持需要身份验证的SOCK5代理。 话说我试了几个小时，搜遍全网的资料，最后才得出这么一个结论😭 https://bugs.chromium.org/p/chromium/issues/detail?id=256785 ","date":"2022-01-09","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/:0:0","tags":["CEF"],"title":"CEF浏览器框架","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/"},{"categories":["浏览器框架"],"content":"浏览器命令行设置 1、启动媒体流 //主要是配置开启Media的命令参数，此配置可以允许摄像头打开摄像 settings.CefCommandLineArgs.Add(\"enable-media-stream\", \"1\"); 2、忽略https证书错误 settings.CefCommandLineArgs.Add(\"--ignore-certificate-errors\", \"1\"); 3、设置全局的代理 settings.CefCommandLineArgs.Add(\"proxy-server\", \"127.0.0.1:1080\"); ","date":"2022-01-09","objectID":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/:1:0","tags":["CEF"],"title":"CEF浏览器框架","uri":"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/cef%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%86%E6%9E%B6/"},{"categories":["后端开发"],"content":"paypal开通支付 paypal是国外的一套支付服务系统，基于web来实现。 官方文档:https://developer.paypal.com/docs/ 代码样例:https://demo.paypal.com/us/demo/code_samples 官方文档点进去之后，主页有三种平台文档: 1、For Business:中小型企业解决方案。 2、For Marketplaces and Platforms:大型销售平台? 3、For Enterprise:大型企业支付解决方案。 按我的猜测，应该是规模和等级依次增加吧，这样的话我就选择1，我就想搭建个小型的收费平台而已。 封装好的SDK:https://github.com/go-pay/gopay 新手教程:https://developer.paypal.com/docs/business/get-started/ 1、paypal提供了一个沙盒平台，开发人员可以在上面进行模拟整套支付流程。 首先需要创建一个App，在创建App 页面点击创建App按钮即可。 我们会得到一个沙盒APP凭证，里面包含 Account: xxx@business.example.com\rClient-ID: xxxxxx\rSecret: xxxxx 这个凭证可以通过官方的一个接口，转换成一个Token凭证，即 Client-ID + Secret =\u003e Token，通过这个Token我们可以去访问创建订单、更新订单、捕获订单等其它API，Token存在一个有效期，如果过期了重新登录即可。 paypal默认还会给我们生成商户和用户两个虚拟账户，在https://www.sandbox.paypal.com上登录能查看到付款和收款情况。 2、创建订单 懒得写了。 ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:0:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"总结大致流程如下: 1、服务器使用后台的Client-ID和Secret去登录paypal，获取访问paypal接口的权限。 2、服务器提供接口server_CreateOrder，用于创建订单。 3、客户端传入商品信息至服务器接口server_CreateOrder。 4、服务器接口server_CreateOrder收到订单后，调用paypal API，接口是paypal_CreateOrder，在这里传入商品的价格、订单的设定 (是否要显示收获地址等…)、以及用户完成订单后的重定向地址，最终得到订单的付费URL地址，再返回给客户端。 5、客户端得到付费的URL地址，通过浏览器访问并付费，付费成功后调用服务器给的重定向地址(可以算是接口)，通知服务器我已经付费完成了。 6、在此时，客户端的付费其实并未被paypal认可，只有服务端收到客户端的通知后，去调用paypal_CaptureOrder函数，捕获住订单，paypal才会承认客户已经付费，服务端此时检查订单的状态是否已完成，返回一些信息给客户端即可。 7、服务端在paypal后台已经设定好了webhook地址，当整个订单完成时候，paypal会发送消息通知服务端paypal的webhook接口，服务端此时确定通过付费，进行一系列操作。 ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:1:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"Paypal安全 https://developer.paypal.com/docs/api/info-security-guidelines/ ","date":"2021-12-31","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/:2:0","tags":["paypal"],"title":"paypal开通支付","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/paypal%E5%BC%80%E9%80%9A%E6%94%AF%E4%BB%98/"},{"categories":["后端开发"],"content":"域名解析 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:0:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"域名起源 一开始，大家都使用IP地址互相访问，但是这样不方便记忆，域名因此出现了。我们访问www.baidu.com的时候，首先会请求DNS服务器，DNS上面存储着A记录，大概可以理解成这样: www.baidu.com -\u003e 14.215.177.39\rwww.google.com -\u003e 74.86.151.167 有了A记录，我们就能根据域名查询到IP地址。 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:1:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"CNAME CNAME又称别名记录，相当于给A记录的域名再起个小名，相当于域名的域名? www.test.com -\u003e www.baidu.com -\u003e 14.215.177.39 A - 将域名指向一个IPV4地址\rCNAME - 将域名指向另外一个域名\rAAAA - 将域名指向一个IPV6地址\rNS - 将子域名指向其它DNS服务器解析\rMX - 将域名指向邮件服务器地址 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:2:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["后端开发"],"content":"NS 解析服务器记录。用来表明由哪台服务器对该域名进行解析。这里的NS记录只对子域名生效。例如用户希望由12.34.56.78这台服务器解析news.mydomain.com，则需要设置news.mydomain.com的NS记录。 NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。 ","date":"2021-12-29","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/:3:0","tags":["DNS"],"title":"域名解析","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"},{"categories":["Go语言"],"content":"Go语言编写DLL 要编写DLL，要用到CGO相关的东西，CGO是基于Mingw编译器的。 编写32位DLL需要安装Mingw，编写64位DLL则安装Mingw-64，安装后将编译器添加到环境变量中即完成了cgo配置。 测试代码如下 package main import \"C\" import( \"fmt\" ) //export Test func Test(){ fmt.Println(\"hello\") } func main(){ } 关键点如下: 1、还是必须要有package main和main函数。 2、导出的函数前面用//export + 函数名声明，表示需要导出该函数 3、引出包import \"C\" 生成dll文件 go build -buildmode=c-shared -o test.dll main.go ","date":"2021-12-27","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99dll/:0:0","tags":["Go","DLL"],"title":"Go语言编写DLL","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99dll/"},{"categories":["Go语言"],"content":"界面库介绍 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:0:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"1、fyne(16k收藏) 项目地址:https://github.com/fyne-io/fyne 自写的的界面库，语法和qt那种一样，体积较大，编译一个demo也要20MB。 优点:跨平台，代码维护性好。 缺点:体积较大、自写库需要时间学习。 刚刚接触可能会不太适应，需要一定的学习成本。这个项目可能是比较不错的小型GUI解决方案了，就是千万别拿来写复杂项目。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:1:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"2、webview(10k收藏) 项目地址:https://github.com/webview/webview 优点:基于webkit组件，体积较小。 缺点:前端写界面哦买噶。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:2:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"3、Walk(6k收藏) 项目地址:https://github.com/lxn/walk 优点:对Windows很友好 缺点:只支持Windows，界面布局很难设计。 在使用的过程中，我卡在了如何设计界面布局这里。。。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:3:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"4、govcl(2k收藏) 项目地址:https://github.com/ying32/govcl/ 示例文件:https://github.com/ying32/govcl/tree/master/samples 文档地址:https://gitee.com/ying32/govcl/wikis/pages?sort_id=2030600\u0026doc_id=102420 优点:跨平台，代码可信度高，毕竟是基于前人的Delphi界面库，有背书。 缺点:需要模块，需要比较了解GTK这一块的知识。 在开发的过程中发现可用函数太少了，还得去下载专门的UI设计器，太麻烦了。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:4:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"5、qt(9k收藏) 项目地址:https://github.com/therecipe/qt 优点:熟悉QT，入手起来有优势，项目维护好。 缺点:QT配置较为复杂。 相关资料: https://zhuanlan.zhihu.com/p/191591015 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:5:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"6、electron(4k收藏) 项目地址:https://github.com/asticode/go-astilectron ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:6:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"7、炫彩GUI 项目地址:https://github.com/twgh/ 相关文档:http://www.xcgui.com/doc-ui/page__basic_example.html 初看起来很不错，但是实际编写代码的时候发现很难使用，感觉像是一个不懂界面设计的人写出来的实验作品，如果作者能够持续不断优化的话或许有一天也能用了。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:7:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"8、GIU 项目地址:https://github.com/AllenDang/giu 示例文件:https://github.com/AllenDang/giu/tree/master/examples ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:8:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["Go语言"],"content":"参考资料 https://github.com/avelino/awesome-go#gui 总结 需要跨平台，并且只是一个简单的UI，优先选择Fyne。 Windows平台界面，选择walk \u003e govcl。 一个能打的都没有，缺点都很多。 …… 2022年11月10日，用Go语言写GUI，我已经放弃了。 2022年11月20日，又试了试用Fyne写GUI，还不如学C#呢，我已彻底疯狂。 ","date":"2021-12-26","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/:9:0","tags":["Go","GUI"],"title":"Go语言编写GUI界面","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80gui%E7%95%8C%E9%9D%A2/"},{"categories":["数据库"],"content":"Mysql学习 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:1:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Mysql的安装 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Windows平台下: 需要安装Mysql Community Server，下载地址:https://dev.mysql.com/downloads/mysql/ ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:1","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"linux平台下: wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:2","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"安装步骤 1、下载完成后首次启动需要初始化数据库，会得到一个临时密码 另外，mysql5.6版本则没有初始化这一步。 mysqld --initialize --console 2、将mysql安装为系统服务 //安装服务 mysqld -install //移除服务 mysqld -remove 3、使用临时密码登录mysql服务 mysql -u root -p 4、修改root用户密码，并提交 mysql\u003e alter user 'root'@'localhost' identified by '想要设置的密码'; mysql\u003e commit; 5、创建数据库 mysql\u003e create database \u003c数据库名\u003e; 6、Mysql8.0设置远程连接密码 mysql\u003e ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'mypass@123'; 7、Mysql关闭密码策略，分别是Mysq旧版本和新版本两种命令。 mysql\u003e set global validate_password_policy = 0; mysql\u003e set global validate_password.policy = 0;\rset global validate_password.mixed_case_count = 0;\rset global validate_password.number_count = 0;\rset global validate_password.special_char_count = 0; 8、刷新权限 mysql\u003e flush privileges; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:2:3","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"MySQL语句 1、查询有哪些数据库 mysql\u003e show databases; 2、使用数据库 mysql\u003e use \u003c数据库名\u003e; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:3:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"SQL语句 1、查询数据库中有哪些表 select table_name from information_schema.tables where table_schema='数据库名'; 2、 ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:4:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"关于UNIQUE Mysql数据库中可以使用UNIQUE关键字给字段添加唯一索引。需要注意的是，创建唯一的索引的目的不是为了提高访问速度，而是为了避免数据出现重复。唯一索引可以有多个但索引列的值必须唯一，索引列的值运行有空值。创建唯一索引的示例如下: CREATE TABLE URLTABLE( url TEXT COMMENT 'url接口', ip TEXT COMMENT 'IP地址', md5 CHAR(32) UNIQUE COMMENT 'hash值' ); ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:5:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Mysql获取字段去重后的总数 如果一张表中某个字段存在重复的值，我们想去重后获取这个字段值的总数。例如有下列数据库 select count(distinct(去重的字段)) as count from 表名; ","date":"2021-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/:6:0","tags":["Mysql"],"title":"Mysql学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"ClickHouse ClickHouse是俄罗斯Yandex于2016年开源的一个高性能的SQL数据库。我对这个数据库的看法是，如果你的数据只涉及到读和写，不存在对数据的修改和删除，那么你永远可以信任ClickHouse。 ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:0","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"简介 1、对linux比较友好，如果要在windows运行，就必须使用容器了。 相关文档:https://clickhouse.com/docs/zh/ ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:1","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"安装过程 sudo yum install yum-utils sudo rpm --import https://repo.clickhouse.com/CLICKHOUSE-KEY.GPG sudo yum-config-manager --add-repo https://repo.clickhouse.com/rpm/stable/x86_64 ClickHouse语句 查询数据库中所有的表名，以及对应的建表语句 select database,name,create_table_query from `system`.tables where database = 'Test' ","date":"2021-12-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/:0:2","tags":["ClickHouse"],"title":"ClickHouse学习","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse%E5%AD%A6%E4%B9%A0/"},{"categories":["CSharp"],"content":"众所周知，自动有了Dnspy这类的反编译工具，C#写的程序如果不加壳，那就差不多把源码送给别人。 而一款商业化的工具，自然是需要加壳工具保护的。 C#端的加壳工具大全:https://github.com/NotPrab/.NET-Obfuscator ","date":"2021-12-14","objectID":"/posts/csharp/csharp%E5%8A%A0%E5%A3%B3%E5%B7%A5%E5%85%B7/:0:0","tags":["加壳"],"title":"C#加壳工具","uri":"/posts/csharp/csharp%E5%8A%A0%E5%A3%B3%E5%B7%A5%E5%85%B7/"},{"categories":["编程工具"],"content":"VS Code学习 VS Code介绍:全能的现代化开发环境，非常适合全栈开发工程师。 下载地址:https://code.visualstudio.com/ ","date":"2021-12-14","objectID":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/:1:0","tags":["VSCODE"],"title":"VSCODE学习","uri":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/"},{"categories":["编程工具"],"content":"基础介绍 1、VS Code默认打开的话只是个资源浏览器和文本编辑器，如果要切换到项目，则需要切换到指定的项目文件夹，在菜单上选择 文件 -\u003e 打开文件夹 即可。 ","date":"2021-12-14","objectID":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/:1:1","tags":["VSCODE"],"title":"VSCODE学习","uri":"/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/vscode%E5%AD%A6%E4%B9%A0/"},{"categories":["反编译"],"content":"SmartDec反编译器项目地址:https://github.com/smartdec/smartdec 记录 1、反编译逻辑入口:void Decompilation::work() 2、核心反编译函数:UniversalAnalyzer::decompile() ","date":"2021-12-06","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/smartdec%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/:0:0","tags":["SmartDec"],"title":"SmartDec源码阅读","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/smartdec%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"categories":["反编译"],"content":"反编译器项目现状总结 1、目前反编译能力最强的，应该是IDA了，但是缺点是IDA并不开源，而且开放的SDK中和反编译相关的部分并不完整。 2、Ghidra，应该是目前最牛逼的开源反编译器了。如果要研究反编译，强烈建议学习这个。 3、Retdec，基于LLVM IR做反编译，可谓是提出了一种新的反编译器解决思路，但是我个人感觉稍微有点绕弯路了，LLVM IR是非常底层的东西，一条汇编就能转成5到10条LLVM IR，不可谓不复杂。 4、clutter，可能反编译器对其它指令集更友好吧，x86下连浮点寄存器都不支持。 5、reko，反编译能力很差。 SmartDec 项目地址:https://github.com/smartdec/smartdec C++编写的反编译器，需要Qt和Boost库，支持PE和ELF格式的文件反编译。 配置选项参考说明: https://github.com/smartdec/smartdec/blob/master/doc/build.txt 这里记录一下我在编译项目的时候，踩的坑吧: 1、只支持低版本Qt，我使用的版本是4.8.7 2、如果使用高版本的编译器，例如我用的是Visual Studio 2019(v142)，需要改一处代码。 在nc/config.h文件中，屏蔽代码define noexcept throw()，如下所示: /* Define noexcept as throw() for MSVC and GCC \u003c 4.6. */ #if defined(_MSC_VER) # //define noexcept throw() 屏蔽就完事了 #elif defined(GCC_VERSION) \u0026\u0026 (GCC_VERSION \u003c 40600) # define noexcept throw() #endif 项目评价: 缺点:作为一个半成品，几乎无法正常使用，只能作为一个玩具反编译器，反编译项目中给定的example，而且项目已停止维护。 优点:代码不多，其中的代码值得学习参考。 RetDec 项目地址:https://github.com/avast/retdec 基于LLVM的反编译器，或许是反编译程序的终点？ ","date":"2021-12-05","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:0","tags":["Github"],"title":"反编译项目介绍","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["前端"],"content":"Vue学习 官方文档:https://cn.vuejs.org/v2/guide/index.html Vue简介:Vue是基于javascript编写一个前端框架，也可以理解为是javascript的一个库。 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:0:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"配置Vue环境 1、安装nodejs，nodejs可以理解为javascript版本的服务端。 2、nodejs中内置npm，npm可以理解为像pip、go get之类的javascript库管理工具。 3、安装cnpm，cnpm可以理解为npm的中国版。 npm install -g cnpm --registry=https://registry.npm.taobao.org 4、安装vue-cli，这个网上都说是vue项目的脚手架，我个人感觉就像是一个项目控制台吧，方便构建和管理vue项目。 cnpm install vue-cli -g 5、npm install在下载第三方库时，偶尔会卡住，这个时候可以尝试使用以下命令(从网上搜集的) npm cache clean ipconfig /flushdns git config http.postBuffer 524288000 git config --global http.sslVerify false npm install --registry=https://registry.npm.taobao.org 可能还是github被墙导致的，好像没有什么太好的办法。 6、查看使用的Vue版本 npm list vue 7、查看vue-cli版本 vue --version 8、使用webpack初始化vue项目，webpack简单来说可以理解为一个项目打包 + 模板化工具。 vue init webpack project_test 项目名必须是全小写 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:1:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"Vue模板详解 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:2:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"搭建VS Code环境 1、安装VS Code https://code.visualstudio.com/ 2、安装VS Code插件 插件Vetur ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:3:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"基础语法 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:4:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["前端"],"content":"可能遇到的问题 1、error:0308010C:digital envelope routines::unsupported 解决办法:输入以下命令 export NODE_OPTIONS=--openssl-legacy-provider 参考资料:https://github.com/webpack/webpack/issues/14532 参考项目 1、https://github.com/PanJiaChen/vue-element-admin 一个管理后台的项目，可以用来参考学习。 ","date":"2021-12-02","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/:5:0","tags":["vue"],"title":"Vue学习","uri":"/posts/%E5%89%8D%E7%AB%AF/vue%E5%AD%A6%E4%B9%A0/"},{"categories":["后端开发"],"content":"正向代理与反向代理 无论代理服务器是正向还是反向，基本原理是相同的，如下图所示: 代理原理 正向代理被客户端所使用，客户端使用自己的代理服务器，可以达到隐藏自身的IP地址，欺骗服务器的效果。 反向代理与正向代理相反，被服务端所使用，服务端使用自己的代理服务器，可以实现隐藏自身真实服务器IP地址，负载均衡等效果。 实现正向代理服务器 1、goproxy:https://github.com/elazarl/goproxy go语言编写的一款代理服务库，支持中间人劫持，代码量小，可定制性强，性能还不错。 不过作者似乎已经很久没有维护过该项目了，我将此代码应用到实际的项目中，发现代码还是存在一些问题的，想要好好地使用还得进行一番源码修复才行哦。 2、mitmproxy:https://github.com/mitmproxy/mitmproxy python编写，维护时间比较长，专门为中间人劫持而制作，暂时没应用过此项目，不太好评价。 ","date":"2021-11-11","objectID":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/:0:0","tags":["代理","proxy"],"title":"代理服务器开发","uri":"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"categories":["Linux"],"content":"安装nload工具 nload可以用来查看linux网络流量，用来实时监测网络流量和带宽使用情况。 yum install gcc yum install gcc gcc-c++ gcc-g77 sudo yum -y install ncurses sudo yum -y install ncurses-devel yum install wget #下载源码编译安装 wget http://www.roland-riegel.de/nload/nload-0.7.2.tar.gz tar zxvf nload-0.7.2.tar.gz cd nload-0.7.2 ./configure make make install ","date":"2021-11-10","objectID":"/posts/linux/linux%E5%AE%89%E8%A3%85nload%E5%91%BD%E4%BB%A4/:1:0","tags":["nload"],"title":"linux安装nload命令","uri":"/posts/linux/linux%E5%AE%89%E8%A3%85nload%E5%91%BD%E4%BB%A4/"},{"categories":["Go语言"],"content":"基础类型 整数型:int、uint、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64 浮点类型:float32、float64 布尔类型:bool 字符串类型:string 字符类型:byte、rune 1、Go语言编译器不会对数据类型进行任何隐式转换，int和int32是两种不同的类型。 2、整数型默认值是0，布尔类型默认值是false，字符串默认是空字符串 3、这些基础类型在进行函数参数传递的时候，都是值传递，即会拷贝一份副本传递至函数体内，函数内对参数的修改不会影响到变量本身。 变量声明 有两种声明方式 //第一种是正常的声明 var a int a = 1 var b int = 2 //第二种是类型自动推导 c := 3 d := \"4\" ","date":"2021-11-09","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["笔记","Go"],"title":"Go语言菜鸟系列(二)基础语法","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Go语言"],"content":"Go语言函数参数传递 参数类型 参数传递 int、string 值传递 []int、[]string、[]*int、[]*string 指针传递 map[string]string 指针传递 总结来说，go语言仅有的两个容器——切片和哈希表，它们的拷贝都是浅拷贝，测试用例如下: func NoCopyMap(testMap map[string]string) { testMap[\"111\"] = \"222\" } func main() { testMap := make(map[string]string) newMap := testMap NoCopyMap(newMap) print(testMap,\"=\",newMap) } ","date":"2021-11-09","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:1","tags":["笔记","Go"],"title":"Go语言菜鸟系列(二)基础语法","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%BA%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Go语言"],"content":"Go语言库 需要进行爬围墙:https://golang.org/ 国内网站:https://studygolang.com/dl 学习相关网站 https://www.topgoer.com/ 开发环境IDE 目前使用的是GoLand，下载地址:https://www.jetbrains.com/go/ GoLand是收费软件，需要配合无限试用插件，在GoLand插件市场，搜索Eval Reset，安装插件即可。 安装插件后，在Help -\u003e Eval Reset中，勾选Auto reset before per restart，即每次重启都会重置试用时间。 另外，GoLand这败家玩意可能和自己从官网下载的go语言库有一些不兼容，如果出了什么问题的话，建议从File -\u003e Settings -\u003e GOROOT中让GoLand自己去远程下载SDK。。。。。。 第一个main程序 package main import \"fmt\" func main() { fmt.Println(\"hello world\") } 很明显，package main中的main函数就是程序的入口。 下载第三方库文件 go和python一样拥有第三方库镜像平台，在命令行中使用go get命令就可以下载，但是国内经常会出现无法访问的情况，这个时候需要设置镜像源为国内。 Windows Powershell输入以下命令，切换镜像源，有下面几种: go env -w GOPROXY=https://goproxy.io,direct go env -w GOPROXY=https://goproxy.cn,direct Linux输入以下命令 export GOPROXY=https://goproxy.io,direct 输入go env查看环境变量，来检查设置是否成功。 项目结构 所谓项目结构，我认为可以比作是建房子，上面的砖头依赖下面的砖头，故下面的砖头不能再去依赖上面的砖头了，其难度在于如何划分出哪些代码是最下面的砖头。 在C语言里面由于定义和实现是分开的，因此不同的文件基本上都可以互相引用，舒服得很，但到了go语言这里就不行了，分分钟交叉引用编译不通过，遇到这种情况，开发者就要考虑到如何将一个模块，拆分成更多更细的子模块，实现功能解体，说简单点就是将A依赖B，B依赖A，拆分成A依赖C，B依赖C。 Goland项目配置介绍 选择Goland -\u003e Run -\u003e Edit Configurations可以对项目进行配置。 Output directory为可执行文件的输出目录，我一般设置为 项目根路径\\bin 目录。 Working directory为可执行文件的工作目录，我一般设置为项目根路径\\bin 目录。 Environment为go的环境变量，有以下几种设置(设置有多个的话，使用;符号进行连接): 变量 说明 可选项 GOOS 编译指令对应的操作系统 windows、linux GOARCH 指令集架构 amd64、386 Go Tool arguments为go的编译参数，例如go语言程序想去掉控制台界面显示，可以填入以下参数: -ldflags -H=windowsgui ","date":"2021-11-08","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["笔记","Go"],"title":"Go语言菜鸟系列(一)环境搭建","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E8%8F%9C%E9%B8%9F%E7%B3%BB%E5%88%97%E4%B8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Go语言"],"content":"Go搭建远程动态调试环境 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:0","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"1、安装go语言 yum install epel-release yum install golang ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:1","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"2、安装调试工具Delve #安装dlv go get -u github.com/go-delve/delve/cmd/dlv #寻找dlv的路径 sudo find / -name dlv #软链接到go的路径 ln -s /root/go/bin/dlv $GOROOT/bin #输入dlv测试是否配置成功 dlv ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:2","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"3、配置GoLand 1、选择Tools -\u003e deployment -\u003e Configuration，新建sftp。 2、填写SSH configuration，配置Root path，这里的root path指的是项目的根目录。 3、选中项目，选择Tools -\u003e deployment -\u003e upload to server，将项目上传到服务器上。 4、选择Run -\u003e Edit Configurations -\u003e 新增Go Remote，填写需要连接的host和端口。 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:3","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["Go语言"],"content":"4、开始调试 1、远程服务器，在项目目录中，运行 dlv debug --headless --listen=:2345 --api-version=2 2、Goland点击远程调试即可。 ","date":"2021-11-01","objectID":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/:1:4","tags":["Go"],"title":"Go语言搭建远程动态调试环境","uri":"/posts/go%E8%AF%AD%E8%A8%80/go%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"},{"categories":["x64Dbg"],"content":"x64Dbg是如何绘制程序代码流程图的 首先在C++代码src\\dbg\\analysis\\advancedanalysis.cpp有与代码流程算法与结构生成相关的代码，最后应该是转换成了dot格式吧。 之后在Qt代码src\\gui\\Src\\Gui\\DisassemblerGraphView.cpp有与流程图的显示、缩放之类相关的代码。 ","date":"2021-10-30","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/:0:0","tags":["x64Dbg"],"title":"x64Dbg源码阅读记录","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"},{"categories":["安全攻防"],"content":"​ Cain工具官方版是一款专业可靠的远程控制命令或密码的软件，Cain工具最新版可以明文捕捉几十种方式的远程密码或口令，支持十几种远程控制或远程传输协议，Cain工具官方版可以用来crack屏保、PWL密码、共享密码、缓存口令、远程共享口令、SMB口令、支持VNC口令解码、Cisco Type-7口令解码等。 ​ 支持的平台:Windows ​ 大概用来做这些事情吧: 1、解密出保存在本地的Wifi密码。 2、嗅探局域网内的机器并进行arp欺骗，可用来盗取密码。 arp欺骗 ARP（Address Resolution Protocol）地址转换协议，工作在OSI模型的数据链路层，在以太网中，网络设备之间互相通信是用MAC地址而不是IP地址，ARP协议就是用来把IP地址转换为MAC地址的。而RARP和ARP相反，它是反向地址转换协议，把MAC地址转换为IP地址。 每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。 总的来说就一句话，在数据包中篡改自己的mac地址，进行中间人攻击。 arp欺骗防御手段: 上层网络保留好各计算机的MAC地址，在伪造的ARP数据包发出时即可侦测到。 ","date":"2021-10-27","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/cain%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/:0:0","tags":["Cain","Winpcap"],"title":"Cain工具使用","uri":"/posts/%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/cain%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"categories":["动态调试"],"content":"x32gui.dll 此模块是调试器界面，核心函数为processMessage，处理着所有的界面消息。 void* Bridge::processMessage(GUIMSG type, void* param1, void* param2) ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:1:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"GUI模块 SelectionGet bool SelectionGet(Window window, duint* start, duint* end); 获取指定窗口的光标选中区域。 SelectionSet bool SelectionSet(Window window, duint start, duint end); 设置指定窗口的光标选中区域。 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:2:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Memory模块 Read bool Read(duint addr, void* data, duint size, duint* sizeRead); 读取被调试进程内存中指定大小的数据。 Write bool Write(duint addr, const void* data, duint size, duint* sizeWritten); 写入数据到被调试进程的内存中。 RemoteAlloc duint RemoteAlloc(duint addr, duint size); 在被调试器的进程中申请指定大小内存。 GetBase duint GetBase(duint addr, bool reserved = false, bool cache = true); 获取指定地址所在内存区域的基址。 GetSize duint GetSize(duint addr, bool reserved = false, bool cache = true); 获取指定地址所在内存区域的大小。 ReadDword unsigned int ReadDword(duint addr); 读取指定地址四字节大小。 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:3:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Main模块 GuiAddLogMessage void GuiAddLogMessage(const char* msg); 在x64Dbg的日志窗口打印一条消息。 GuiDisasmAt void GuiDisasmAt(duint addr, duint cip); 设置反汇编窗口指向的反汇编地址。 DbgIsDebugging bool DbgIsDebugging(); 判断当前调试器是否处于调试状态，未载入文件进行调试返回false，否则返回true。 DbgGetProcessHandle HANDLE DbgGetProcessHandle(); 获取当前被调试进程的句柄 DbgCmdExec bool DbgCmdExec(const char* cmd); 将x64Dbg命令加入执行队列后立即返回。 DbgCmdExecDirect bool DbgCmdExecDirect(const char* cmd); 执行x64Dbg命令，此函数等待命令执行完成才会后返回。 GuiSetFavouriteToolShortcut void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut); 设置收藏工具的快捷键 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:4:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["动态调试"],"content":"Pattern模块 FindMem duint FindMem(duint start, duint size, const char* pattern); 搜索内存中的数据，支持模板匹配 ","date":"2021-10-16","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/:5:0","tags":["x64Dbg"],"title":"x64Dbg插件开发相关","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"categories":["C++开发"],"content":"Spd是一个C++的高效日志打印库 项目地址:spdlog: Fast C++ logging library Spd日志库有着自己的一些语法打印格式，详细内容参考 Custom formatting ","date":"2021-10-15","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E6%97%A5%E5%BF%97%E5%BA%93/:0:0","tags":["日志库"],"title":"C++日志库","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["动态调试"],"content":"GDB调试 命令 解释 attach 进程PID 附加进程调试 next 单步步过,简写n step 单布步入,简写s finish 结束当前函数，返回到函数调用点 print 打印地址以及值，简写p info breakpoints 查看当前断点情况 ","date":"2021-10-15","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/gdb%E8%B0%83%E8%AF%95/:0:0","tags":["GDB","调试器","Linux"],"title":"GDB调试","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/gdb%E8%B0%83%E8%AF%95/"},{"categories":["C++开发"],"content":"​ 禁止程序多开其实有两种，一种是启动A1进程，再启动A2进程，A2进程自行退出；另外一种是启动A1进程后，再启动A2进程，A1进程自行退出。 ​ 第一种逻辑相对来说比较简单，随便贴一下网上抄的代码: void 禁止新开() BOOL bRet = FALSE; HANDLE hMutex = ::CreateMutexA(NULL, FALSE, \"random_id\"); if (GetLastError() == ERROR_ALREADY_EXISTS) { CloseHandle(hMutex); ExitProcess(0); } while (true) { printf(\"running...\\n\"); Sleep(1000); } } ​ 第二种逻辑就比较复杂了，核心思路应该是去想办法通知原先的进程，让它自行退出，这里只能给一个简易的版本: void 禁止多开() { HANDLE event = CreateEventA(NULL, true, false, \"random_id\"); SetEvent(event); std::thread th([event]{ ResetEvent(event); WaitForSingleObject(event, INFINITE); ExitProcess(0); }); th.detach(); } ","date":"2021-10-14","objectID":"/posts/c++%E5%BC%80%E5%8F%91/%E7%A6%81%E6%AD%A2%E5%A4%9A%E5%BC%80/:0:0","tags":["高级C++","Event"],"title":"禁止程序多开","uri":"/posts/c++%E5%BC%80%E5%8F%91/%E7%A6%81%E6%AD%A2%E5%A4%9A%E5%BC%80/"},{"categories":["C++开发"],"content":"​ 在开发TCP有关的程序的时候，我们就会遇到粘包的这个单词了。 ​ 首先要知道TCP是\"完美的\"，久经考验的TCP协议能够确保数据被有序而准确地发送和接受，因此粘包问题是个伪问题，本质上其实是应用层接收和发送数据双方之间未做好约定。 ​ 我们都知道发送和接受的数据分别是send和recv，假设客户端发送两次数据，如下: std::string msg1=\"1234\"; send(ConnectSocket, msg1.c_str(), msg1.size(), 0); std::string msg2=\"5678\" send(ConnectSocket, msg2.c_str(), msg2.size(), 0); 客户端发送数据每4个字节当作一帧，那么根据服务端设置的接受数据长度的不同，有以下几种情况: recv和send数据长度相等，数据正常接收。 recv长度小于send数据长度，数据少接收，前面的数据和后面的数据都被破坏。 recv长度大于send数据长度，数据将多接收，前面的数据和后面的数据都被破坏。 //数据正常接受 char buffer1[4]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[4]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); //数据遭到破坏 char buffer1[3]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[3]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); //数据遭到破坏 char buffer1[5]={0}; recv(ConnectSocket,buffer1,sizeof(buffer1),0); char buffer2[5]={0}; recv(ConnectSocket,buffer2,sizeof(buffer2),0); ​ 看到这里，我自己都觉得自己废话多，其实所谓粘包无非就是send和recv的长度不对等而已，网上说的都是屁话。 完美情况下，每次发送约定好的长度，每次接受约定好的长度，什么事都没有。但是由于实际情况比较复杂，例如客户端需要发送文件给服务端，文件的长度是会动态变化的，因此需要自己设计应用层的协议算法，一般来说有下面几种想法: 1、双方约定好数据长度 //客户端 std::string msg=\"1234\"; int msgLen=msg.size(); send(ConnectSocket,\u0026msgLen,4,0) send(ConnectSocket,msg.cstr(),msgLen,0); //服务端 int msgLen = 0; recv(ConnectSocket, (char*)\u0026msgLen, 4, 0); char* pBuf = new char[msgLen]; recv(ConnectSocket, pBuf, msgLen, 0); delete pBuf; 核心思想就是服务端在第一次接收到数据的时候，确认好后续的数据长度。 但是上面的代码有一个潜在的问题，比如客户端连续多次发送数据，由于网络原因存在某一个send没发送出去呢？这样服务端的解析会全乱，因此上述代码还需要进一步优化。 2、以指定字符串标记作为包的结束标志 不管三七二十一，我们自定一个值，例如0xCCDDEEFF，服务端处理每帧数据的时候，会进行判断和分包处理。 ","date":"2021-10-11","objectID":"/posts/c++%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88tcp%E7%B2%98%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/:0:0","tags":["高级C++","TCP"],"title":"浅谈TCP粘包的理解","uri":"/posts/c++%E5%BC%80%E5%8F%91/%E6%B5%85%E8%B0%88tcp%E7%B2%98%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Github碎片"],"content":"brynet 项目地址:https://github.com/Microsoft/vcpkg/tree/master/ports/brynet 这个库的优点是只需要包含头文件就能使用，而且属于小型库，可以很方便地深入底层代码调试分析，方便网络库初学者研究。 但是就功能上看，我的评价是不稳定，慎用。 evpp 项目地址:https://github.com/Qihoo360/evpp 从配置上看，有一个缺点是需要引入很多lib。 从功能上看，我的评价是不好用。 asio2 项目地址:https://github.com/zhllxt/asio2 从配置上看，只需要包含头文件就能使用，有一个缺点是只支持C++ 17，对老项目不友好。 从功能上看，我的评价是还行。 ","date":"2021-10-10","objectID":"/posts/github%E7%A2%8E%E7%89%87/tcp%E9%80%9A%E8%AE%AF%E5%BA%93/:0:0","tags":["TCP","Network"],"title":"TCP通讯库","uri":"/posts/github%E7%A2%8E%E7%89%87/tcp%E9%80%9A%E8%AE%AF%E5%BA%93/"},{"categories":["C开发"],"content":"FreeRDP FreeRDP是由C语言编写的一个远程桌面连接软件，使用标准的RDP协议。 搭建编译环境 1、下载openssl和libusb三方库。 vcpkg.exe install openssl:x86-windows vcpkg.exe install openssl:x64-windows vcpkg.exe install libusb:x86-windows vcpkg.exe install libusb:x64-windows libusb:https://github.com/libusb/libusb/releases OpenSSL:http://slproweb.com/products/Win32OpenSSL.html ","date":"2021-10-09","objectID":"/posts/c++%E5%BC%80%E5%8F%91/freerdp/:0:0","tags":["远程控制"],"title":"FreeRDP开源远程控制","uri":"/posts/c++%E5%BC%80%E5%8F%91/freerdp/"},{"categories":["C++开发"],"content":"Windows创建计划任务 schtasks create | Microsoft Docs ","date":"2021-10-09","objectID":"/posts/c++%E5%BC%80%E5%8F%91/windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/:0:0","tags":["高级C++","Windows"],"title":"Windows应用开发","uri":"/posts/c++%E5%BC%80%E5%8F%91/windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"categories":["Linux"],"content":"Docker容器学习 docker查询容器 docker ps docker进入容器 docker exec -it 容器id ash docker exec -u root -it 容器id ash docker列举本地已有镜像 docker images docker 保存镜像 docker save 镜像仓库名 -o 文件路径 docker 杀掉一个运行中的容器 docker kill 容器id docker查看容器内的标准输出 docker logs 容器id docker拷贝文件 从容器内拷贝至主机 docker cp 容器id:文件路径 文件路径 远程调试Docker内的进程 1、根据容器的id获取容器的pid docker inspect –format {{.State.Pid}} 834e73bf3caa 2、使用nsenter进程gbd调试 nsenter -t 容器PID -m -p gdb -p 容器内进程PID 容器端口映射 端口也可以映射多个 docker run -it -d -p 0.0.0.0:3000:3000 -p 9988:9988 容器镜像名称 设定网络模式 –network host ","date":"2021-10-08","objectID":"/posts/linux/docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/:0:0","tags":["Docker"],"title":"Docker容器学习","uri":"/posts/linux/docker%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"categories":["易语言"],"content":"因为工作的原因，需要判断文件是否为易语言程序，这里稍微记录一下。 首先了解到易语言EXE程序大致上可以分为编译、独立编译、静态编译、黑月编译这几种。 1、读取文件的版本信息 大部分易语言程序的文件说明和产品名称是固定的值。 2、读取程序资源中的MANIFEST数据 判断其中是否含有E.App这个关键字。 这种做法的好处是静态判断，有些程序即便是加了一些稀奇古怪的壳(SE、VMP、SP等)，也依然可以检测出来。 缺点是可能无法检测一些感染了蠕虫病毒的易语言样本。 3、判断xor eax,eax 已知易语言程序代码段第一句为xor eax,eax，所以可以利用它来进行快速检测。 优点是简单、快速。 缺点是只支持静态编译的程序，且部分程序即便是静态编译开头也不是xor eax,eax指令。 4、特征码扫描 易语言程序有太多的特征码，这里就不详细说明了。 这个方法缺点是对于加了壳的程序，需要动态运行起来才能进行识别。 优点是支持一些被蠕虫病毒(例如Synaptics)感染的样本。 ","date":"2021-09-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/:0:0","tags":["易语言"],"title":"如何判断文件是否为易语言程序","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/"},{"categories":["C++开发"],"content":"​ unique_ptr指针的出现是为了解决指针释放的问题，在将指针升级为unique_ptr指针的时候，需要注意这二者之间的区别。 在C++项目中我们一般这样定义头文件: class A; class B { A* a; } 没毛病，非常完美，但是升级到unique_ptr之后: class A; class B { std::unique_ptr\u003cA\u003e a; } 这样实际上是存在隐患的，因为std::unique_ptr需要静态检测类型的大小，我们需要额外声明B的析构函数，像下面这样: class A; class B { std::unique_ptr\u003cA\u003e a; public: ~B() = default; } 总的来说，unique_ptr相较之前的裸指针传递，还是好用的，就是得多撸很多代码… ","date":"2021-09-25","objectID":"/posts/c++%E5%BC%80%E5%8F%91/unique_ptr%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/:0:0","tags":["高级C++"],"title":"unique_ptr使用注意事项","uri":"/posts/c++%E5%BC%80%E5%8F%91/unique_ptr%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"categories":["C++开发"],"content":"以下谈一下自己感想 使用原生数据类型 很多项目喜欢自建自己的数据类型，比如std::vector、std::list，这个项目来一个qvector、qlist，另外一个项目又是QVector、QList。又或者一个很普通的int数据类型，在这个项目中是typedef char int8，另外一个项目又是typedef long long int8。 而这样容易出现头文件不兼容，无法引用各种问题，给我们这些代码搬运工带来了很大的麻烦。这里我只能建议尽可能使用自己的数据类型，例如在Windows平台上我们使用的最多的是vector和string，如果上述方案仍然无法解决，最终的办法是建立自己的中间件，例如封装一个Wrapper类，重新封装一遍要调用的库函数。 不要陷入解耦陷阱 有一次在写项目的时候，我老想着把功能给解耦，例如有一个模块G，可以解耦成三个类，于是我把模块拆分成A、B、C三个类，这三个模块分别使用数据X、Y、Z，于是我又把这三种数据类型分配到对应的类中去，但是事实上这三种数据X、Y、Z实质上可以理解为一种东西，最后我又把这三种数据合并到一起，又把类整合了回去。。。 从上面的例子来看，如果说项目由功能 + 数据类型组成的话，我试图对功能进行解耦，然而却忽略了数据类型无法解耦的事实，结果陷入了解耦的陷阱。 ","date":"2021-09-20","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/:0:0","tags":["C++"],"title":"C++个人感想","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"},{"categories":["C++开发"],"content":"​ volatile单词意思为易变的，这里作为关键字是用来提示编译器它后面所定义的变量随时有可能改变。具体看下面这个源码例子: void test() { int a=2; while(1){ if(a==1){ break; } } } ​ 按照C++的编译优化逻辑，汇编伪代码可能会变成下面这个样子: void test() { //申请四个字节堆栈空间 var a=alloc(0x4); //初始化变量a mov a,0x2; //将变量a存储到寄存器上 mov eax,a; while(1){ if(eax==1){ break; } } } ​ 如果像这个样子，即使a的值在其他的地方发生了改变，循环也无法跳出去了。因此我们需要指定volatile关键字，提示编译器不要随便使用寄存器来缓存变量，汇编代码就是这个样子: void test() { //申请四个字节堆栈空间 var a=alloc(0x4); mov a,0x2; while(1){ if(a==1){ break; } } } ","date":"2021-08-17","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["高级C++"],"title":"C++中的volatile关键字","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["Linux"],"content":"​ 在我们遇到与跨平台有关的一些事的时候，估计就会碰上这玩意。Cygwin提供了一个在Windows下面使用Linux环境的平台。 ​ 这个cygwin实现的原理大概就是依赖一个能在windows平台运行的核心库，叫做cygwin1.dll，这个模块提供了底层的Linux API的所有功能，从而达到欺骗linux程序，让它以为自己在linux上面运行的目的。好家伙，这不就是中间人攻击吗？ ​ 而Wine可谓是和Cygwin互补，是linux系统下一个用来模拟windows环境的程序。 ","date":"2021-08-11","objectID":"/posts/linux/cygwin/:0:0","tags":["Cygwin","Wine"],"title":"Cygwin和Wine","uri":"/posts/linux/cygwin/"},{"categories":["反编译"],"content":"​ Ghidra项目地址:https://github.com/NationalSecurityAgency/ghidra ​ 在项目/Ghidra/Features/Decompiler/src/decompile/cpp目录下有一个C++写的开源反编译器。下载下来后一共有consolemain.cc、sleighexample.cc、slgh_compile.cc、test.cc、ghidra_process.cc这五个测试例子。 ​ ghidra_process.cc对应生成的文件decompile.exe。 ​ slgh_compile.cc对应生成的文件sleigh.exe。 ​ test.cc是一些测试代码，不用管。 ​ ​ 项目代码适用于linux上的编译器，因为其使用了linux下的bfd库，如果要移植到windows平台上，就得重写项目中loadimage_bfd.hh和loadimage_bfd.cc这两个文件。 consolemain项目 load file 123.exe load addr 0x4C0 decompile print C 项目文件介绍 项目中有doccore.hh和docmain.hh这两个帮助文档。 代码中还有几个比较有有用的例子，例如consolemain.cc、sleighexample.cc、slgh_compile.cc，可以让我们快速理解代码的运行。 类 说明 UserPcodeOp 用户自定义的Pcode操作指令，指令类型都属于CALLOTHER Pattern 指令匹配模板 StringManager 字符串管理类 ParamList 函数参数列表 Symbol 符号相关 Scope 命名空间或者函数范围，用来区分Symbol符号 Datatype 变量、函数的数据类型 Action 用来表示代码具体执行的行为动作。 LoadImage 二进制文件加载至映像内存中 Architecture 针对LoadImage实例化的处理器类 Translate 根据处理器将指令数据转换为汇编代码或者pcode。 PrintLanguage 生成高级语言 PcodeEmit Pcode生成器 TransformManager 根据数据流对代码逻辑进行转换 MemoryBank 用来表示二进制文件中的虚拟内存 JumpModel 跳转表模型 TypeModifier 类型修饰符 Emulate 基于Pcode的代码模拟执行 Widener 值扩展类，将值的字节大小自动进行扩充。 CapabilityPoint 反编译器的扩展能力。 Rule 用来表示反编译规则。 FlowBlock 控制流基本块。 TypeOp Op指令的类型大全 Address 用来表示地址，主要是用来存储offset这一个字段。 P-Code p-code 可以理解为一种新的指令集，能够适用于任何处理器的语言。 ","date":"2021-08-09","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80/:0:0","tags":["Ghidra"],"title":"Ghidra反编译(一)","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80/"},{"categories":["反编译"],"content":"VarNode varnode可以理解为pcode的组成参数。 例如一条PUSH 0x0指令 可以理解为\rvar tmp = 0x0\resp = esp - 0x4\r[esp] = tmp\r[40101e]:(unique,0x2f200,4) = COPY (const,0x0,4)\r[40101e]:(register,0x10,4) = INT_SUB (register,0x10,4) (const,0x4,4)\r[40101e]:STORE (const,0x1def5c9fdd0,8) (register,0x10,4) (unique,0x2f200,4) 结构体解读 1、Varnode 变量节点，可以理解为pCode指令对应的变量，一个变量节点可以用来表示任何数据，包括寄存器、堆栈、内存、常量。 不同变量节点通过Address来进行标记。 2、FuncData 函数可以理解为Ghidra重要的反编译基本单位，此结构体包含与函数反编译有关的一切。 包含控制流、数据流、数据类型信息、跳转表、参数，其中比较重要的几个函数有: startProcessing()，开始对函数进行基本的分析。 followFlow()，跟踪代码流程，并根据遇到的每句汇编指令生成原始的PCode。 printBlockTree()，打印出控制流结构体。 numCalls()，getCallSpecs()，可用来遍历函数内的call指令信息。 源码解读 1、initializeProcess函数(DecompInterface.java) -\u003e 2、decompProcess.registerProgram函数 文件 类 说明 DecompInterface.java DecompInterface 与反编译进程通讯的接口类 Program.java Program 用来表示一个完整的程序，包括内存、函数、标签、符号等。 代码分析 将汇编指令转换为OP指令 int4 Sleigh::oneInstruction(PcodeEmit\u0026 emit, const Address\u0026 baseaddr) const { SleighBuilder builder; try { builder.build(walker.getConstructor()-\u003egetTempl(), -1); pcode_cache.resolveRelatives(); pcode_cache.emit(baseaddr, \u0026emit); } catch (UnimplError\u0026 err) { ... } } FlowInfo::generateOps\r生成所有的op列表\rFlowInfo::setupCallSpecs\r根据类型为CPUI_CALL的opcode生成FuncCallSpecs。 ","date":"2021-08-09","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80/:0:1","tags":["Ghidra"],"title":"Ghidra反编译(一)","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80/"},{"categories":["C++开发"],"content":"​ 懒癌犯了，这里简要介绍一下吧。 ​ MinGw就是一个编译器，你可以理解为和Visual Studio差不多的一个玩意儿，只不过MinGw更原始质朴，Visual Studio则进行了大量封装。 ​ 比较好的下载地址是: https://www.mingw-w64.org/downloads/ https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win64/Personal Builds/mingw-builds/ https://github.com/niXman/mingw-builds-binaries/releases ​ 下载完成后，bin目录下有一个mingw32-make.exe程序，这个就是强大的make指令了，可以像linux上那样根据makefile文件进行make 编译。 mingw不同版本的区别 1、dwarf则只能用于32位程序 2、seh只能用于64位程序 3、sjlj适合32/64位程序，但是它会带来轻微的性能损失 win32，更接近windows原始api。posix，使用现代化api。 ","date":"2021-08-09","objectID":"/posts/c++%E5%BC%80%E5%8F%91/mingw/:0:0","tags":["MinGW"],"title":"MinGW编译器","uri":"/posts/c++%E5%BC%80%E5%8F%91/mingw/"},{"categories":["Github碎片"],"content":"​ 项目地址:zneak/x86doc: HTML representation of the Intel x86 instructions documentation ​ 作者将Intel官方的指令集PDF手册转换成了HTML文档，转换后的结果如下:http://www.felixcloutier.com/x86，可以很方便地进行查阅。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E6%96%87%E6%A1%A3/:0:0","tags":["指令集","x86","amd64"],"title":"Intel指令集文档","uri":"/posts/github%E7%A2%8E%E7%89%87/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E6%96%87%E6%A1%A3/"},{"categories":["Github碎片"],"content":"nlohmann json nlohmann/json: JSON for Modern C++ 这可能是github上star数目最多的一个json库了，只需要包含一个头文件即可快速将库添加至开发环境，并且简单易用，快速上手。 用了这个库后，我就再也没有用过其它的了。 缺点:好像只支持utf-8。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/json%E8%A7%A3%E6%9E%90%E5%BA%93/:0:1","tags":["json"],"title":"json解析库","uri":"/posts/github%E7%A2%8E%E7%89%87/json%E8%A7%A3%E6%9E%90%E5%BA%93/"},{"categories":["Github碎片"],"content":"URL Parser 解析引擎似乎存在Bug? hcs-url 似乎无法对有缺失的URL进行解析。 EdUrlParser 功能太简单了。 CxxUrl 兼容性似乎不太行。 Url Parser 需要引入Boost三方库 Simple Url Parser 各方面都不错，但是似乎设计的解析结果不太合理? homer Url Parser seomoz Url Parser URL Dedupe 懒得评测了。 LUrlParser 最终我选用的是这款，虽然功能依旧比较简单，无法满足我的需求。 但是感觉代码写得不错，简单易读，可拿来根据自己的需求进行改造。 ","date":"2021-07-27","objectID":"/posts/github%E7%A2%8E%E7%89%87/url%E8%A7%A3%E6%9E%90%E5%BA%93/:0:0","tags":["parser","URL"],"title":"URL解析库","uri":"/posts/github%E7%A2%8E%E7%89%87/url%E8%A7%A3%E6%9E%90%E5%BA%93/"},{"categories":["Github碎片"],"content":"​ 首先简单介绍一下kafka吧。 Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。 主要应用场景是：日志收集系统和消息系统。 Kafka主要设计目标如下： 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out:支持在线水平扩展 ​ 显然，有了这么牛逼的东西，我们可以对方便地存储数据和消费数据了，为了编写代码，我们需要用到kafka的第三方库。 ","date":"2021-07-26","objectID":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/:0:0","tags":["kafka"],"title":"kafka三方库","uri":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["Github碎片"],"content":"librdkafka 项目地址:https://github.com/edenhill/librdkafka 这玩意要是自己手动安装会比较累，因此这里推荐使用vcpkg进行安装，可以参考一下项目介绍中的命令行，可以很方便地得到所需要的库文件。 另外项目中作者也提供了很多用来学习的示例代码，参考这个东西就行了。 ","date":"2021-07-26","objectID":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/:0:1","tags":["kafka"],"title":"kafka三方库","uri":"/posts/github%E7%A2%8E%E7%89%87/kafka%E4%B8%89%E6%96%B9%E5%BA%93/"},{"categories":["QQ"],"content":"利用QQ群的查询接口来获取QQ群的一些信息。接口: https://qun.qq.com/cgi-bin/group_search/pc_group_search post数据: 传递值 说明 选项 keyword 关键字，可为QQ群号,QQ群名称 必填 wantnum 想要查询的个数 必填 from 来源，填1 必填 在发送请求时，需要携带好QQ的Cookie。 请求返回值示例如下: {\"ec\":0,\"errcode\":0,\"em\":\"\",\"keywordSuicide\":0,\"exactSearch\":1,\"gTotal\":1,\"endflag\":1,\"penetrate\":\"eyJwb3MiOjEsInAiOiJ7XCJyZWNvbW1lbmRcIjp0cnVlfSJ9\",\"usr_cityid\":null,\"exact\":1,\"group_list\":[{\"code\":633783602,\"owner_uin\":425063169,\"name\":\"E-debug兴趣小组\",\"class\":27,\"class_text\":\"\",\"dist\":null,\"face\":0,\"flag\":150995985,\"flag_ext\":2163040,\"geo\":null,\"gid\":633783602,\"latitude\":\"0\",\"level\":0,\"longitude\":\"0\",\"max_member_num\":500,\"member_num\":175,\"group_label\":[{\"item\":\"文件多\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"00cafc\"},{\"item\":\"管理员活跃\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"c573ff\"},{\"item\":\"男生多\",\"type\":3,\"text_color\":\"ffffff\",\"edging_color\":\"ff80ca\"}],\"memo\":\"E-debug Plus插件交流与反馈群.https:github.comfjqisbaE-debug-plus\",\"richfingermemo\":\"\",\"option\":2,\"app_privilege_flag\":67731665,\"url\":\"http:\\/\\/p.qlogo.cn\\/gh\\/633783602\\/633783602\\/140\",\"calc\":null,\"join_auth\":\"iGo2gTpSQ3GUGtZJkOrvSQCfjWanN9xTC0wCfnVGo0RRyc+kZC0llDIFthXkv0j1\",\"certificate_type\":0,\"certificate_name\":\"\",\"bitmap\":1024,\"labels\":[{\"label\":\"王者荣耀\",\"tagid\":\"1955f30159a44e2800005e21\",\"time\":1503940136},{\"label\":\"小学生\",\"tagid\":\"1955f30159a44e2d0000ab6a\",\"time\":1503940141},{\"label\":\"PUBG\",\"tagid\":\"1955f3015a3a53fb0000dc32\",\"time\":1513772027}],\"uin_privilege\":1,\"activity\":9,\"cityid\":10282,\"qaddr\":[\"江西省\",\"上饶市\"],\"gcate\":[\"人物\"]}]} 其中group_list.option这个值表示QQ群的加群方式，有以下几种: option1:允许任何人加群 option2:需要验证消息 option4:需要正确回答问题 option5:需要回答问题并由管理员审核 ","date":"2021-07-23","objectID":"/posts/qq/qq%E7%BE%A4%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/:0:0","tags":["协议逆向"],"title":"QQ群查询信息协议","uri":"/posts/qq/qq%E7%BE%A4%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/"},{"categories":["QT"],"content":"​ Qt中控件中的弹出菜单(ContextMenu)，依据ContextMenuPolicy的值的不同，有五种形式： 一、无菜单 此时,ContextMenuPolicy的值为Qt::NoContextMenu 二、默认菜单 此时，ContextMenuPolicy的值为Qt::DefaultContextMenu，这是默认值，其将显示控件定义的默认菜单 三、由Action定义菜单 此时，ContextMenuPolicy的值为Qt::ActionsContextMenu,要为此部件定义这种菜单，很简单，只要把已经定义好的Action部件插入到要显示此菜单的部件中，部件将自动按顺序显示菜单。 QWidget::addAction(QAction *action); 四、自定义菜单 此时，ContextMenuPolicy的值为Qt::CustomContextMenu，这回，有两种方式来定义菜单，一种是响应 customContextMenuRequested(const QPoint\u0026)这个signal，在响应的槽中显示菜单(QMenu的exec()方法)。第二种是需要从这个部件的类中派生一个类，重写contextMenuEvent()这个函数显示菜单(QMenu的exec()方法显示)。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/:0:0","tags":["入门","新手教程"],"title":"QT控件中的菜单","uri":"/posts/qt/qt%E6%8E%A7%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"categories":["QT"],"content":"在QT的开发中，免不了要用到列表(QListWidget)这个控件。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:0","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["QT"],"content":"一、初始化表格 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:1","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["QT"],"content":"信号大全 QListWidget控件的信号 void itemPressed(QListWidgetItem *item); void itemClicked(QListWidgetItem *item); void itemDoubleClicked(QListWidgetItem *item); void itemActivated(QListWidgetItem *item); void itemEntered(QListWidgetItem *item); void itemChanged(QListWidgetItem *item); void currentItemChanged(QListWidgetItem *current, QListWidgetItem *previous); void currentTextChanged(const QString \u0026currentText); void currentRowChanged(int currentRow); void itemSelectionChanged(); itemPressed，当在项目上按下鼠标按钮时，此信号随指定项目一起发出 。 itemClicked，当在项目上单击鼠标按钮时，此信号随指定项目一起发出。 itemDoubleClicked，当在项目上双击鼠标按钮时，此信号随指定项目一起发出。 itemActivated，当项目被激活时发出这个信号。 当用户单击或双击它时，该项目将被激活，具体取决于系统配置。 当用户按下激活键时它也会被激活（在 Windows 和 X11 上这是返回键，在 Mac OS X 上是 Command+O）。 itemEntered，当鼠标光标进入一个项目时发出这个信号，item指针指向进入的项目。 此信号仅在mouseTracking选项开启，或者在鼠标光标移动进入项目的过程中按下鼠标按钮时发出。 itemChanged，每当 item 的数据发生变化时，就会发出此信号。 currentItemChanged，每当当前选中项发生改变时就会发出此信号。 previous 是先前具有焦点的项目； current 是新的当前项目。 currentTextChanged，每当当前选中项发生改变时就会发出此信号。 currentText 是当前选中项中的文本数据。 如果当前项为空，则 currentText 无效。 currentRowChanged，每当当前选中项发生改变时就会发出此信号。currentRow是当前项的行，如果没有当前项，则为-1。 itemSelectionChanged，每当当前选中项发生改变时就会发出此信号。 ","date":"2021-07-15","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/:0:2","tags":["ListWidget","新手教程","QT"],"title":"QT组件之QListWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqlistwidget/"},{"categories":["杂文"],"content":"1.注册表检测 [HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\BIOS] “SystemManufacturer”=“VMware, Inc.” 根据SystemManufacturer中的内容计算出一个hash值，判断是否为0x6A7BDBF4。 可以通过修改注册表来绕过此检测。 2.特权指令检测 通过以下代码来检测是否在虚拟机内 bool IsInsideVMWare() { bool rc = true; __try { __asm { push edx push ecx push ebx mov eax, ‘VMXh’ mov ebx, 0 // 将ebx设置为非幻数’VMXH’的其它值 mov ecx, 10 // 指定功能号，用于获取VMWare版本，当它为0x14时用于获取VMware内存大小 mov edx, ‘VX’ // 端口号 in eax, dx // 从端口dx读取VMware版本到eax //若上面指定功能号为0x14时，可通过判断eax中的值是否大于0，若是则说明处于虚拟机中 cmp ebx, ‘VMXh’ // 判断ebx中是否包含VMware版本’VMXh’，若是则在虚拟机中 setz [rc] // 设置返回值 pop ebx pop ecx pop edx } } __except(EXCEPTION_EXECUTE_HANDLER) //如果未处于VMware中，则触发此异常 { rc = false; } return rc; } 目前没有找到什么好办法，可以在虚拟机vmx文件中加入以下配置绕过检测: monitor_control.restrict_backdoor = TRUE 但这样有一个缺点就是会使Vmware Tools工具失效。 3.vpcext指令检测 DWORD __forceinline IsInsideVPC_exceptionFilter(LPEXCEPTION_POINTERS ep) { PCONTEXT ctx = ep-\u003eContextRecord; ctx-\u003eEbx = -1; // Not running VPC ctx-\u003eEip += 4; // skip past the \"call VPC\" opcodes return EXCEPTION_CONTINUE_EXECUTION; // we can safely resume execution since we skipped faulty instruction } // high level language friendly version of IsInsideVPC() bool IsInsideVPC() { bool rc = false; __try { _asm push ebx _asm mov ebx, 0 // Flag _asm mov eax, 1 // VPC function number // call VPC _asm __emit 0Fh _asm __emit 3Fh _asm __emit 07h _asm __emit 0Bh _asm test ebx, ebx _asm setz [rc] _asm pop ebx } // The except block shouldn't get triggered if VPC is running!! __except(IsInsideVPC_exceptionFilter(GetExceptionInformation())) { } return rc; } 这套代码是用来检测VPC虚拟机的，Vmware不用管。 4.cpuid指令检测 据说是检测cpuid一号功能 ecx的最高位。 .vmx文件中添加下面配置可绕过检测。 cpuid.1.ecx = \"0111:1111:1101:1010:1111:1011:1011:1111\" 有一些AMD处理器的电脑似乎不支持上面的配置，修改后会无法正常启动虚拟机。这个时候添加下面的代码: hypervisor.cpuid.v0 = \"FALSE\" 参考资料 sanbarrow.com 绕过SE的虚拟机检测 ","date":"2021-07-04","objectID":"/posts/%E6%9D%82%E6%96%87/se%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/:0:0","tags":["SafeEngine"],"title":"SE过虚拟机检测流程","uri":"/posts/%E6%9D%82%E6%96%87/se%E8%BF%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B/"},{"categories":["杂文"],"content":"​ x64Dbg的Ctrl+G功能，有的时候能够自动补全Api名称，有的时候不行，我一开始没太注意这个功能，后来观察x64Dbg的源码才发现，作者设置了x32Dbg.ini两个配置项，CaseSensitiveAutoComplete和DisableAutoComplete。 CaseSensitiveAutoComplete：用来设置补全功能是否大小写敏感。 DisableAutoComplete：是否禁用自动补全功能。 将这两个配置项都设置为0就好了。 ​ ","date":"2021-07-04","objectID":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%BC%80%E5%90%AF%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/:0:0","tags":["x64Dbg"],"title":"x64Dbg开启补全功能","uri":"/posts/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/x64dbg%E5%BC%80%E5%90%AF%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/"},{"categories":["产品试用"],"content":"​ 在起手开发一个程序的时候，我们总是想先决定好程序的图标，毕竟只有图标选好了，程序的代码才放心敲下去不是吗？ 图标素材库 https://www.flaticon.com http://flat-icon-design.com http://www.fontawesome.com.cn/ 将任意图片转成ico格式的工具:https://icofx.ro 在线抠图 https://www.shiliuai.com/koutu/ 在线PS https://www.photopea.com/ ","date":"2021-06-30","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E5%9B%BE%E6%A0%87%E8%AE%BE%E8%AE%A1/:0:0","tags":["开发","图标"],"title":"图标设计","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E5%9B%BE%E6%A0%87%E8%AE%BE%E8%AE%A1/"},{"categories":["易语言逆向"],"content":"通用的函数特征对于易语言程序来说肯定是不行的， 因此必须定制一套独立的特征码识别引擎。 ","date":"2021-05-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/:0:0","tags":["IDA","特征码","易语言"],"title":"易语言模块函数特征码识别","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"categories":["易语言逆向"],"content":"调研易语言用户函数 1、易语言用户函数必定是以下几条指令开头 push ebp\rmov ebp,esp 如果函数内含有局部变量，那么编译器便会通过下列指令申请变量空间，指令会紧跟着易语言函数头。 sub esp,0x4 局部变量初始化指令会紧跟着申请局部变量空间指令，默认数据类型都是初始化为0 mov dword ptr ss:[ebp-0x4],0x0\rmov dword ptr ss:[ebp-0x8],0x0\rmov dword ptr ss:[ebp-0xC],0x0 2、易语言用户函数必定是以下几条指令结尾 mov esp,ebp\rpop ebp\rret xxx 3、关于易语言函数特征的生成顺序 在函数体内没有call的情况下，跳转指令也当成普通指令，从函数头到尾依次往下生成特征。 为了防止出现递归分析的状况，因此制定这样一条规则： 如果函数是第一次分析，那么该函数使用计算后的MD5作为特征，否则使用函数索引作为特征。 函数索引就是函数出现的顺序，每遇到函数自增加一。 ","date":"2021-05-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/:0:1","tags":["IDA","特征码","易语言"],"title":"易语言模块函数特征码识别","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"categories":["易语言逆向"],"content":"对指令进行种类划分 为什么不站在易语言编译器的角度，而只站在汇编的角度对指令进行划分? 因为表面上看易语言编译器已经十多年没更新过，但仍无法排除未来有一天会更新的可能，站在汇编的角度才是真正的永恒。 1、灵活的单操作数指令 push、inc、dec 特点是它们都支持以下几种形式的用法 inc eax\rinc [eax]\rinc [0x401000]\rinc [eax+ebx*4+0x401000] 其中push指令额外多一种用法push 0x401000，但是不影响划分。 2、灵活的双操作数指令 add、sub、mov 特点是它们都支持以下几种形式的用法 sub eax,0x1\rsub eax,ebx\rsub dword ptr[eax],0x1\rsub dword ptr[0x401000],1\rsub dword ptr[eax+ebx*4+0x401000],0x1 ","date":"2021-05-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/:0:2","tags":["IDA","特征码","易语言"],"title":"易语言模块函数特征码识别","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"categories":["易语言逆向"],"content":"指定特征生成规则 1、特征生成的一个难点是区分数据和代码。 例如，push 0x401000这条指令，根本无法区分0x401000是一个常数，还是一个数据地址。 2、先制定一套指令模板规则，在模板规则基础上增加强化规则。 例如，可能有多个函数满足模板规则，在模板规则上不同的强化规则可满足识别任意函数。 3、我比较懒，个人力量比较弱，所以规则肯定是建立在txt或者sqlite上，这样比较好修改呢。我个人还是倾向于txt吧。 格式应该是这样吧: 特征函数1:c4ca4238a0b923820dcc509a6f75849b,\u003c1,push,55664477889911223374456456465\u003e\r特征函数2:28c8edde3d61a0411511d3b1866f0636,\u003cstart+60,none,2333333\u003e 首先是函数名字，然后是函数模板，最后是特征规则。 特征函数1规则:第一条指令是push指令，且push的常量数据是后面的二进制 特征函数2规则:函数头偏移60的位置数据233333。 有这两种规则，应该能表示大多数函数了吧。 4、call这条指令太烦人了。。。到底如何才能解决掉这种东西？？？去它大爷的，用call来对付call。 call func0\r{\r1.1,push ebp\r1.2,mov esp,ebp\r1.3,call func1\r{\r2.1,push const\r2.2,call func0\r2.3,ret\r}\r1.4,call func2\r{\r2.4,mov eax,[const + ecx * 4]\r2.5,ret\r}\r1.5 jnz +0x60\r1.6,mov eax,const\r1.7,mov ebp,esp\r1.8,ret 0x4\r} 文本型局部变量赋值 易语言的文本型变量，可以理解为const char*，因此常量赋值无需拷贝，直接传递eax即可。 mov eax,0x47B2FB 如果是变量赋值给一个另外一个变量，那么易语言会通过以下指令进行拷贝。 mov eax,dword ptr ss:[ebp-0x4]\rtest eax,eax\rje short $+18\rpush eax\rmov ebx,eax\rcall Strlen //获取字符串长度\rinc eax\rpush eax\rcall AllocMemory //申请新内存\rpop ecx\rpop esi\rmov edi,eax\rrep movs byte ptr es:[edi],byte ptr ds:[esi] //字符串拷贝 字节集局部变量赋值 易语言的字节集类型变量，本质上是一块存储了大小的Buffer，常量可通过直接传递eax来进行赋值。 mov eax,0x47B2B3 如果是变量赋值给一个另外一个变量，那么易语言会通过以下指令进行拷贝。 test eax,eax 易语言的类 push 0x4\rcall malloc\radd esp,0x4\rmov var,eax\rmov ebx,eax\rmov dword ptr ds:[ebx],0x0\rmov dword ptr ds:[ebx],classVt 1.类的构造函数不在虚表中，而会直接以call的形式进行调用。类的析构函数是虚表中的第一个函数。 2.如果类含有继承类，那么这两个类函数合并使用一张虚表，构造函数 = 父类构造函数 + 子类构造函数。 类的析构函数同样是虚表中的第一个函数，析构函数 = 子类的析构函数 + 父类的析构函数。 ","date":"2021-05-22","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/:0:3","tags":["IDA","特征码","易语言"],"title":"易语言模块函数特征码识别","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"categories":["反编译"],"content":"递归下降分析法 如果我们需要对某一段代码进行流程分析，那么首先需要思考一下这些代码有什么特点。 这些代码有一个非常重要的特点是，cpu执行指令的时候默认逻辑是按照地址从上往下执行的. 我们可以根据这个特定，来制定一个递归下降分析代码的算法。 首先，对cpu指令进行以下几种分类: 普通指令(push,call) 无条件跳转指令(jmp) 条件跳转指令(jcc) 结束指令(ret) 分析引擎的关键点如下: 1、循环从地址分析队列中取出最新的一个地址，进行解析，直到分析队列为空。 2、如果当前地址所处的指令为普通指令，压入此指令的下一条指令至分析队列，结束分析。 如果当前地址所处的指令为无条件跳转指令，压入此指令的跳转地址至分析队列，结束分析。 如果当前地址所处的指令为条件跳转指令，压入此指令的跳转地址和此指令的下一条指令至分析队列，结束分析。 如果当前地址所处的指令为结束指令，结束分析 3、分析地址的时候需要对已分析过的地址进行记录，由于我们是按照指令的执行顺序递归向下进行分析的，那么不难得出如果一个地址已经分析过，这个地址后面的所有地址必然全都分析过的结论。 通过上面这几点，我们很容易编写出一个简单的流程分析引擎。 另外我们还需要对代码进行分块，那么就需要了解到一些关于基本块(BasicBlock)的基本概念。 BasicBlock定义: 只有一个入口指令，一个出口指令 执行时从入口指令进入，从出口指令退出 基本块的一个典型特点是：只要基本块中第一条指令被执行了，那么基本块内的代码都将按照顺序执行有且仅有一次。 划分BasicBlock的关键点: 1、在上述分析引擎的基础上，按照顺序进行指令分析。 2、如果当前地址是普通指令，且不在任何基本块中，则添加当前地址至当前的基本块中，继续向下分析。 如果当前地址是是普通指令，但已处于某个基本块中，则结束分析。 如果当前地址是跳转指令,且跳转地址在已生成的Block代码之内，则将之前的Block块分割成至多两块。 如果当前地址是跳转指令,且跳转地址不在基本块中，则结束当前的Block，并将新地址作为Block的头部。 如果当前地址是结束指令，结束分析。 3、代码是否处于基本块中与代码是否分析过等价。 必经节点(dominators) 在程序流图中，对任意两个节点m和n，如果从流图的首节点出发，到达n的任一通路都要经过m，则称m是n的必经节点，记为m DOM n。 回边(back edge) 假设a-\u003eb是流图中的一条有向边，如果b DOM a，则称a-\u003eb是流图中的一条回边。 ","date":"2021-05-16","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/:0:1","tags":["Branch"],"title":"反编译之分支流程图的生成","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/"},{"categories":["反编译"],"content":"基本分支类型 1、第一种是if，流程图如下: 2、第二种是if-else，流程图如下: 3、第三种是do-while，流程图如下: 4、第四种是while-do，流程图如下: 5、第五种是switch，流程图如下: ","date":"2021-05-16","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/:0:2","tags":["Branch"],"title":"反编译之分支流程图的生成","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E5%88%86%E6%94%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/"},{"categories":["CTF"],"content":"第一题 拜师学艺 软件有一段内存解密代码，将解密后的EXE DUMP出来，看到一个字符串ZmxhZ3trYW54dWV9，结合算法猜测是BASE64算法，解密后得到flag{kanxue}，测试通过即得解。 ","date":"2021-05-11","objectID":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/:1:0","tags":["看雪CTF","Windows逆向"],"title":"看雪2021 KCTF春季赛","uri":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/"},{"categories":["CTF"],"content":"第二题 南冥神功 从最后判断的结果往上寻找逻辑，从下面这段代码我们可以得到以下信息： 1.存在一张大小为90字节的Table_Misc表，这张表一开始有些数据为0，有些数据不为0。 2.最终要使得这张表里面的数据全部不为0，才能通过校验。 再结合中间的逻辑代码，推测这很可能是迷宫求解，最后理解出题目的意思如下: 这张大小90字节Table_Misc表，对应的是一个9x10的迷宫，数据为1的部分不可通过，为0则表示可通过，我们的初始下标是(0,0)，需要走过整个迷宫，期间不得重复路线，求路线解。 将迷宫整理如下: ***#**##**\r*##**#*#*#\r**####*#*#\r##*###*#*#\r**#**#**##\r*##*#**#**\r**#*#####*\r##**#**#**\ro*#**#**## 代码中的switch case分支可以转换为以下的移动规则: 0:如果上一个格所在行是奇数，则向下移动一格，如果上一个所在行是偶数，则向右下移动一格。 1:向右移动一格。 2:如果上一个格所在行是奇数，则向上移动一格；如果上一格所在行是偶数，则向右上移动一格。 3:如果上一个格所在行是偶数，则向上移动一格；如果上一格所在行是奇数，则向左上移动一格。 4:向左移动一格。 5:如果上一个格所在行是偶数，则向下移动一格，如果上一格所在行是奇数，则向左下移动一格。 我们输入的flag每个字符可以转换为迷宫的两个移动规则，最后人工看图求解迷宫，得出移动步骤，再编写代码将步骤转换回flag。 char Table_seed[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char StepindexToAlpha(unsigned int nIndex, unsigned char firstStep, unsigned char secondStep) { char ret = 0; for (unsigned int n = 0; n \u003c 36; ++n) { unsigned char result_firstStep = 5 - ((n + nIndex) % 6); unsigned char result_secondStep= (nIndex + n / 6) % 6; if (result_firstStep == firstStep \u0026\u0026 result_secondStep == secondStep) { return Table_seed[n]; } } return ret; } int main() { unsigned char buff_Step[] = { 1,2,3,4,3,2,1,2, 3,4,3,2,1,1,0,1, 2,1,0,0,5,0,5,4, 3,4,5,0,5,0,1,2, 1,0,1,2,1,2,3,4, 3,2,2,3,2,1 }; std::string flag; int n = 0; int nStep = 0; while (n \u003c sizeof(buff_Step)) { char tmp = StepindexToAlpha(nStep, buff_Step[n], buff_Step[n + 1]); flag = flag + tmp; nStep = nStep + 1; n = n + 2; } std::cout \u003c\u003c flag.c_str() \u003c\u003c std::endl; return false; } ","date":"2021-05-11","objectID":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/:2:0","tags":["看雪CTF","Windows逆向"],"title":"看雪2021 KCTF春季赛","uri":"/posts/ctf/%E7%9C%8B%E9%9B%AA2021-kctf%E6%98%A5%E5%AD%A3%E8%B5%9B/"},{"categories":["QQ"],"content":"因为工作需要，需要对QQ群文件协议进行逆向分析。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:0","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"1.分析准备流程 首先我们要知道QQ群文件的静态页面网址是https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602， 其中gid这个值就是QQ群号。 我们正常情况下访问这个页面是一片空白，因为缺少QQ登录的Cookie，这个时候我们需要到QQ群官网 登录一下我们的QQ，然后再访问静态页面，就会发现能看到QQ群内的群文件，可以开始进行协议分析了。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:1","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"2.BKN算法 在分析的过程中，会遇到一个重要的参数BKN，我们其实不必理解这个参数有什么含义，只需要找到值的来源就行了。算法很简单，由Cookie中的skey转换得到，算法如下: function getBKN(skey) { var hash = 5381; for (var n = 0, len = skey.length; n \u003c len; ++n) hash += (hash \u003c\u003c 5) + skey.charCodeAt(n); return hash \u0026 2147483647 }; ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:2","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"3.获取群文件列表 请求协议如下: Request URL:https://pan.qun.qq.com/cgi-bin/group_file/get_file_list?gc=633783602\u0026bkn=xxxx\u0026start_index=0\u0026cnt=50\u0026filter_code=0\u0026folder_id=%2F\u0026show_onlinedoc_folder=1 referer:https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602 cookie:skey=xxxx gc就是QQ群号，bkn是根据cookie中的skey转换得到的值，cnt是显示的群文件个数。 返回的数据如下: { \"ec\": 0, \"file_list\": [ { \"create_time\": 1620539743, \"id\": \"\\/5637b4d6-1216-4d84-bbbe-579d4c65f6e2\", \"modify_name\": \"💀\", \"modify_time\": 1620539743, \"modify_uin\": 425063169, \"name\": \"新建文件夹\", \"owner_name\": \"💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"size\": 0, \"type\": 2 }, { \"bus_id\": 104, \"create_time\": 1620539142, \"dead_time\": 1621403742, \"download_times\": 2, \"id\": \"\\/5fc46b55-5ff8-47dc-bf2a-7171752843e9\", \"local_path\": \"\", \"md5\": \"3f26d3be679d81b5d9bd4fdf046d3eed\", \"modify_time\": 1620539144, \"name\": \"VMware.exe\", \"owner_name\": \"﻿﻿﻿💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"safe_type\": 0, \"sha\": \"d52d301385647f4dab3fee94734534a0385c22147c\", \"sha3\": \"\", \"size\": 241597204, \"type\": 1, \"upload_size\": 241597204 }, { \"bus_id\": 102, \"create_time\": 1618906774, \"dead_time\": 0, \"download_times\": 3, \"id\": \"\\/9366e551-cb4e-49c5-922a-17bc25f6cc3e\", \"local_path\": \"\", \"md5\": \"d9a985b55c724f4912fe5f80e21463aef3\", \"modify_time\": 1618906775, \"name\": \"VMOS.APK\", \"owner_name\": \"💀\", \"owner_uin\": 425063169, \"parent_id\": \"\\/\", \"safe_type\": 0, \"sha\": \"b4de8c3c29f4911bae322ea2c2fc5c306ca8c9ec43\", \"sha3\": \"\", \"size\": 15365031, \"type\": 1, \"upload_size\": 15365031 }, ], \"next_index\": 50, \"open_flag\": 0, \"total_cnt\": 63, \"user_role\": 2 } bus_id推测表示文件的类型，102表示是永久文件，104表示是缓存文件。 id表示文件的唯一ID，比较重要的一个值。 total_cnt表示群内文件的总数。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:3","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["QQ"],"content":"4.获取文件下载地址 请求协议如下: Request URL:https://pan.qun.qq.com/cgi-bin/group_share_get_downurl?uin=425063169\u0026groupid=633783602\u0026pa=%2F102%2F9366e551-cb4e-49c5-951a-17bc25f6cc3e\u0026charset=utf-8\u0026g_tk=xxxx referer:https://pan.qun.qq.com/clt_filetab/groupShareClientNew.html?gid=633783602 cookie:skey=xxxx uin是我们的QQ号。 groupid是QQ群号。 pa其实是文件的bus_id和id的组合路径。 g_tk的值等于bkn。 结果如下: { \"code\": 0, \"data\": { \"cookie\": \"6138633965635533\", \"dns\": \"tj-ctfs.ftn.qq.com\", \"ismember\": 1, \"md5\": \"d9a985b50d4f4912fe5f80e21463aef3\", \"ret\": 0, \"sha\": \"b4de8c3c29f4911bae322ea2c2fc006ca8c9ec43\", \"sha3\": \"\", \"sip\": \"133.150.76.225\", \"url\": \"http:\\/\\/tj-ctfs.ftn.qq.com\\/ftn_handler\\/daab4b510d965064e12d4586ad5e2967167c95610b0188f29f5655fa607f83aa6f29326e8cf806300b4d2a8f11c0756601abc5698bf8df4ff4896f0865c08ccb\" }, \"default\": 0, \"message\": \"\", \"subcode\": 0 }); url是文件的下载地址直链。 ","date":"2021-05-09","objectID":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/:0:4","tags":["协议逆向"],"title":"QQ群文件协议","uri":"/posts/qq/qq%E7%BE%A4%E6%96%87%E4%BB%B6%E5%8D%8F%E8%AE%AE/"},{"categories":["易语言逆向"],"content":"注意:本文所说的PUSH进入窗体，是指忽略程序的一般功能，目的只是为了进入窗体。 ","date":"2021-04-28","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/:0:0","tags":["IDA"],"title":"易语言程序万能进入主窗体","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/"},{"categories":["易语言逆向"],"content":"PUSH窗口 PUSH窗体其实比较简单，一般我们只需要在载入或者载入启动窗口这个函数上下断点就可以了，之后修改此命令的参数，将原先的窗体ID修改为我们想要进入的窗体ID即可。 之后观察是否能够进入窗体，如果能进，那么直接PUSH成功！ 不能成功的话，有可能是以下几种情况: 窗口载入后的窗口_创建完毕，或者窗口_首次激活等事件中有额外的代码处理。 窗口已经成功载入了，只不过是不可视的。 窗体时钟周期事件中有额外的代码处理。 如果是第一种情况，我们只需要将这些事件统统都干掉即可。 如果是第二种情况，我们需要找到窗体的可视属性在资源中位置，修改为真即可。 ","date":"2021-04-28","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/:0:1","tags":["IDA"],"title":"易语言程序万能进入主窗体","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%87%E8%83%BDpush/"},{"categories":["易语言逆向"],"content":"基础介绍 通过寻找易语言静态编译的程序规律，我们可以找到一处结构体，寻找的特征码是50 64 89 25 00 00 00 00 81 EC AC 01 00 00 53 56 57，找到后这个结构体大概是下面这个样子: struct EHead { unsigned int dwMagic; //未知,值固定为3 unsigned int szNone2; //未知,值固定为0 unsigned int szNone3; //未知,好像是个随机数,修改不影响程序 unsigned int lpStartCode; //用户代码起始地址,不可修改 unsigned int lpEString; //常量资源,如果没有常量资源,则为0 unsigned int dwEStringSize; //常量资源大小,如果没有常量资源,则为0 unsigned int lpEWindow; //创建组件信息 unsigned int dwEWindowSize; //创建组件信息大小 unsigned int dwLibNum; //支持库数量 unsigned int lpLibEntry; //支持库信息入口 unsigned int dwApiCount; //Api数量 unsigned int lpModuleName; //指向模块名称 unsigned int lpApiName; //指向Api名称 }; 可以看到这些结构体包含着易语言程序中的很多重要数据，今天我们要研究的是界面资源部分。 易语言所有的GUI信息都放在lpEWindow这个指针所指向的位置，dwEWindowSize则为信息的总大小，通过对这个信息进行解析，理论上我们可以还原与易语言IDE中几乎一模一样的控件设计。 具体解析规则，我就懒得介绍了，请自行参考E-Decompiler 源码中的GuiParser::ParseGUIResource函数。通过不断尝试进行拆解还原，我们最终大概可以看到这样一个结构: 窗口结构 每个窗口都是一棵树，窗口内的控件则为这个树的子节点，不难理解，通过窗口ID -\u003e 控件ID，我们就能对应到每个控件了。其中值得说明的是窗口本身也属于控件，每个窗口的第一个控件就是窗口控件。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:1","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件类型 控件类型 在上图中我们可以看到，窗口.取窗口句柄()这样一个命令的参数中，0x52010001表示控件所属窗口ID，0x6010000表示控件ID，而0x10001这个参数则表示控件的类型ID。 每个控件都有一个控件类型ID，比如窗口的控件类型ID是0x10001，按钮的控件类型是0x1000B。 这个控件类型ID是有规律的，因为易语言有一个支持库机制，我们不妨看看易语言核心支持库的介绍: 提供了51种库定义数据类型，提供了686种命令，提供了335个库定义常量 而编辑框、按钮这些控件就属于核心支持库中的数据类型的一部分，控件ID中的高四位对应的是控件所属支持库在易语言程序中的加载顺序，低四位对应的则是控件在所属支持库中的数据类型数组中的下标，因此窗口控件ID0x10001表示的含义其实是程序所加载的第一个支持库中的第一种控件。 由于系统支持库默认最先加载，所以核心支持库中的控件的高四位必定是1。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:2","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件属性 在易语言中，属性可以分基本属性和附加属性两种，像左边、顶边、宽度、高度这些几乎每个控件都有的属性就属于基本属性了，这些字段每个控件排列顺序、排列方式都是一样的，我们可以通用解析。基础属性之后跟着的则是每个控件独特的附加属性，以序列化的形式存储，因此如果我们想要把这些属性还原出来，就必须对每个控件的属性进行反序列化解析。 另外，易语言为了节省空间，控件的附加属性都有一个默认值，即如果控件在IDE中的附加属性未进行任何改动，那么控件的信息结构中，附加属性字段占用大小为0。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:3","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"控件事件 事实上，控件的事件属于控件基本属性的一部分，事件的结构体很简单: struct ControlEvent { int EventIndex; //事件索引 uint32 EventOffset; //事件地址便宜 }; EventIndex表示事件类型，EventOffset值等于事件地址相对于用户代码起始地址的偏移。 每个控件都有自己的一张事件列表，例如0表示窗口_创建完毕事件，1表示窗口_可否被关闭事件。 控件的属性，2112 =\u003e ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:4","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"总结 其实还有一些细节，像子控件、父控件，菜单控件之类的，由于作者太懒也没有进行介绍，本文只是一个科普贴。。。。。。 啥也不说了，都在代码里。 ","date":"2021-04-27","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/:0:5","tags":["IDA"],"title":"解析易语言窗口控件资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6%E8%B5%84%E6%BA%90/"},{"categories":["C++开发"],"content":"​ 虽然很久以前在还原C++代码的时候就已经接触到工厂类这个概念了，但是其实由于懒得理解，所以一直处于一知半解的状态，直到我今天写代码遇到了一个实际问题，并且发现这个问题的答案似乎工厂类是最优解的时候，我才终于领悟了工厂类的核心思想。 试想这样一个问题:存在100个类 class A,B,C,D,E….，这100个类继承基础类class base，而class base存在一个纯虚函数void func()，那么 ","date":"2021-04-19","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%9D%99%E6%80%81%E7%B1%BB/:0:0","tags":["高级C++"],"title":"C++工厂类","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%9D%99%E6%80%81%E7%B1%BB/"},{"categories":["QT"],"content":"QT工程转换为Visual Studio工程 打开QT 命令行工具，使用如下命令，得到工程文件 qmake -r -tp vc xx.pro ","date":"2021-04-18","objectID":"/posts/qt/qt%E7%AC%94%E8%AE%B0%E6%9C%AC/:0:0","tags":["入门","新手教程"],"title":"QT笔记本","uri":"/posts/qt/qt%E7%AC%94%E8%AE%B0%E6%9C%AC/"},{"categories":["C++开发"],"content":"使用函数指针作为参数 例如某个函数 int func(string arg); 将函数表示为参数的形式为int(*)(string); 如果非要带上个参数的话，那么是int(* funcDef)(string); 定义一个常量字符串数组 声明一个const char*数组即可，这使得每个元素都是一个char指针，并且指针会指向常量字符串。 const char * cities[5]= { \"Gribble City\", \"Gribbletown\", \"New Gribble\", \"San Gribble\", \"Gribble Vista\" }; 原始字符串 原始字符串是C++ 11新增的一个功能，一般被用来处理那些反人类的转义字符。语法为R\"(text string)\"，所见即所得。 cout \u003c\u003c R\"(I print '\\', \"\\n\" as I like.)\" \u003c\u003c endl; 查看类的关系图 在阅读大型项目源码的时候，使用Visual Studio中的生成类图功能能帮助我们快速了解代码。 首先需要安装此功能，在Visual Studio Installer中选择其他工具集-\u003e Visual Studio扩展开发，勾选右侧安装详细信息中的类设计器，安装完成之后重启电脑。 如果需要一次性生成项目中的所有类关系图，可以尝试对项目右键选择查看-\u003e查看类图，如果生成类图失败，我们可以手动将所有的类头文件筛选出来，再批量选中右键选择查看类图。 如果想要将类图保存下来，可以在类图上右键选择将关系图导出为图像，如果类图过大，导出来的图片可能会很模糊，这个时候只能选择导出增强的图元文件格式(*.emf)。 进程入口点的源码 熟悉逆向的我们知道，我们在源码中看到的main函数并非一个进程的原始入口点，真实的入口处源码参考exe_common.inl。 ","date":"2021-04-13","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/:0:0","tags":["C++"],"title":"C++常用知识","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"categories":["静态分析"],"content":"解除函数名称的限制 默认配置情况下我们是不能将函数名称修改为中文的，会提示bad character，意思就是包含非法字符，那么怎样让中文成为合法的字符呢？ 通过在网上查找资料，这个合法字符的定义在ida.cfg文件中，我们定位到文件，搜索Block_CJK_Unified_Ideographs，如下图所示: // the following characters are allowed in user-defined names: NameChars = \"$?@\" // asm specific character \"_0123456789\" \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\", // This would enable common Chinese characters in identifiers: // Block_CJK_Unified_Ideographs, CURRENT_CULTURE; 我们去掉Block_CJK_Unified_Ideographs这一行前面的注释，就可以给函数名字起中文了。 ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:1","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["静态分析"],"content":"解除IDA反汇编代码限制 虽然通过上述操作函数可以起名为中文，但是实际上使用F5功能的时候，得到的伪代码，中文函数名称却会变成下划线，如下图所示: 中文变成下划线 通过对IDA进行逆向得知，原来hexray在生成伪代码的时候会调用一个calc_c_cpp_name函数，该函数会试图针对C/C++的函数名称进行优化，结果却误伤中文字符，我们将此处代码给NOP掉，就可以了。 合法化名称 ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:2","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["静态分析"],"content":"最终效果 我已制作Patch好的DLL ，替换后效果如下: 中文函数 ","date":"2021-04-10","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/:0:3","tags":["IDA"],"title":"IDA7.5支持中文的办法","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/ida%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%87%BD%E6%95%B0%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8A%9E%E6%B3%95/"},{"categories":["QT"],"content":"在QT的开发中，免不了要用到表格(QTableWidget)这个控件。 ","date":"2021-04-05","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/:0:0","tags":["TableWidget","新手教程","QT"],"title":"QT组件之QTableWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/"},{"categories":["QT"],"content":"一、初始化表格 设置基本属性 ui.FileTableWidget-\u003esetColumnCount(2); //设置列数 ui.FileTableWidget-\u003esetColumnWidth(0, 100); //设置第一列宽度 ui.FileTableWidget-\u003esetColumnWidth(1, 300); //设置第二列宽度 //使行列头自适应宽度，最后一列将会填充空白部分 ui.FileTableWidget-\u003ehorizontalHeader()-\u003esetStretchLastSection(true); //使行列头自适应宽度，所有列平均分来填充空白部分 ui.FileTableWidget-\u003ehorizontalHeader()-\u003esetResizeMode(QHeaderView::Strtch); //设置表头标题 ui.FileTableWidget-\u003esetHorizontalHeaderLabels(QStringList()\u003c\u003c\"property\"\u003c\u003c\"value\"\"); //设置选中的模式,有禁止选择、单选、多选等5种模式 ui.tableView-\u003esetSelectionMode(QAbstractItemView::ExtendedSelection); //设置整个表格不可被编辑 ui.tableView-\u003esetEditTriggers(QAbstractItemView::NoEditTriggers); //设置某一列不可编辑 QTableWidgetItem *item1 = new QTableWidgetItem(“xxx”); item1-\u003esetFlags(item1-\u003eflags() \u0026 (~Qt::ItemIsEditable)); ui-\u003etableView-\u003esetItem(i, 0, item1); 添加代理 如果我们想让表格中的单元不仅仅是显示文本，而是其他的控件，例如编辑框、复选框等，这个时候我们就得使用代理了，可以给所有的单元添加代理控件: //给所有的单元添加代理控件 ui.tableView-\u003esetItemDelegate(new ReadOnlyDelegate()); 或者只给某一列或某一行添加代理控件: //给特定的单元添加代理控件 ui.tableView-\u003esetItemDelegateForColumn(0, new ReadOnlyDelegate()); ui.tableView-\u003esetItemDelegateForRow(0, new ReadOnlyDelegate()); 假设我们想要通过代理控件达到的需求是，控件列表中的内容不可编辑、但是可以选中且被复制，那么我们需要实现以下代码: #include \u003cQLineEdit\u003e #include \u003cQStyledItemDelegate\u003e class ReadOnlyDelegate : public QStyledItemDelegate { Q_OBJECT public: ReadOnlyDelegate(QObject* parent = 0) :QStyledItemDelegate(){} QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem\u0026 option, const QModelIndex\u0026 index) const override { QLineEdit* editor = new QLineEdit(parent); editor-\u003esetFrame(false); editor-\u003esetReadOnly(true); return editor; } void setEditorData(QWidget* editor, const QModelIndex\u0026 index) const { QString value = index.model()-\u003edata(index, Qt::EditRole).toString(); QLineEdit* spinBox = static_cast\u003cQLineEdit*\u003e(editor); spinBox-\u003esetText(value); } void setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex\u0026 index) const { QLineEdit* spinBox = static_cast\u003cQLineEdit*\u003e(editor); QString value = spinBox-\u003etext(); model-\u003esetData(index, value, Qt::EditRole); } void updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem\u0026 option, const QModelIndex\u0026 index) const { editor-\u003esetGeometry(option.rect); } }; 二、获取选中的行 QModelIndexList selectedsList = ui.tableView-\u003eselectionModel()-\u003eselectedRows(); for (unsigned int n = 0; n \u003c selectedsList.size(); ++n) { int row = selectedsList.at(n).row(); } 三、动态插入数据 ui.tableView-\u003esetSortingEnabled(false); //关闭排序功能 int insertRow = ui.tableView-\u003erowCount(); ui.tableView-\u003einsertRow(insertRow); ui.tableView.setItem(insertRow,0,new QTableWidgetItem(\"name\")); ui.tableView-\u003esetSortingEnabled(true); //开启排序功能 这里需要注意的是，在插入数据的时候，必须关闭表头的排序(对应上述代码中的setSortingEnabled函数)，否则表格数据会错乱。 四、清空所有数据 ui.tableView-\u003esetRowCount(0); ui.tableView-\u003eclearContents(); ","date":"2021-04-05","objectID":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/:0:1","tags":["TableWidget","新手教程","QT"],"title":"QT组件之QTableWidget","uri":"/posts/qt/qt%E7%BB%84%E4%BB%B6%E4%B9%8Bqtablewidget/"},{"categories":["Github碎片"],"content":"因为工作的需要，不可避免地要对csv进行解析，但是自己写解析引擎的话只能写几句玩具代码，上限太低，不堪入目，所以一个好用的CSV解析引擎库就显得比较重要的。 fast-cpp-csv-parser 轻量小巧，好用，只需要包含一个头文件即可使用。特点如下： 可以按照标题将不同列的信息解析出来 可以使用多线程技术读取CSV文件并且解析 可以在编译时使用模板启用和禁用解析功能（例如转义字符串），按需定制功能 可以在合理的时间内读取多个GB大小的文件 支持自定义列分隔符（即支持制表符分隔值文件），引用转义字符串，自动空格修剪 使用*nix和Windows换行符，并自动忽略UTF-8 BOM 具有足够上下文以格式化有用的错误消息的异常类。 what（）返回错误消息准备好显示给用户 rapidcsv 使用了C++ 11，支持多平台。只需要包含一个头文件即可使用。个人认为就提供的库接口函数来说，rapidcsv比fastcsv更加简单，不过代价可能就是牺牲了一些效率吧。作者更新也挺勤劳。个人认为这个比较适合用来解决平时的一些小需求。 ","date":"2021-03-14","objectID":"/posts/github%E7%A2%8E%E7%89%87/csv%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E/:0:0","tags":["开源项目","csv","parser"],"title":"CSV解析引擎","uri":"/posts/github%E7%A2%8E%E7%89%87/csv%E8%A7%A3%E6%9E%90%E5%BC%95%E6%93%8E/"},{"categories":["QT"],"content":"例如我们想让主窗口能接受到拖放来的文件，要点如下: 1.设置属性 在Qt Designer中点击主窗口，右侧会出现属性编辑器，我们在属性acceptDrops上打√。 或者在初始化ui代码中添加 this-\u003esetAcceptDrops(true); 事实上这二者是等价的。 2.实现虚函数dragEnterEvent() 当窗口触发拖放事件的时候，就会进入到这个函数，这个时候我们可以检查一下拖进来的是什么东西(文件或者文本之类的)。 void MainWindow::dragEnterEvent(QDragEnterEvent* event) { //判断是否是文件 if (event-\u003emimeData()-\u003ehasFormat(\"text/uri-list\")) { event-\u003eacceptProposedAction(); } } 3.实现虚函数dropEvent() 这里可以填写触发的动作代码 void MainWindow::dropEvent(QDropEvent* event) { QList\u003cQUrl\u003e urls = event-\u003emimeData()-\u003eurls(); if (urls.isEmpty()) { return; } //To do... //拿到文件路径后，就可以执行想做的事了 } ","date":"2021-03-14","objectID":"/posts/qt/qt%E6%8E%A5%E5%8F%97%E6%8B%96%E6%94%BE%E6%96%87%E4%BB%B6/:0:0","tags":["入门","新手教程"],"title":"QT接受拖放文件","uri":"/posts/qt/qt%E6%8E%A5%E5%8F%97%E6%8B%96%E6%94%BE%E6%96%87%E4%BB%B6/"},{"categories":["产品试用"],"content":"由于不同的应用都有的自己的音乐版权，而我们如果想要存储自己想听的歌，那么该怎么做呢？ 使用物理硬盘存储 现在的机械硬盘容量很大，又十分便宜，把歌曲放在这里是个可取的选择。 稳定性:⭐⭐⭐⭐⭐ 传输速度:⭐⭐⭐⭐⭐ 容量:⭐⭐⭐⭐⭐ 便利性:⭐⭐ 评价:传输到自己的机械硬盘里，就不会像某音乐网盘一样会删掉你上传的歌曲了，数据安全性得到极大的保证，传输速度和容量也有保证。唯一的缺点就是传输不太方便了。 使用音乐网盘存储 每家音乐App其实都用的是自家的云盘，例如QQ音乐对接腾讯微云、网易云音乐对接网易云盘、酷狗音乐对接酷我云盘。然而不知何时开始，因为版权等原因，有一些歌曲经过扫描后，有可能不被允许上传到云盘中，有的甚至上传之后会被悄悄删除。 稳定性:⭐⭐⭐ 传输速度:⭐⭐⭐⭐ 容量:⭐⭐⭐⭐ 便利性:⭐⭐⭐⭐⭐ 评价:如果能够忍受自己上传的歌曲被删除，那么可以考虑使用这个方案；传输速度方面也暂时不用担心会像某度盘一样被限速，容量也能满足大部分人的需求。 使用坚果云 我目前就在尝试这个方案，因为坚果云个人版是不限制容量的，但是限制上传和下载流量，所以这个传输速度和容量，就不好评价了，如果你和我一样，只是为了将歌曲慢慢地存起来，只是为了等到想听的时候能快速找到资源(有可能是收集癖)，那么这个流量限制也就不用太在意。坚果云在我心目中的评价是: 稳定性:⭐⭐⭐⭐ 传输速度:⭐⭐⭐⭐ 容量:⭐⭐⭐⭐⭐ 便利性:⭐⭐⭐⭐ 使用国外云盘 像微软的OneDrive或者谷歌的云端网盘，都是不错的选择。大家也都可以尝试，这里我就懒得评测了。 ","date":"2021-03-14","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E9%9F%B3%E4%B9%90%E5%AD%98%E5%82%A8/:0:0","tags":["坚果云"],"title":"音乐存储","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E9%9F%B3%E4%B9%90%E5%AD%98%E5%82%A8/"},{"categories":["QT"],"content":"QT是一个跨平台的C++开发库，主要用来开发图形用户界面程序，不过QT还自带很多其它的开发库，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等。 参考教程 http://c.biancheng.net/qt/ 安装QT 由于QT版本较多，初学者建议选择稳定的老版本，而不是追求那些最新版本，否则可能踩各种坑，从而失去对QT的兴趣。 QT最后一个比较稳定且支持离线安装包版本是5.12，下载地址如下，自行选择一个版本即可，例如QT 5.12.10。 https://download.qt.io/official_releases/qt/5.12/ 进入到安装界面后，在安装的组件中，QT 5.12.10部分选择以下项: MSVC 2017 32-bit MSVC 2017 64-bit MinGW 7.3.0 32-bit 而Developer and Designer Tools部分选择以下项: Qt Creator 4.13.1 CDB Debugger Support MinGW 7.3.0 32-bit 因为我个人习惯了使用Visual Studio 2019，为了配合还需要下载一个VS插件，下载地址如下，选最新版的即可: https://download.qt.io/official_releases/vsaddin/ 在安装完成了上述两个程序，打开Visual Studio还需要配置一下QT的关键路径: Visual Studio菜单 -\u003e 扩展 -\u003e QT VS Tools -\u003e Qt Versions，在此添加对应的QT版本，路径选择QT目录下的qmake程序，例如C:\\Qt\\Qt5.12.10\\5.12.10\\msvc2017\\qmake.exe ","date":"2021-03-12","objectID":"/posts/qt/qt%E5%85%A5%E9%97%A8%E4%B9%8Bwindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["入门","新手教程"],"title":"QT入门之Windows开发环境搭建","uri":"/posts/qt/qt%E5%85%A5%E9%97%A8%E4%B9%8Bwindows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["产品试用"],"content":"kinhdown https://kinhdown.kinh.cc/ 用来下载百度云盘里面的东西，速度的话还算是能满足日常使用需求的。不过据说会窃取用户的cookie，如果对这一点不在意的话，那么还是选择这个软件吧，因为真的没什么太好的选择。 ","date":"2021-03-12","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/:0:0","tags":["下载","百度云"],"title":"下载工具","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"},{"categories":["易语言逆向"],"content":"通过寻找易语言静态编译的程序规律，我们可以找到一处结构体，这个结构体大概是下面这个样子: struct EHead { unsigned int dwMagic; //未知,值固定为3 unsigned int szNone2; //未知,值固定为0 unsigned int szNone3; //未知,好像是个随机数,修改不影响程序 unsigned int lpStartCode; //起始用户代码地址,不可修改 unsigned int lpEString; //常量资源,如果没有常量资源,则为0 unsigned int dwEStringSize; //常量资源大小,如果没有常量资源,则为0 unsigned int lpEWindow; //创建组件信息 unsigned int dwEWindowSize; //创建组件信息大小 unsigned int dwLibNum; //支持库数量 unsigned int lpLibEntry; //支持库信息入口 unsigned int dwApiCount; //Api数量 unsigned int lpModuleName; //指向模块名称 unsigned int lpApiName; //指向Api名称 }; 可以看到这些结构体包含着易语言程序中的很多重要数据，今天我们要研究的就是常量资源部分。 lpEString这个指针指向着易语言代码中所用到的全部常量，包括文本字符串、字节集、浮点数、类虚表、数组头、数组数据等，而dwEStringSize则表示常量的总大小。 这些数据十分复杂，无论是在理论上还是实际上，我们仅凭数据本身，是很难分辨出这些数据的类别的，因此本文的主题就诞生了——基于交叉引用来解析易语言常量资源。 基于交叉引用来解析资源，原理就是通过对数据进行代码交叉引用，观察代码是怎么使用数据的，我们根据固定的数据使用模板就能识别出数据类别了。 但是在实际情况下，有大量的代码被保护，是无法得知使用代码的，如果代码100%全部被虚拟化保护，那么基于交叉引用来识别数据类型就彻底不可行了。幸运的是，大部分程序只会对少量关键代码进行虚拟化保护，如何最大化地利用交叉引用来识别这些被保护的程序的资源便是一个值得研究的问题了。 ","date":"2021-03-08","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/:0:0","tags":["IDA"],"title":"基于交叉引用来解析易语言常量资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/"},{"categories":["易语言逆向"],"content":"固定的数据使用模板 因为在易语言程序中，不同的常量数据类型有不同的使用模板，因此首先我们要记录下这些模板。 浮点数模板 使用到数据的指令是fadd、fsub、fmul、fdiv、fcomp、fld其中的一种。 空白字符串模板 一种是jnz$+0x5,mov eax,addr。 一种是push addr 字符串模板 一种是push addr 一种是mov eax,addr 空白字节集模板 一种是jnz$+0x5,mov eax,addr。 一种是push addr 一种是mov esi,addr,0xABADABAD 字节集模板 一种是push addr 一种是mov eax,addr 数组头模板 一种是 mov esi,addr\rlodsd\rstosd\rlodsd\rstosd 数组模板 一种是mov eax,addr ","date":"2021-03-08","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/:0:1","tags":["IDA"],"title":"基于交叉引用来解析易语言常量资源","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%98%93%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F%E8%B5%84%E6%BA%90/"},{"categories":["C++开发"],"content":"一般情况下，创建一个类对象，可以在栈或者堆中分配空间。 比如，这样编写代码，就是在栈中建立类对象 int main() { A Obj; } 这句代码对于编译器来说可以转换为近似等于下面的代码: int main() { obj = 申请栈空间(sizeof(A)); A(Obj); ~A(Obj); } 1.分配好类的栈空间 2.调用类的构造函数 3.在变量生命周期结束的地方调用析构函数(编译器负责识别出在哪里结束) 因此，如果我们想让编译器无法在栈上建立类对象，可以将类的析构函数设为private，因为编译器便无法执行第三步。 而动态建立类对象，就是将对象建立在堆空间中，代码如下： int main() { A* ptr = new A; } 实际上编译器是怎么理解这句代码的呢? 1.判断对象A是否有重载operator new函数，如果有，使用对象A的operator new函数，否则，使用默认的operator new函数 2.使用operator new函数返回得到的空间指针，调用类的构造函数 因此，如果我们想让编译器无法在堆上建立类对象，可以重载类的operator new函数，再将属性设为private，这样编译器将无法调用类的operator new函数，便达到了限制的目的。 ","date":"2021-03-06","objectID":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%99%90%E5%88%B6%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/:0:0","tags":["高级C++"],"title":"C++限制堆和栈的对象空间分配","uri":"/posts/c++%E5%BC%80%E5%8F%91/c++%E9%99%90%E5%88%B6%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/"},{"categories":["Github碎片"],"content":"Github项目地址:graphviz Graphviz 是一款由 AT\u0026T Research 和 Lucent Bell 实验室开源的可视化图形工具，用于绘制DOT语言脚本描述的图形。它可以很方便的用来绘制结构化的图形网络，并且支持GIF,PNG,SVG,PDF等多种格式输出。 官方文档地址:Documentation 要想使用Graphviz就得先熟悉DOT语言，这是一种用来描述图形的脚本语言。 DOT语言 DOT语言是一种文本图形描述语言。它提供了一种简单的描述图形的方法，并且可以为人类和计算机程序所理解。DOT语言文件通常是具有.gv或是.dot的文件扩展名。 graph表示无向图，例如下面的dot脚本 graph graphname { a -- b -- c; b -- d; } digraph为有向图，例如下面的dot脚本 digraph graphname { a -\u003e b -\u003e c; b -\u003e d; } 在线画图工具 项目地址:https://github.com/dreampuf/GraphvizOnline 工具地址:https://dreampuf.github.io/GraphvizOnline/ ","date":"2021-01-30","objectID":"/posts/github%E7%A2%8E%E7%89%87/graphviz/:0:0","tags":["开源项目","Graphviz"],"title":"Graphviz","uri":"/posts/github%E7%A2%8E%E7%89%87/graphviz/"},{"categories":["Github碎片"],"content":"Github项目地址:NetworKit NetworKit是用一个用于高性能网络分析的开源工具包，其目标是为了分析上千或者上亿条边的大型网络节点。为此，它实现了有效的图算法，并且部分算法实现了并行处理。 该项目底层核心使用C++编写，上层再封装一层python库，因此性能较高。 不过国内资料实在太少，文档都看不懂，我是小白，不会用(⊙﹏⊙)…… ","date":"2021-01-30","objectID":"/posts/github%E7%A2%8E%E7%89%87/networkit/:0:0","tags":["开源项目","NetworKit"],"title":"NetworKit","uri":"/posts/github%E7%A2%8E%E7%89%87/networkit/"},{"categories":["产品试用"],"content":"今天看到一款产品，据说能将DLL或者EXE转换为可编译的C/C++代码，官网地址如下: https://www.dll-decompiler.cn/dll2c.html 官方介绍如下: DLL to C 是一个能够把所有DLL文件和部分EXE文件转换为可编译的C/C++代码的工具，转换之后生成的代码高度可靠，可直接编译运行，并且可以很容易地阅读和编辑。 带着好奇心，我便下载了产品试了试。 EXE的话需要付费版才能进行转换，要650RMB。额，那就试试DLL的转换效果，随便找了几个DLL，发现稍微复杂一点的便提示不支持。 于是自己编译了一个DLL，代码也就一句MessageBox，使用OD加载该模块并运行的话就会弹出一个提示框。 那就用这工具转换试试吧，转换成功后，得到了一个Visual Studio工程，看了看转换后的工程代码，发现里面并没有我写的代码，大部分都是一些作者写的函数和原始DLL的十六进制数据。这和官方的描述不符啊，说好的可以很容易地阅读和编辑呢。。。 不过也罢，工程倒是生成出来了，也确实能编译出DLL，那么试试编译后的DLL模块吧。 使用OD载入此模块并没有弹出提示框，这样的话功能等价性就测试失败了。也有可能是我没有掌握使用方法吧，也懒得再进行测试了。 好的，经过上面一番测试，也大概了解了该工具的原理，和内存加载DLL的方向有点相似，区别就在于多了一些杂七杂八的代码，换汤不换药，还不如内存加载DLL呢。 ","date":"2021-01-24","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/:0:0","tags":["Decompiler"],"title":"DLL2C试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/"},{"categories":["产品试用"],"content":"总结: 没什么用的工具，我也很难找到其应用场景。如果是想要窃取他人的产品，最笨同时也是最有效的方法是花费人力来对产品进行人工逆向还原，取得产品核心代码和原理后再在此基础上进行重新架构开发，这样能一定程度上避免法律的风险。像这种把二进制集成到源码里面，和直接调用模块本身并无实质区别，通过二进制对比等技术手段取证之后，无法规避法律风险。没啥用的工具，已卸载。 ","date":"2021-01-24","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/:0:1","tags":["Decompiler"],"title":"DLL2C试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/dll2c%E8%AF%95%E7%94%A8/"},{"categories":["杂文"],"content":"系统又又又重装了，又又又忘了怎么配置博客，所以做笔记是有多么重要。。。。 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 1.下载Hugo 地址如下，找到对应平台的二进制包，下载后将工具目录添加至系统环境变量。 https://github.com/gohugoio/hugo/releases 需要注意的是，由于LoveIt主题使用了一些特性，因此我们需要下载hugo_extended版本，否则可能会生成博客失败。 2.创建博客 执行以下命令 hugo new site testDemo cd testDemo git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 之后修改testDemo目录下的config.toml文件，该文件可以用来配置主题信息，例如修改为如下 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 3.添加文章 我们可以在testDemo/content/posts目录下添加md文件，例如first_post.md --- title: \"我是第一篇文章\" date: 2021-01-24 tags: [\"笔记\",\"博客\"] categories: [\"杂文\"] --- 这是我的第一篇文章 4.调试 添加完成后，执行下面的命令开启动态预览博客。 hugo server 执行完成后，命令会返回一个本地网址，我们可以通过该网址查看博客内容。 5.发布 使用以下命令行，生成html内容 rm -f -r docs hugo -b \"https://fjqisba.github.io\" -d docs git add . git status git commit -m \"content update\" git push 这个生成的docs文件夹其实就是Github Pages要展示的内容了，因此在项目配置中的Settings -\u003e Pages -\u003e Source这一栏，我们需要将目录/root修改为/docs。 ","date":"2021-01-24","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","博客"],"title":"Hugo搭建LoveIt博客","uri":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/"},{"categories":["杂文"],"content":"遇到的坑 markdown文件在网页的路径中不能出现小数点之类的特殊字符。 ","date":"2021-01-24","objectID":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/:0:1","tags":["Hugo","博客"],"title":"Hugo搭建LoveIt博客","uri":"/posts/hugo%E6%90%AD%E5%BB%BAloveit%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言逆向"],"content":"易语言数据操作支持库一中存在这样一对算法函数 调用格式： 〈字节集〉 加密数据 （字节集 字节集数据，文本型 密码文本，［整数型 加密算法］） - 数据操作支持库一-\u003e数据加解密\r英文名称：Encrypt\r加密一段字节集数据，返回加密后的结果字节集。如果失败，返回空字节集。本命令为初级命令。\r参数\u003c1\u003e的名称为“字节集数据”，类型为“字节集（bin）”。为命令提供所需的字节集数据。\r参数\u003c2\u003e的名称为“密码文本”，类型为“文本型（text）”。\r参数\u003c3\u003e的名称为“加密算法”，类型为“整数型（int）”，可以被省略。指定具体使用的加密算法，可以为以下常量值之一：1: #DES算法； 2: #RC4算法。加密和解密必须使用相同的算法，有关算法的具体说明请参阅有关文献。如果本参数被省略，则默认值为1，即DES算法。 调用格式： 〈字节集〉 解密数据 （字节集 字节集数据，文本型 密码文本，［整数型 加密算法］） - 数据操作支持库一-\u003e数据加解密\r英文名称：Decrypt\r解密一段加密后的字节集数据，返回解密后的结果字节集。注意本命令并不对密码文本进行校验，如果密码提供错误，将返回错误的结果。如果失败，返回空字节集。本命令为初级命令。\r参数\u003c1\u003e的名称为“字节集数据”，类型为“字节集（bin）”。为命令提供所需的字节集数据。\r参数\u003c2\u003e的名称为“密码文本”，类型为“文本型（text）”。\r参数\u003c3\u003e的名称为“加密算法”，类型为“整数型（int）”，可以被省略。指定具体使用的加密算法，可以为以下常量值之一：1: #DES算法； 2: #RC4算法。加密和解密必须使用相同的算法，有关算法的具体说明请参阅有关文献。如果本参数被省略，则默认值为1，即DES算法。 这个函数里面的DES算法是不标准的，如果我们需要逆向算法或者移植语言，就会陷入坑中。。。。 根据别人研究的资料， 得知将密钥进行变换就可以对齐结果，实现Go语言代码如下: package Utils import ( \"bytes\" \"crypto/des\" \"encoding/binary\" \"math/bits\" ) func zeroPadding(ciphertext []byte, blockSize int) []byte { padding := blockSize - len(ciphertext) % blockSize padtext := bytes.Repeat([]byte{0}, padding) return append(ciphertext, padtext...) } func E_加密数据_DES(加密数据 []byte,密码文本 string)([]byte,error) { key := make([]byte,8) //压缩密钥 sIndex := 0 for _,eKey := range 密码文本{ key[sIndex] = byte(eKey) ^ key[sIndex] sIndex = sIndex + 1 if sIndex == 8{ sIndex = 0 } } //转换密钥 for n,_ := range key{ key[n] = bits.Reverse8(key[n]) } block,err := des.NewCipher(key) if err!=nil{ return nil,err } //需要在数据前面追加长度 inputData := make([]byte,4) binary.LittleEndian.PutUint32(inputData,uint32(len(加密数据))) inputData = append(inputData, 加密数据...) inputData = zeroPadding(inputData,block.BlockSize()) //开始执行加密 encryptedData := make([]byte, len(inputData)) data := inputData dst := encryptedData bs := block.BlockSize() for len(data) \u003e 0 { // Mandarin encryption is made according to blocksize // Can use the Go key to encrypt block.Encrypt(dst, data[:bs]) data = data[bs:] dst = dst[bs:] } return encryptedData, nil } func E_解密数据_DES(解密数据 []byte,密码文本 string)([]byte,error) { key := make([]byte,8) //压缩密钥 sIndex := 0 for _,eKey := range 密码文本{ key[sIndex] = byte(eKey) ^ key[sIndex] sIndex = sIndex + 1 if sIndex == 8{ sIndex = 0 } } //转换密钥 for n,_ := range key{ key[n] = bits.Reverse8(key[n]) } block,err := des.NewCipher(key) if err!=nil{ return nil,err } //开始执行解密 decryptedData := make([]byte, len(解密数据)) data := 解密数据 dst := decryptedData bs := block.BlockSize() for len(data) \u003e 0 { // Mandarin encryption is made according to blocksize // Can use the Go key to encrypt block.Decrypt(dst, data[:bs]) data = data[bs:] dst = dst[bs:] } //读取头部数据 recvLen := binary.LittleEndian.Uint32(decryptedData) return decryptedData[4:recvLen+4], nil } 另外附上一份别人写的python版本 from Crypto.Cipher import DES import struct def reverse_bytes(b): assert type(b) == bytes ba = bytearray(b) for i in range(0, len(b)): ba[i] = int(format(b[i], '0\u003e8b')[::-1], 2) return bytes(ba) def get_new_key(key): ba = bytearray(8) i = 0 for b in key: ba[i] = b ^ ba[i] i = i + 1 if i \u003c 8 else 0 return bytes(ba) # zero padding def padding(d): ba = bytearray(d) while len(ba) % 8 != 0: ba.append(0) return bytes(ba) def append_len(d): assert type(d) == bytes length = struct.pack('\u003cL', len(d)) return bytes(length + d) def remove_len(d): assert type(d) == bytes return d[4:] def e_des_encrypt(plain, key): des = DES.new(reverse_bytes(get_new_key(key)), DES.MODE_ECB) return des.encrypt(padding(append_len(plain))) def e_des_decrypt(raw, key): des = DES.new(reverse_bytes(get_new_key(key)), DES.MODE_ECB) t = des.decrypt(raw) return remove_len(t) # 易语言： # 输出调试文本(字节集_字节集到十六进制 (加密数据 (到字节集 (“123456789”), “123456789”, #DES算法))) # 输出： # 53DEE70DD231541839EB99553B8B056D # -------------------------------- # python: plain = b'123456789' key = b'123456789' ciph = e_des_encrypt(plain, key) print(ciph.hex().upper()) print(e_des_decrypt(ciph, key).decode()) # 输出: # 53DEE70DD231541839EB99553B8B056D123456789 # 123456789 参考资料 https://monvvv.github.io/2019/10/09/A-weird-way-of-DES-implementation-of-Elang.html ","date":"2021-01-11","objectID":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E5%BA%93%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/:0:0","tags":["易语言","DES"],"title":"易语言支持库中的加密数据与解密数据","uri":"/posts/%E6%98%93%E8%AF%AD%E8%A8%80/%E6%98%93%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%E5%BA%93%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/"},{"categories":["LLVM"],"content":"LLVM的核心是中间端表达式，即LLVM IR(Intermediate Representation)，这是一种类似汇编的底层语言。 中间端表达式有三种存在形态: 一种文本形态，可以直接被人类阅读; 一种内存对象形态，存在于运行中的C++代码中; 一种文件形态，为序列化的bitcode。 官方手册地址:https://llvm.org/docs/LangRef.html 文档手册地址:https://llvm.org/doxygen/annotated.html 摘要 LLVM 语言是基于Static Single Assignment (SSA)策略的语言。LLMV IR的语言特点是：类型安全、 低级别操作、灵活且具有清晰表示所有高级语言的能力。它作为一个统一的代码表示，贯穿LLVM编译的各个阶段。 标识符 LLVM标识符有2个基本类型：全局的和局部的。全局的标识符（函数，全局变量）以@字符开头。局部的标识符（注册名称，类型）以％字符开头 注释 注释行以;符号开头。 Store指令，操作数A = 存储值，操作数B = 存储地址。 函数调用约定(calling convention) ccc，C语言 fastcc ，fastcall类型 5、 llvm::Instruction函数中的eraseFromParent和removeFromParent方法的区别: removeFromParent = 从BasicBlock中移除指令链接 eraseFromParent = 从BasicBlock中移除指令链接 + 删除指令 ","date":"2021-01-09","objectID":"/posts/llvm/llvm-ir%E7%AE%80%E4%BB%8B%E4%B8%89/:0:0","tags":["LLVM"],"title":"LLVM IR简介(三)","uri":"/posts/llvm/llvm-ir%E7%AE%80%E4%BB%8B%E4%B8%89/"},{"categories":["产品试用"],"content":"福昕PDF阅读器(目前的选择) 感觉比较专业，标签页结构清晰，支持多种形式保存标签，功能较为齐全。 Sumatra PDF 一款开源的PDF阅读器，只能满足基本的阅读功能，中规中矩，没有出彩的地方。 万兴PDF专家 必须得注册账号并登录才能使用PDF阅读功能，安装后我立马就卸载了。。 ","date":"2021-01-08","objectID":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/pdf%E9%98%85%E8%AF%BB%E5%99%A8%E8%AF%95%E7%94%A8/:0:0","tags":["PDF"],"title":"PDF阅读器试用","uri":"/posts/%E4%BA%A7%E5%93%81%E8%AF%95%E7%94%A8/pdf%E9%98%85%E8%AF%BB%E5%99%A8%E8%AF%95%E7%94%A8/"},{"categories":["Python"],"content":"python安装Crypto这个库非常的坑，正确步骤似乎是: 1、pip install pycryptodome 2、将python lib库目录下面的crypto文件夹名改成大写的Crypto。 这里要吐槽一下，网上的一些库，对Windows实在是太不友好了😭 ","date":"2021-01-08","objectID":"/posts/python/python%E5%AE%89%E8%A3%85crypto%E5%BA%93/:0:0","tags":["Crypto","pip"],"title":"Python安装Crypto库","uri":"/posts/python/python%E5%AE%89%E8%A3%85crypto%E5%BA%93/"},{"categories":["Python"],"content":"str和bytes python3中str默认是Unicode，bytes则是utf-8。 例如字符串\"我日你哥\"，在str状态下打印出十六进制 b = [hex(ord(x)) for x in '我日你哥'] print(b) 11 62 E5 65 60 4F E5 54 ","date":"2021-01-08","objectID":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","tags":["Crypto","pip"],"title":"Python常见数据类型转换","uri":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"str转bytes a = \"我日你哥\" b = a.encode(\"utf-8\") 实际数据则变成了 E6 88 91 E6 97 A5 E4 BD A0 E5 93 A5 ","date":"2021-01-08","objectID":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","tags":["Crypto","pip"],"title":"Python常见数据类型转换","uri":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"bytes转str bytes转换回str，使用以下方法: a = \"我日你哥\" b = a.encode(\"utf-8\") a = b.decode(\"utf-8\") ","date":"2021-01-08","objectID":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:3:0","tags":["Crypto","pip"],"title":"Python常见数据类型转换","uri":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["Python"],"content":"bytes转换为十六进制字符串 Python3直接用hex函数即可。 a = \"我日你哥\" b = a.encode(\"utf-8\") print(b.hex()) 得到结果e68891e697a5e4bda0e593a5 ","date":"2021-01-08","objectID":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:4:0","tags":["Crypto","pip"],"title":"Python常见数据类型转换","uri":"/posts/python/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["LLVM"],"content":"前端代码生成LLVM IR 使用以下命令将源代码转换成LLVM IR文本。 clang -emit-llvm -S test.c -o test.ll 前端代码生成可执行程序 基本选项是定义目标体系结构，语法为-target \u003ctriple\u003e triple的格式一般为\u003carch\u003e\u003csub\u003e-\u003cvendor\u003e-\u003csys\u003e-\u003cabi\u003e，其中: arch = x86_64、i386、arm、thumb、mips等 sub = 与arch对应，例如在ARM上有 v5、v6m、v7a、v7m等。 vendor = none、linux、win32、darwin、cuda等 abi = eabi、gnu、android、macho、elf等 简单举个例子就清楚了，例如对于某个test.c文件，我们想要将它编译成不同平台下的可执行程序。 如果想要编译成Windows下的64位可执行程序，使用以下命令行即可 clang test.c -target x86_64-pc-windows-msvc 在上面这个例子中，arch就是x86_64，sub则没有，vendor是pc，sys是windows，abi是msvc。 另外如果我们想要编译成Windows下的32位可执行程序，使用以下命令行即可 clang test.c -target i386-pc-windows-msvc LLVM IR生成可执行程序 使用clang可以直接将LLVM IR编译成可执行文件，命令如下 clang test.ll -o test.exe ","date":"2021-01-07","objectID":"/posts/llvm/llvm%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BA%8C/:0:0","tags":["LLVM","Clang"],"title":"LLVM整体架构(二)","uri":"/posts/llvm/llvm%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BA%8C/"},{"categories":["LLVM"],"content":"LLVM是一个非常有名的开源编译器框架，由C++编写。 介绍:LLVM - 维基百科，自由的百科全书 (wikipedia.org) Github项目地址:llvm-project 编译LLVM前需要准备的环境 Git，工具地址为https://git-scm.com/download CMake，工具地址为https://cmake.org/download/ Visual Studio 2017或者以上 Python 1.克隆代码仓库 执行以下命令即可 git clone --config core.autocrlf=false https://github.com/llvm/llvm-project.git 2.配置VS工程 执行以下命令即可 cd llvm-project mkdir build cd build cmake -DLLVM_ENABLE_PROJECTS=clang -G \"Visual Studio 16 2019\" -A x64 -Thost=x64 ..\\llvm 这样就得到了生成好的LLVM.sln工程 3.编译程序 在Visual Studio中打开LLVM.sln工程，里面项目有很多，还包含一些测试用例，如果全部编译的话，占用空间估计得上百G。 LLVM工程中的项目介绍: Clang: LLVM中的前端，可用来输出源代码对应的抽象语法树(Abstract Syntax Tree, AST)，并将代码编译成LLVM Bitcode，最后在后端编译出平台相关的机器语言。Clang命令行参数文档:Clang command line argument reference llvm-as LLVM的汇编器，它可以将LLVM IR转换为bitcode(就像把普通的汇编代码转换为可执行文件)。 llvm-dis LLVM的反汇编器，它可以将bitcode转回为LLVM IR。 llvm-link LLVM bitcode的链接器，可以将多个bitcode链接成一个bitcode。 opt LLVM模块化的优化器和分析器。可以通过使用PASS对LLVM IR或者LLVM bitcode进行优化处理。 ","date":"2021-01-06","objectID":"/posts/llvm/%E5%9C%A8windows%E4%B8%8B%E6%90%AD%E5%BB%BAllvm%E7%8E%AF%E5%A2%83%E4%B8%80/:0:0","tags":["LLVM"],"title":"在Windows下搭建LLVM环境(一)","uri":"/posts/llvm/%E5%9C%A8windows%E4%B8%8B%E6%90%AD%E5%BB%BAllvm%E7%8E%AF%E5%A2%83%E4%B8%80/"},{"categories":["项目管理"],"content":"积累的一些想法，根本不一定是对的: 1、要么就提战略上的宏观目标，要么就提具体的需求，永远不要将目标当成需求交给底层人员解决。 2、项目中，去除项目之间的依赖性，分开业务逻辑一定比合在一起好，俗称解耦? ","date":"2021-01-01","objectID":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/:0:0","tags":["笔记","经验"],"title":"项目经验总结","uri":"/posts/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"categories":["杂文"],"content":"Crypto++ 官网:https://www.cryptopp.com/ 也被称为CryptoPP,libcrypto++和libcryptopp，是免费开源的C++算法库。该库支持多种加密算法，且代码运行性能较高，例如AES算法使用了AES-NI，计算性能较普通的AES算法有显著提高。 OpenSSL 官网:https://www.openssl.org/source/ 二进制包下载地址:http://slproweb.com/products/Win32OpenSSL.html openssl是一个安全套接字层密码库，囊括主要的密码算法、常用密钥、证书封装管理功能及实现ssl协议。 ","date":"2020-12-30","objectID":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:0","tags":["Github"],"title":"开源项目","uri":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["杂文"],"content":"Emscripten Github项目地址:Emscripten Emscripten 是 Mozilla 的 Alon Zakai 开发的一个独特 LLVM 后端，可以将任意LLVM中间码编译成JavaScript。 LLVM负责解析C/C++代码，输出初步解析后的中间代码，后端Emscripten负责将中间代码转换为JavaScript代码，作者设计了一套转换语法，想办法在JavaScript中创建出C/C++的特性，但很明显并不是所有的C/C++的代码都能进行完美转换。 为了提高速度，生成出来的JS代码被优化成了WebAssembly，这是一种类似于二进制的文件，这样可以在js中编写一套解释执行框架去执行这些字节码。 ","date":"2020-12-30","objectID":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/:0:1","tags":["Github"],"title":"开源项目","uri":"/posts/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"categories":["杂文"],"content":"虽然说我天天和Windows X86平台下的汇编指令打交道，大部分指令都已经掌握了，但直到有一天需要对这些指令进行逐个解析处理的时候，才发现自己对这些指令的掌握远远不够。 首先X86平台下的这些指令，是可以进行分类的。 由于不知道专业术语是什么，我自己定义了名称: 下列这些指令，我称之为灵活的双操作数指令: ADD ADC MOV SBC SUB XOR 它们的特点就是支持mov [eax],eax;mov eax,[eax]这样的操作。 如何在不改变标志位的情况，对寄存器进行增减? 使用add,sub,inc,dec等指令会修改标志位，使用lea指令即可。 lea eax,[eax+0x1];\rlea eax,[eax-0x1]; ","date":"2020-12-27","objectID":"/posts/x86%E6%8C%87%E4%BB%A4%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/:0:0","tags":["指令集 X86"],"title":"X86指令进阶学习","uri":"/posts/x86%E6%8C%87%E4%BB%A4%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"16位、32位、64位指令 80x86系列处理器有一个逐渐发展的过程。 8086、8088、80286是16位结构处理器，支持16位指令系统。 常用的汇编器有以下几种: 编译器 开发者 优点 缺点 MASM 微软 微软自家软件和系统兼容性好；支持invoke/.if等伪指令将汇编变得和C++差不多 就一个编译器，没有资源编译器和链接器，也没有头文件 TASM Borland 支持伪指令，有资源编译器和链接器 没有Windows数据结构和预定义的头文件，现在官方似乎不维护了 NASM 开源 同时支持Windows和Linux 不支持伪指令，没有Windows数据结构和预定义的头文件 MASM是Microsoft Macro Assembler的缩写，它是微软为x86 微处理器家族所写的一套宏汇编器。 masm虽然产品年龄比较大，但是它是最受各方支持的汇编器，在最新版的Visual Studio中，我们能在bin目录中找到一个ml.exe，这个就是masm中编译部分的一个核心程序。 我们可以在http://www.masm32.com/网址上找到MASM32开发包。 安装好开发包后我们可以在masm32目录下找到一个qeditor.exe可视化开发工具。 新建一个test.asm文件，编写以下代码 .386 ; 编译器指令，使用386指令集 .model flat, stdcall ; model汇编指令，程序的内存模式, flat是windows程序，没有远近指针，stdcall是windows函数用的参数方式，即参数从右向左传递 option casemap :none ; 标签是否区分大小写 include \\masm32\\include\\windows.inc ; 包含了Win32 API 的一些常量和函数定义 include \\masm32\\include\\kernel32.inc ; 包含了后面使用的ExitProcess函数 include \\masm32\\include\\masm32.inc ; 包含了后面使用的StdOut函数，不是标准的Win32函数，由MASM提供 includelib \\masm32\\lib\\kernel32.lib ; 库文件 includelib \\masm32\\lib\\masm32.lib .data HelloWorld db \"Hello World!\", 0 ; 定义使用的字符串常量,db代表define byte。最后跟一个NUL，表示ANSI字符集结束符 .code ; 开始代码区 start: ; 所有的代码要在start标签后、end start前 invoke StdOut, addr HelloWorld ; 调用函数StdOut，参数量HelloWorld的地址。注意StdOut是MASM提供的宏。其它编辑器里可以使用WriteConsole之类win32函数代替。 invoke ExitProcess, 0 ; 调用ExitProcess end start 选择菜单Project-\u003eAssemble ASM file，我们就可以根据asm文件生成出obj文件。 再选择菜单Project -\u003e Link OBJ File，就可以根据obj文件链接得到可执行文件。 以上两个步骤实质上是通过调用masm32/bin目录下的ml.exe和link.exe这两个程序来完成的，我们也可以在控制台输入以下命令，完成编译链接操作: ml.exe /c /Zd /coff test.asm link.exe /SUBSYSTEM:WINDOWS test.obj 编写16位程序 masm默认编译出来的程序是32位的，但目录下其实也有一个link16.exe用来生成16位程序。 示例代码如下: .MODEL SMALL .data HelloWorld db \"Hello World!\", 0 .code start: mov ax,2 end start 我们可以执行以下命令行，来生成16位的程序 ml.exe /Zm /c test.asm link16.exe test.asm %1,,,,, ","date":"2020-12-23","objectID":"/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/:0:0","tags":["汇编 MASM"],"title":"MASM学习","uri":"/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"categories":["C++逆向"],"content":"C++存在非常令人头疼的STL模板库，如果不去了解它的话，还原C++代码又会特别吃力。。。 不同的VC版本或者Debug\\Release版，STL库都可能有一定的差别。 这里以VS2017 Release版本为示例: String(大小0x18) struct string { Union _Bxty { char _Buf[16]; char* _Ptr; } size_t _Mysize; //字符串长度 size_t _Myres; //最大字符串长度 }; Vector(大小0xC) struct vector { T* _Myfirst; //数组起始地址 T* _Mylast; T* _Myend; }; Map(大小0x8) struct map { Tree_nod* _MyHead; unsigned int _Mysize; }; Tree_nod(大小0x10 + 键值对) struct __declspec(align(4)) Tree_nod { Tree_nod* _Left; Tree_nod* _Parent; Tree_nod* _Right; char _Color; char _Isnil; map_pair _Myval; //键值对 }; List(大小0x8) struct list { List_node* _MyHead; unsigned int _Mysize; } List_node(大小0x8 + 值): struct __declspec(align(4)) List_node { List_node* _Next; List_node* _Prev; int _Myval; //值 } list-\u003eMyHead-\u003eNext为list.front(); list-\u003eMyHead-\u003ePrev为list.back(); ","date":"2020-09-24","objectID":"/posts/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/:0:0","tags":["STL"],"title":"STL库学习","uri":"/posts/stl%E5%BA%93%E5%AD%A6%E4%B9%A0/"},{"categories":["爬虫"],"content":"想标题想了很久，最后感觉还是用这个标题比较合适。 问题情景是这样的： 有一个较为古老的CEF程序，需要对程序里面的内容进行爬取，获取数据。 众所周知，CEF框架无非就是个浏览器，最终访问的还是网页，那么我们直接访问网页进行爬取不就好了吗? 但实际上能否这样做是值得商榷的，例如我要爬取的那个程序，通过CEF注册JS扩展的方式，使网页与本地的其它进程建立起了通讯，这样我就不能脱离这个CEF程序而独立去访问网页了，否则页面将无法正常运作。 遇到这种情况，我们可以根据远程调试协议开启浏览器的远程调试功能，再用Selenium或者Puppeteer等爬虫工具挂接浏览器，这样我们就可以对浏览器进行一些自动化操作了。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:0","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"开启远程调试 开启方法很简单，在要调试的浏览器进程快捷方式属性上加上参数: --remote-debugging-port=9222 --user-data-dir=C:\\ChromeDebug 远程调试端口一般为9222，用户数据目录我们随便创建一个就好。 这个时候我们可以访问127.0.0.1:9222/json/version，其中有一个值叫webSocketDebuggerUrl，调试程序主要就是根据这个URL来连接上浏览器的。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:1","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["爬虫"],"content":"Selenium爬虫 为什么使用Selenium而不是Puppeteer呢？先前已经提到，该CEF程序是一个古老的程序，Chromium浏览器内核版本为V58左右，而Puppeteer框架对浏览器版本有着严格的限制，官方也有说明:每一个版本的Puppeteer理论上只适配一个特定版本的Chromium浏览器。而Selenium框架对版本支持更加友好，不管老版本还是新版本，都有适配的浏览器驱动，我们只需要去下载相应版本的WebDriver即可。下载地址如下: http://chromedriver.storage.googleapis.com/index.html 至于Selenium的使用教程，参考一下: https://selenium-python-zh.readthedocs.io/en/latest/ 编写代码连接上浏览器 from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option('debuggerAddress','127.0.0.1:9222') browser = webdriver.Chrome(executable_path=\"C:\\chromedriver.exe\",chrome_options=chrome_options) browser.get('http://www.baidu.com') 之后后面的模拟点击、爬取内容就不再细谈了。 ","date":"2020-09-20","objectID":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/:0:2","tags":["浏览器","CEF","Selenium"],"title":"对CEF程序进行爬虫","uri":"/posts/%E7%88%AC%E8%99%AB/%E5%AF%B9cef%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB/"},{"categories":["Github碎片"],"content":"1.DocFx是微软的一款开源的文档生成工具，下载地址如下:https://github.com/dotnet/docfx/releases 软件的官网是https://dotnet.github.io/docfx，在里面还可以获取到一些教程 2.此软件的运行需要.Net Framework 4.7.2环境，需要自行安装 3.创建一个DocFx工程 docfx init -q 4.建立网站 docfx docfx_project\\docfx.json --serve 这样就可以通过访问http://localhost:8080来查看文档页面了，里面包含了一些基本的页面。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"docfx.json解析 docfx.json是docfx用于生成文档的配置文件，目前docfx.json只包含了两个键值对，分别是metadata和build。 metadata属性如下(暂时对我来说好像没什么用，我就不管了): Key Description src 工程源码的位置 dest 存放生成的metadata文件的目录 force shouldSkipMarkup filter useCompatibilityFileName properties build属性如下: Key Description content 用于生成文档的全部文件 resources 资源文件或者元数据文件，例如图片文件。 overwrite Contains all the conceptual files which contains yaml header with uid and is intended to override the existing metadata yml files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadata 应用于每个文件的配置选项，例如在globalMetadata中定义\"_appTitle\": \"我是标题\",则每个页面都会追加标题文本。 fileMetadata Contains metadata that will be applied to specific files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadataFiles Specify a list of JSON file path containing globalMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. fileMetadataFiles Specify a list of JSON file path containing fileMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. template The templates applied to each file in the documentation. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, embedded default template will be used. theme The themes applied to the documentation. Theme is used to customize the styles generated by template. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, no theme will be applied, the default theme inside the template will be used. xref Specifies the urls of xrefmap used by content files. Currently, it supports following scheme: http, https, ftp, file, embedded. xrefService Specifies the url patterns of xref service. Please read Section3.2.4 for detail. exportRawModel If set to true, data model to run template script will be extracted in .raw.json extension. rawModelOutputFolder Specify the output folder for the raw model. If not set, the raw model will be generated to the same folder as the output documentation. exportViewModel If set to true, data model to apply template will be extracted in .view.json extension. viewModelOutputFolder Specify the output folder for the view model. If not set, the view model will be generated to the same folder as the output documentation. dryRun If set to true, template will not be actually applied to the documents. This option is always used with --exportRawModel or --exportViewModel, so that only raw model files or view model files are generated. maxParallelism Set the max parallelism, 0 (default) is same as the count of CPU cores. markdownEngineName Set the name of markdown engine, default is dfm, other available engines are gfm and markdig. markdownEngineProperties Set the parameters for markdown engine, value should be a JSON string. noLangKeyword Disable default lang keyword, it can be downloaded from here . keepFileLink If set to true, docfx does not dereference (aka. copy) file to the output folder, instead, it saves a link_to_path property inside manifest.json to indicate the physical location of that file. A file link will be created by incremental build and copy resouce file. sitemap In format SitemapOptions Specifies the options for the sitemap.xml file. disableGitFeatures Disable fetching Git related information for articles. Set to true if fetching git related information is slow for huge Git repositories. Default value is false. ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"更换主题模板 我个人对官方默认的主题不是特别满意，我们可以去官网下载其它的主题模板。 下载完成后进行以下步骤使用模板 在Doxfx网站根目录创建一个templates文件夹 将主题文件夹拷贝至templates文件夹目录下 在docfx.json中的template项中添加模板文件夹的路径，例如我使用的是mathew主题模板 { \"template\": [ \"default\", \"templates/mathew\" ], } 主题文件夹中有一个main.css可以用来修改主题的一些属性 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"配置文档目录 docfx工程默认结构如下: docfx_project/index.md为主页的显示内容 docfx_project/toc.yml为文档目录配置文件，对应docfx_project/api和docfx_project/articles这两个目录 我们可以通过修改docfx_project/toc.yml来配置文档目录，例如默认配置文件如下 - name: Articles href: articles/ - name: Api Documentation href: api/ homepage: api/index.md yml这种数据格式可能不太熟悉，其实和json差不多，转换成json如下 [ { \"name\": \"Articles\", \"href\": \"articles/\" }, { \"name\": \"Api Documentation\", \"href\": \"api/\", \"homepage\": \"api/index.md\" } ] 在添加目录或者修改目录的时候，同时也要修改docfx_project/docfx.json中的content，因为content包含用于生成文档的全部文件。 ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Github碎片"],"content":"开启搜索功能 如果想要开启程序自带的搜索功能，需要进行以下两步: 程序其实预留了一些配置项，通过修改globalMetadata可以设置它们，在docfx_project/docfx.json中添加以下globalMetadata项 \"globalMetadata\": { \"_enableSearch\": \"true\", }, 这样我们就开启了页面上的搜索栏。 程序如果要对生成后的HTML文件继续处理，可以通过添加postProcessors项来进行操作，在docfx_project/docfx.json中添加postProcessors项 \"postProcessors\": [ \"ExtractSearchIndex\" ], 这表示程序会在生成HTML文件之后提取里面的单词生成一个数据库，可用于搜索。 程序完整的预留MetaData如下: Metadata名称 类型 描述 _appTitle string Will be appended to each output page’s head title. _appFooter string 页脚内容，如果未设置则默认为Generated by DocFX _appLogoPath string Logo file’s path from output root. Will show DocFX’s logo if not specified. Remember to add file to resource. _appFaviconPath string Favicon file’s path from output root. Will show DocFX’s favicon if not specified. Remember to add file to resource. _enableSearch bool 用于设置是否在页面上方显示搜索栏 _enableNewTab bool Indicate whether to open a new tab when clicking an external link. (internal link always shows within the current tab) _disableNavbar bool Indicate whether to show the navigation bar on the top of page. _disableBreadcrumb bool Indicate whether to show breadcrumb on the top of page. _disableToc bool Indicate whether to show table of contents on the left of page. _disableAffix bool Indicate whether to show the affix bar on the right of page. _disableContribution bool Indicate whether to show the View Source and Improve this Doc buttons. _gitContribute object Customize the Improve this Doc URL button for public contributors. Use repo to specify the contribution repository URL. Use branch to specify the contribution branch. Use apiSpecFolder to specify the folder for new overwrite files. If not set, the git URL and branch of the current git repository will be used. _gitUrlPattern string Choose the URL pattern of the generated link for View Source and Improve this Doc. Supports github and vso currently. If not set, DocFX will try speculating the pattern from domain name of the git URL. _noindex bool File(s) specified are not returned in search results ","date":"2020-09-13","objectID":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["笔记","DocFx"],"title":"DocFx学习笔记","uri":"/posts/docfx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["爬虫"],"content":"Puppeteer，木偶框架，是谷歌开源的一个浏览器控制框架。它提供了一组可以用来操控Chrome的API，使得我们可以很方便地进行一些浏览器模拟、自动化操作，例如: 生成网页截图或者 PDF 高级爬虫，爬取大量异步渲染内容的网页 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试 捕获站点的时间线，以便追踪网站，帮助分析网站性能问题 至于为什么选择Puppeteer，而不使用Selenium、CEF等其它框架来模拟浏览器操作，是因为Puppeteer有以下优点: Puppeteer是站在用户使用的角度上来设计操作接口，而不是浏览器的角度，使用起来较为简单、更人性化 由Chrome官方团队进行维护，拥有更好的前景 功能比Selenium更强大，可以很方便地对网络请求进行拦截 使用与浏览器相同的语言，与浏览器衔接更好 Puppeteer同样也有缺点，缺点如下: 只支持Chrome、FireFox浏览器，不支持IE浏览器 只支持NodeJs、C#两种语言 Puppeteer实际上为NodeJs的一个库，NodeJs部署也较为简单，首先到NodeJs官网 https://nodejs.org/en/ 配置好NodeJs环境。 之后可以在cmd中运行以下指令安装puppeteer库。 npm install puppeteer --save npm介绍: NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 到此puppeteer环境就已经配置好了，如果要编写puppeteer相关的代码，那么还需要配置一下NodeJs的编程环境，可选的编程环境有 webstorm、Visual Studio、VSCode等。这里笔者使用的是Visual Studio，不要问我为什么，Visual Studio天下第一！ 不过在使用Visual Studio的时候，可能会出现一点问题，例如以下代码 var 百度主页 = \"https://www.baidu.com\"; Visual Studio将无法编译通过，这是因为Visual Studio中的源码默认字符集设置问题，需要将字符集编码改为UTF-8。 但是VS 2019隐藏了高级保存功能，导致没办法直接去设置代码编码为UTF-8。具体开启步骤参考如下: 单击“工具”|“自定义”命令，弹出“自定义”对话框。 单击“命令”标签，进入“命令”选项卡。 在“菜单栏”下拉列表中，选择“文件”选项。 单击“添加命令”按钮，弹出“添加命令”对话框。 在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”按钮，关闭“添加命令”对话框。 选中“控件”列表中的“高级保存选项”选项，单击“上移”或者“下移”按钮，调整该命令的位置。 单击“关闭”按钮，完成“高级保存选项”命令的添加操作。 之后我们就可以通过高级保存选项来设置源码的字符集编码了。 官方API文档:https://zhaoqize.github.io/puppeteer-api-zh_CN/#/，请务必频繁查看此API文档。 Browser类 一个Browser可以理解成一个浏览器实例，这个类较为简单，使用Browser创建Page例子如下: const puppeteer = require('puppeteer'); puppeteer.launch().then(async browser =\u003e { const page = await browser.newPage(); //浏览器创建一个新标签页 await page.goto('https://www.baidu.com'); //标签页导航到指定网址 await browser.close(); //关闭浏览器 }); Page类 这个类最为关键，可能是要用到的最多的一个类。Page提供对单个标签页进行操作的方法，一个Browser实例可以有多个Page实例。 ","date":"2020-09-01","objectID":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["爬虫"],"content":"实际应用场景模拟 就以爬取百度搜索结果为例吧，目标是爬取出指定搜索结果。 1、新建浏览器，定位到页面 ","date":"2020-09-01","objectID":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Puppeteer","自动化","模拟","入门教程"],"title":"Puppeteer入门教程","uri":"/posts/%E7%88%AC%E8%99%AB/puppeteer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"categories":["二进制特征码识别"],"content":"我们首先从数学的角度去考虑，如何对比两个值是否为相似的呢？ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:0","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"1、 欧式距离（Euclidean Distance） 欧式距离全称是欧几里距离，是最易于理解的一种距离计算方式，源自欧式空间中两点间的距离公式。 平面空间内的(x1,y1) 与(x2,y2) 间的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2} $$ 三维空间里的欧式距离： $$ d=\\sqrt{(x1-x2)^2+(y1-y2)^2+(z1-z2)^2} $$ 当两个点之间的距离为0时，代表两个值完全相似，两个点之间的距离越大，则相似度越低。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:1","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"2、 余弦相似度（Cosine） 在坐标中存在两条向量，通过计算两条向量之间的夹角来对比差异。 平面坐标中向量(x1,y1)与向量(x2,y2)之间可以构成一个三角形，根据三角形余弦夹角公式，得到两个向量之间的夹角计算公式如下： $$ \\cos(\\theta) = \\frac{x1x2+y1y2}{\\sqrt{x1^2+y1^2}\\sqrt{x2^2+y2^2}} $$ 余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，夹角等于0，即两个向量相等，这就叫\"余弦相似性\"。 欧式距离和夹角余弦的区别： 夹角余弦更能反映两者之间的变动趋势，两者有很高的变化趋势相似度，而欧式距离较大是因为两者数值有很大的区别，即两者拥有很高的数值差异。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:2","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"3、皮尔逊相关系数（Pearson Correlation Coefficient） pearson相关系数p是一个介于[-1,1]之间的值。 如果p=1，称X与Y完全线性相关; 如果p=0，称X与Y无线性关系; 如果p\u003e0，称X与Y正相关; 如果p\u003c0，称X与Y负相关。 如果两个随机变量相关独立，则它们的相关系数为0；如果两个随机变量的相关系数为0，这两个随机变量却未必独立。 皮尔逊相关系数与余弦相似度较为相似。 在数据标准化后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:3","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"4、汉明距离（Hamming distance） 汉明距离可以理解为两个向量中不相等的值的个数。 例如X为1001，Y为1110，不同的值有3个，汉明距离就是3。 其实说简单点就是暴力对比，相同的点位越多，越相似。 ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:4","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["二进制特征码识别"],"content":"5、曼哈顿距离（Manhattan Distance） 在平面上，坐标(x1,y1)与坐标(x2,y2)之间的曼哈顿距离为: $$ d = |x1-x2|+|y1-y2| $$ ","date":"2020-08-30","objectID":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/:0:5","tags":["相似度","距离"],"title":"相似度对比学习","uri":"/posts/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"},{"categories":["杂文"],"content":"项目管理 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"克隆含有子模块的项目 当一个git项目含有子模块(submodule)时，直接克隆下来的子模块目录里面是空的。 这时可以在执行git clone时加上–recursive参数，它会自动初始化并更新每一个子模块，例如 git clone --recursive https://github.com/x64dbg/x64dbg.git 如果项目已经克隆到了本地，执行下面的步骤： 1.初始化本地子模块配置文件 git submodule init 2.更新项目，抓取子模块内容。 git submodule update ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["杂文"],"content":"配置Git信息 第一次使用git的时候需要配置一下用户名和邮箱 git config --global user.name fjqisba git config --global user.email fjqisba@sohu.com 清空所有的commit 想要删掉仓库中所有的commit，得到一个新的仓库且当前代码不变，可以使用下面的命令 git checkout --orphan newBranch git add -A git commit -am \"commit message\" git branch -D master git branch -m master git push -f origin master 关闭Github的换行符自动转化功能 git config --global core.autocrlf false 搜索功能 1、搜索star数目超过1w的项目，stars:\u003e10000 ","date":"2020-08-23","objectID":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["笔记","Git"],"title":"Git学习笔记","uri":"/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["静态分析"],"content":"当前IDA能用的版本勉强只有一个泄露出安装包+跑出安装包Key的IDA 7.2版本 + x64 Hex-Rays 可以参考一下此文档: https://github.com/jas502n/IDA_Pro_7.2 由于没有完整的Hex-Rays插件，因此只好去杂交7.0版本的Hex-Rays，插件在此下载 。 下载完成后覆盖在IDA目录下，即可拥有IDA7.2 + 7.0 Hex-Rays。 展望未来 目前发现一个IDA7.4比较完整的安装包，但是尚未跑出Key，个人觉得比较悬了，暂且关注一下吧 https://bbs.pediy.com/thread-261050-1.htm 2020年12月23日更新 IDA已泄露出7.5 SP3版本，https://bbs.pediy.com/thread-264354.htm ","date":"2020-08-17","objectID":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/:0:0","tags":["IDA"],"title":"配置IDA环境","uri":"/posts/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/%E9%85%8D%E7%BD%AEida%E7%8E%AF%E5%A2%83/"},{"categories":["Github碎片"],"content":"ZyDis库 Zydis是一个开源的反汇编引擎库，项目地址为:https://github.com/zyantific/zydis。 1.克隆存储库，得到Zydis源码。 2.由于笔者使用的是Windows平台下的Visual Studio环境，因此可以直接运行源码目录zydis\\msvc\\Zydis.sln的工程。 3.在工程中编译库，大致分为DLL动态库或者静态库两种方式，笔者比较喜欢静态编译的方式，因此工程配置选择Release MT，编译x86和x64两个版本的库。 4.提取出include头文件和lib文件，即得到反汇编引擎库。 新建一个测试工程 1.附加包含目录中添加Zydis\\include 2.附加库目录视编译平台选择Zydis\\lib\\X86或者Zydis\\lib\\X64 3.附加依赖项中添加Zycore.lib和Zydis.lib 4.预处理器定义中添加两行 ZYCORE_STATIC_DEFINE\rZYDIS_STATIC_DEFINE 编写代码进行测试，可以正常地使用Zydis库函数，则代表反汇编引擎配置成功! ","date":"2020-08-16","objectID":"/posts/github%E7%A2%8E%E7%89%87/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/:0:1","tags":["反汇编引擎","ZyDis"],"title":"反汇编引擎","uri":"/posts/github%E7%A2%8E%E7%89%87/%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BC%95%E6%93%8E/"},{"categories":null,"content":"PyQt库 使用Qt构造Python界面 pip install PyQt5 -i https://pypi.douban.com/simple ","date":"0001-01-01","objectID":"/posts/python/pyqt%E5%BA%93/:0:0","tags":null,"title":"","uri":"/posts/python/pyqt%E5%BA%93/"},{"categories":null,"content":"WxPython界面库 安装方式 pip install wxpython -i https://pypi.douban.com/simple ","date":"0001-01-01","objectID":"/posts/python/wxpython%E7%95%8C%E9%9D%A2%E5%BA%93/:0:0","tags":null,"title":"","uri":"/posts/python/wxpython%E7%95%8C%E9%9D%A2%E5%BA%93/"},{"categories":null,"content":"某蛋糕软件 这个软件全程联网，导入图片和导出功能都是要经过服务器运算的，无法完成完美的破解。 ","date":"0001-01-01","objectID":"/posts/windows%E9%80%86%E5%90%91/%E6%9F%90%E8%9B%8B%E7%B3%95%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"","uri":"/posts/windows%E9%80%86%E5%90%91/%E6%9F%90%E8%9B%8B%E7%B3%95%E8%BD%AF%E4%BB%B6/"},{"categories":null,"content":"梦幻软件 pytyon魔改解释器 + ","date":"0001-01-01","objectID":"/posts/windows%E9%80%86%E5%90%91/%E6%A2%A6%E5%B9%BB%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"","uri":"/posts/windows%E9%80%86%E5%90%91/%E6%A2%A6%E5%B9%BB%E8%BD%AF%E4%BB%B6/"},{"categories":null,"content":"进程的PEB和TEB学习 mov eax,fs:[0x18] 存储的是TEB结构 mov eax,fs:[0x30] 存储的是PEB结构 TEB也称作是 32位进程下TEB的结构如下: struct _TEB32 { //占用大小是0x1C struct _NT_TIB32 NtTib{ ULONG ExceptionList; ULONG StackBase; ULONG StackLimit; ULONG SubSystemTib; union { ULONG FiberData; ULONG Version; } ULONG ArbitraryUserPointer; ULONG Self; //指向自己的指针,也是fs:[0x18]的来源 } ULONG EnvironmentPointer; struct CLIENT_ID{ HANDLE UniqueProcess; HANDLE UniqueThread; } PVOID ActiveRpcHandle; PVOID ThreadLocalStoragePointer; PEB* ProcessEnvironmentBlock; //指向PEB,也是fs:[0x30]的来源 //... } ","date":"0001-01-01","objectID":"/posts/windows%E9%80%86%E5%90%91/%E8%BF%9B%E7%A8%8B%E7%9A%84peb%E5%92%8Cteb%E5%8F%8A%E5%AD%A6%E4%B9%A0/:0:0","tags":null,"title":"","uri":"/posts/windows%E9%80%86%E5%90%91/%E8%BF%9B%E7%A8%8B%E7%9A%84peb%E5%92%8Cteb%E5%8F%8A%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"Flutter https://github.com/iampawan/FlutterExampleApps ，这个项目收录了一些基础的flutter项目。 https://github.com/mitesh77/Best-Flutter-UI-Templates ，这个是某位大哥写的app/ios项目，MIT协议可供参考。 https://flutter.github.io/samples/#?platform=web ，官方的例子。 ","date":"0001-01-01","objectID":"/posts/%E5%89%8D%E7%AB%AF/flutter/:0:0","tags":null,"title":"","uri":"/posts/%E5%89%8D%E7%AB%AF/flutter/"},{"categories":null,"content":"编译代码出错 1、Connect to 127.0.0.1:1080 [/127.0.0.1] failed: Connection refused: connect，这是因为Android Studio存在使用代理的Bug，解决方式是修改C:\\Users\\Administrator\\.gradle\\gradle.properties文件，填写正确的代理端口，例如 systemProp.http.proxyHost=127.0.0.1\rsystemProp.https.proxyHost=127.0.0.1\rsystemProp.https.proxyPort=10809\rsystemProp.http.proxyPort=10809 ","date":"0001-01-01","objectID":"/posts/%E5%89%8D%E7%AB%AF/flutter/:1:0","tags":null,"title":"","uri":"/posts/%E5%89%8D%E7%AB%AF/flutter/"},{"categories":null,"content":"Sleigh负责将二进制转换成PCode代码 ","date":"0001-01-01","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bsleigh%E7%BC%96%E8%AF%91/:0:0","tags":null,"title":"","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/ghidra%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bsleigh%E7%BC%96%E8%AF%91/"},{"categories":null,"content":"新手学习Ghida反编译之项目搭建 反编译是逆向的核心，然而这方面的研究似乎并不多，ida反编译固然强大，然而对外只提供了残缺的sdk，retdec更倾向于是实验品，且已停止维护。Ghidra是目前能在网上找到的最强开源反编译器了。 因此写一篇记录方便更多人入门学习该项目。 项目地址: https://github.com/NationalSecurityAgency/ghidra 其中界面和逻辑处理部分的代码是用java写的，然而核心的反编译部分是用C++写的，完全可以剥离出来一个独立项目。 反编译部分的代码位于https://github.com/NationalSecurityAgency/ghidra/tree/master/Ghidra/Features/Decompiler/src/decompile/cpp 使用Visual Studio新建一个空项目，直接拖入全部的代码，然后编译之。。。 这样肯定是不能通过的，需要进行一些项目修复: 1、在C/C++ -\u003e 预处理器上添加预处理器定义 _CRT_SECURE_NO_WARNINGS\r_WINDOWS C/C++ -\u003e 常规 -\u003e SDL检查，改为否 高级 -\u003e 字符集，使用多字节字符集 2、处理loadimage_bfd文件 由于loadimage_bfd类中引用了bfd这个库，这个类主要是用来解析PE、符号，读取二进制数据相关的功能，而msvc编译器是不支持的，因此可以直接移除loadimage_bfd.hh、loadimage_bfd.cc、bfd_arch.hh、bfd_arch.cc这几个文件，或者自己写个类来代替。 ghidra_process.cc、sleighexample.cc、slgh_compile.cc、test.cc、consolemain.cc这几个文件中有main函数，想编译哪个项目，就移除其它的cc文件即可。 test.cc看起来像是做单元测试用的，直接移除。 ghidra_process看起来像是编译一个反编译后台进程给Ghidra前端用的，也直接移除。 slgh_compile.cc看起来像是和Sleigh编译器有关，这里抄一下gpt的解释 在Ghidra项目中，slgh_compile.cc文件是用于编译Sleigh语言的编译器的源代码文件。Sleigh语言是一种特定于Ghidra的领域特定语言（DSL），用于描述处理器指令集的语义和模式。 Sleigh编译器负责将Sleigh语言描述的处理器指令集编译成中间表示形式，以便Ghidra可以使用它来进行二进制代码的逆向工程和分析。slgh_compile.cc文件实现了Sleigh编译器的主要逻辑和算法。 这里暂时用不上，如果要移除，需要将与之有关的slghparse、slghscan文件也一并移除，或者直接去掉main函数。 sleighexample.cc比较有用，作用是输入一段二进制，可以用来反汇编、打印pcode或者是模拟执行。 consolemain.cc算是一个完整的控制台，输入一个文件，可以执行反编译打印源码等一系列操作。 这里只说明一下consolemain这个项目，首先里面有一个startDecompilerLibrary函数，这个函数作用是用扫描sleigh一些预定义数据文件的，这个文件一般在Ghidra/Processors/*/data/languages目录里面，函数参数的话传入Ghidra反编译程序的根目录就行了。之前说的loadimage类，需要自己进行补充，这里可以参考一下这个项目https://github.com/airbus-cert/Yagi/blob/main/yagi/src/idaloader.cc 跑起来后是一个控制台，输入类似下面的命令: load file C:\\123.exe load addr 0x401000 decompile print C 就能够完成反编译流程，输出源码文件了。 ","date":"0001-01-01","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0ghida%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/:0:0","tags":null,"title":"","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0ghida%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"ghidra中函数在创建的时候会使用架构中对应的默认Model，例如x86下面就是stdcall void FuncProto::setScope(Scope *s,const Address \u0026startpoint) { store = new ProtoStoreSymbol(s,startpoint); if (model == (ProtoModel *)0) setModel(s-\u003egetArch()-\u003edefaultfp); } 但是很明显在vmp架构中函数块不是stdcall，我们 ","date":"0001-01-01","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0vmp%E4%B9%8Bhandler%E8%AF%86%E5%88%AB/:0:0","tags":null,"title":"","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0vmp%E4%B9%8Bhandler%E8%AF%86%E5%88%AB/"},{"categories":null,"content":"新手学习Vmp之控制流程图生成 控制流程图的生成对于反混淆分析来说是非常重要的一步，这里记录一下我研究的过程，以Vmp2为例子。 这里我的环境准备如下: Visual Studio + IDA SDK + Capstone + Unicorn + Graphviz IDA SDK插件环境，主要是有一些API可以调用，方便编写代码，X64Dbg插件环境可以替代之。 Capstone，一个很不错的反汇编引擎，IDA自带的反汇编引擎不太好用，用这个替代之。 Unicorn，指令模拟执行，用来跟踪指令。 Graphviz，一个绘图工具，可以将控制流程图可视化。 要生成流程图，首先使用unicron引擎对指令进行跟踪，大致步骤如下: 1、使用uc_mem_map和uc_mem_write函数填充内存区域和堆栈 2、uc_hook_add设置监视函数，每次执行指令前检查退出条件，例如当前指令位于text区段且上一条指令是ret的时候，基本上就是vmp结束的时候了。 3、uc_emu_start进行trace，拿到所有的指令跟踪数组。 之后是根据这些地址动态生成控制流程图，这里了解一下基本块这个概念就行了。 在遍历地址的过程中动态生成流程图，核心逻辑如下: bool VmpTraceFlowGraph::GenerateBasicFlowData(std::vector\u003cea_t\u003e\u0026 traceList) { if (!traceList.size()) { return false; } cs_insn* curIns; VmpTraceFlowNode* currentNode = createNode(traceList[0]);; for (unsigned int n = 0; n \u003c traceList.size(); ++n) { const ea_t\u0026 curAddr = traceList[n]; if (!DisasmManager::DecodeInstruction(curAddr, curIns)) { return false; } //不管是什么指令,都立即追加到当前基本块 if (!currentNode-\u003ebTraced) { currentNode-\u003eaddrList.push_back(curAddr); updateInstructionToBlockMap(curAddr, currentNode); } //判断是否为终止指令 if (isEndIns(curIns)) { //检查是否为最后一条指令 if (n + 1 \u003e= traceList.size()) { break; } currentNode-\u003ebTraced = true; //这里开始进行核心判断 ea_t nextNodeAddr = traceList[n + 1]; VmpTraceFlowNode* nextNode = instructionToBlockMap[nextNodeAddr]; linkEdge(curAddr, nextNodeAddr); //下一个节点是新节点 if (!nextNode) { currentNode = createNode(nextNodeAddr); } //已访问过该节点,且节点指向Block头部 else if (nextNode-\u003enodeEntry == nextNodeAddr) { currentNode = nextNode; } else { //节点指向已有区块其它地址,需要对区块进行分割 currentNode = splitBlock(nextNode, nextNodeAddr); } } } return true; } 再进行节点合并优化，核心代码是这样的: void VmpTraceFlowGraph::MergeNodes() { //已确定无法合并的节点 std::set\u003cea_t\u003e badNodeList; bool bUpdateNode; do { bUpdateNode = false; std::map\u003cea_t, VmpTraceFlowNode\u003e::iterator it = nodeMap.begin(); while (it != nodeMap.end()) { ea_t nodeAddr = it-\u003efirst; if (badNodeList.count(nodeAddr)) { it++; continue; } //判断合并条件 //条件1,指向子节点的边只有1条 if (toEdges[nodeAddr].size() == 1) { ea_t fromAddr = *toEdges[nodeAddr].begin(); VmpTraceFlowNode* fatherNode = instructionToBlockMap[fromAddr]; //条件2,父节点指向的边也只有1条 if (fromEdges[fromAddr].size() == 1) { //条件3,子节点不能指向父节点 if (!fromEdges[nodeAddr].count(fatherNode-\u003eaddrList[fatherNode-\u003eaddrList.size() - 1])) { executeMerge(fatherNode, \u0026it-\u003esecond); bUpdateNode = true; it = nodeMap.erase(it); continue; } } } badNodeList.insert(nodeAddr); it++; } } while (bUpdateNode); } 最后是将流程图转换成dot语言，核心代码如下: std::string VmpTraceFlowGraph::DumpGraph() { std::stringstream ss; ss \u003c\u003c \"strict digraph \\\"hello world\\\"{\\n\"; cs_insn* tmpIns = 0x0; char addrBuffer[0x10]; for (std::map\u003cea_t, VmpTraceFlowNode\u003e::iterator it = nodeMap.begin(); it != nodeMap.end(); ++it) { VmpTraceFlowNode\u0026 node = it-\u003esecond; sprintf_s(addrBuffer, sizeof(addrBuffer), \"%08X\", it-\u003efirst); ss \u003c\u003c \"\\\"\" \u003c\u003c addrBuffer \u003c\u003c \"\\\"[label=\\\"\"; for (unsigned int n = 0; n \u003c node.addrList.size(); ++n) { //测试代码 if (n \u003e 20 \u0026\u0026 (n != node.addrList.size() - 1)) { continue; } DisasmManager::DecodeInstruction(node.addrList[n], tmpIns); sprintf_s(addrBuffer, sizeof(addrBuffer), \"%08X\", node.addrList[n]); ss \u003c\u003c addrBuffer \u003c\u003c \"\\t\" \u003c\u003c tmpIns-\u003emnemonic \u003c\u003c \" \" \u003c\u003c tmpIns-\u003eop_str \u003c\u003c \"\\\\n\"; } ss \u003c\u003c \"\\\"];\\n\"; } for(std::map\u003cea_t, std::unordered_set\u003cea_t\u003e\u003e::iterator it = fromEdges.begin(); it != fromEdges.end(); ++it){ std::unordered_set\u003cea_t\u003e\u0026 edgeList = it-\u003esecond; for (std::unordered_set\u003cea_t\u003e::iterator edegIt = edgeList.begin(); edegIt != edgeList.end(); ++edegIt) { VmpTraceFlowNode* fromBlock = instructionToBlockMap[it-\u003efirst]; sprintf_s(addrBuffer, sizeof(addrBuffer), \"%08X\", fromBlock-\u003enodeEntry); ss \u003c\u003c \"\\\"\" \u003c\u003c addrBuffer \u003c\u003c \"\\\" -\u003e \"; sprintf_s(addrBuffer, sizeof(addrBuffer), \"%08X\", *edegIt); ss \u003c\u003c \"\\\"\" \u003c\u003c addrBuffer \u003c\u003c \"\\\";\\n\"; } } ss \u003c\u003c \"\\n}\"; return ss.str(); } 得到文件后，调用dot命令行打印出流程图 dot graph.txt -T png -o vmp2.png ","date":"0001-01-01","objectID":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0vmp%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%94%9F%E6%88%90/:0:0","tags":null,"title":"","uri":"/posts/%E5%8F%8D%E7%BC%96%E8%AF%91/%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0vmp%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%94%9F%E6%88%90/"},{"categories":null,"content":"安卓群控脚本编写 ","date":"0001-01-01","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/:1:0","tags":null,"title":"","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":"easyclick 官网:https://ieasyclick.com/ 198元/年，质量一般般吧。 ","date":"0001-01-01","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/:2:0","tags":null,"title":"","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":"UiAutomator2 项目地址:https://github.com/openatx/uiautomator2 1、安装https://github.com/openatx/weditor，用于查看控件，命令行如下: pip3 install -U weditor 如果安装遇到错误，在命令行中试试运行命令 set PYTHONUTF8=1 安装完成后，运行weditor --shortcut添加桌面快捷方式。 ","date":"0001-01-01","objectID":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/:3:0","tags":null,"title":"","uri":"/posts/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/%E5%AE%89%E5%8D%93%E7%BE%A4%E6%8E%A7%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":"YY逆向分析 账号 2910828889—-jf121121—-16217435942–封 2910699550—-jf121121—-16217436058-封 2910825704—-jf121121—-16217436101-封 2910497760—-jf121121—-16217436045 2910812781—-jf121121—-16217436029 2910481366—-jf121121—-16217436012 2910630046—-jf121121—-16217435884 2910805973—-jf121121—-16217436054 2910762356—-jf121121—-16217436038 1459261448 YYID = 2910353707，UID = 2911777559，0xAD8E3317，1号 YYID = 2910828889，UID = 2911879942，0xAD8FC306，2号 YY频道相关 频道主界面左侧的频道列表树YYChannelTreeMenuReactor ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:1:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"YY频道封入黑名单 YYChannelTreeMenuReactor::onSigBanUser ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:2:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取频道用户信息 YYChannelTreeMenuReactor::on_personalInfo_triggered ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:3:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取接待频道 CChannelManagerOp::asyncChangeJiedaiSid ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:4:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"新用户监控 SInfoUserMgr::onPushChannelUser CBizChannelDataBase::slotOnFullUserListViewAdd YYChannelUserTreeWidget::onUserTableNotify row dump: table=%s, ptr=0x%08X(%u), ref=%d, %s DuiHPTreeModel::batchUpdateItems ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:5:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"设置用户马甲 YYChannelTreeMenuReactor::on_addTempVIP_triggered YYChannelTreeMenuReactor::makeUserAs YYChannelManageWrapper::makeUserAs 似乎有一个权限检查CChannelRulerChecker::_canDo，直接调用无效 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:6:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"发送频道消息 控件为YYChannelPage yychannel.dll中的YYChannelSendPanelWidget::on_sendButtonClicked yycefchannel.dll中的YYChannelMessage::sendPublicMessage -\u003e channellogic.dll中的YYChannelMessageLogicWrapper::sendMessage3 -\u003e yychannel.dll中的YYChannelMessageEdit::addCommand -\u003e widgetchannel.dll中的YYChannelMessageEdit::on_commandAppend ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:7:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"登录 YYLoginWidget::on_loginButton_clicked，点击登录按钮 yymainframe.dll中的YYLoginWrapper::on_updateLoginCredit函数，这里能拿到yyid。 appmain.dll中的AppWindowManager::realLogin，完成登录，这里能分析清楚账号是存哪里了。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:8:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"YY频道的设置页面 位于yycommon.dll中的YYChannelInfoSettingPage类中 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:9:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取当前用户账号真实ID appmain.dll -\u003e bizcore.dll -\u003e LoginWrapper.dll 通过yycommon.dll中的yyim::getImId公开函数获取即可 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:10:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取当前账户的YYID YYLoginWrapper::on_login_opened，此时登录完毕，关键字符串是strAccountYYid ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:11:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取当前频道ID 通过yycommon.dll中的yychannel::currentChannelId公开函数获取即可 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:12:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取当前子频道ID 通过yycommon.dll中的yychannel::currentSubChannelId公开函数获取即可 或者CChannel::getCurSubSid ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:13:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取当前子频道短位ID 核心位于bizchannel.dll中的CChannel::getAsid函数。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:14:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"修改个性签名 核心是appmain.dll中的YYInfoPanel类，找到YYInfoPanel类的metacall即可。 YYInfoPanel::on_signEditLabel_clicked -\u003e YYInfoPanel::on_signEditLabel_editLeft -\u003e YYInfoPanel::on_signEditLabel_submit ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:15:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"修改昵称 和修改个性签名一样。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:16:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"修改频道字体 yychannel.dll中的YYChannelSendPanelWidget::on_FontChanged函数。 yycommon.dll中的YYChannelSmileWrapper::on_fontChanged函数。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:17:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"修改频道字体颜色 yychannel.dll中的YYChannelSendPanelWidget::on_FontColorChanged函数。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:18:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"发送频道广播消息 yychannel.dll中的YYChannelBroadcastDlg::on_sendButton_clicked函数。 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:19:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"屏蔽频道广播消息 channellogic.dll中的YYChannelMessageLogicWrapper::onMessageArrived函数 YYChannelMsgReceiver::on_broadCastMessageArrived2 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:20:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"发送多张图片消息 widgetchannel.dll，Only can send one picture ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:21:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取频道列表 频道信息界面，yycommon.dll中的YYChannelInfoSettingPage YYChannelUserTreeWidget::onChannelAdd ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:22:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"删除子频道 YYChannelMgrPwd::on_deleteSubChannelInformationDlg_buttonClicked CChannelManagerOp::asyncDestroySubChannel ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:23:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"修改接待频道 CChannelManagerOp::asyncChangeJiedaiSid ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:24:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"创建子频道 YYCreateSubChannel::on_channelName_editingFinished ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:25:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"监控频道消息 各种各样的动作 YYChannelEchoMessageReceiver::onUserJoinByModified [[U]%1[/U]] joined [%2]channel 顺序是 YYChannelEchoMessageReceiver::echoMessage -\u003e YYChannelMsgReceiver::onEchoMessageArrived -\u003e YYChannelMessageLogicWrapper::onMessageArrived和YYChannelMessageLogicWrapper::on_myselfMessageArrived -\u003e YYChannelMessageExWrapper::onMessageArrived 监控自己发的消息，关键点GetSendMessageInfo ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:26:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"新建子频道 yychannel.dll中的YYCreateSubChannel类 -\u003e bizchannel.dll中的CChannelManagerOp::asyncCreateSubChannel 麦序功能 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:27:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"设置自由模式 YYMicrophonePannel::on_freeStyle_triggered CChannelManagerOp::asyncChangeChannelStyle ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:28:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取麦序用户列表 YYChannelAudioPannel::_dealwithUpdateSpeakState 这个函数会获取用户列表 YYMicrophonePannel::init，虚函数，关键字符串labelMicphoneStyle上方 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:29:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"和1号连麦 YYChannelTreeMenuReactor::on_push2MutiMai_triggered(bool checked) ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:30:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"和2号连麦 YYChannelTreeMenuReactor::on_push2MutiMai_triggered(bool checked) ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:31:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"从麦序中移除 YYChannelTreeMenuReactor::on_removeFromMaixu_triggered ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:32:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"将用户麦序上移 YYChannelTreeMenuReactor::on_moveUp ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:33:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"将用户调整到2号麦序 YYChannelTreeMenuReactor::on_move2Top_triggered ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:34:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"发送麦序提醒 YYChannelTreeMenuReactor::on_notifySecondMaixu_triggered ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:35:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"添加到麦序 YYChannelTreeMenuReactor::addMicOrderList ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:36:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"发言模式 YYChannelAudioPannel::on_speakStyleButton_clicked YYChannelAudioPannel::updateSpeakStyleButton speakStyleButton ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:37:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"放麦和控麦 YYMicrophonePannel::on_micControlButton_clicked ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:38:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"禁麦和开麦 YYMicrophonePannel::on_queueControlButton_clicked YYChannelMaiXuListWrapper::forbidMaixu ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:39:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"抢麦和下麦 YYChannelMaiXuListWrapper::joinMaixu YY群 ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:40:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"获取群消息 yycommon.dll中的ChatInformation类 bizim.dll中的CGroupText::OnGChatMsgArrive ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:41:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"真群号转文本群号 SIG_ON_GROUP_DETAILINFO protocol::gprops::CGProperty::GetGroupProps CGroupList::_asyncGetGroupAliasNumber CGroupSetting::_bizsyncFetGroupDetailInfo ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:42:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"关于界面 DuiXmlUI::createFromFile ","date":"0001-01-01","objectID":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/:43:0","tags":null,"title":"","uri":"/posts/%E6%9D%82%E6%96%87/yy%E8%AF%AD%E9%9F%B3%E5%8F%91%E6%B6%88%E6%81%AF/"},{"categories":null,"content":"Switch模拟器指南 Switch模拟器，有Yuzu和龙神这两款。 每个switch都需要一个和用户关联的key，游戏也和key加解密有关。下载网上公开的key就行了，https://prodkeys.net/ ","date":"0001-01-01","objectID":"/posts/%E6%B8%B8%E6%88%8F/switch%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%8C%87%E5%8D%97/:0:0","tags":null,"title":"","uri":"/posts/%E6%B8%B8%E6%88%8F/switch%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"逆向人生。 语言:C++、Python、Go、易语言。欢迎学习交流。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"作者信息","uri":"/about/"}]